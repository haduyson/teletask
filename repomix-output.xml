This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  .env.example
config/
  __init__.py
  settings.py
database/
  migrations/
    versions/
      20241214_0001_initial_schema.py
      20241215_0002_recurring_templates.py
      20251215_0003_group_tasks.py
      20251216_0004_export_reports.py
      20251216_0005_reminder_source.py
      20251216_0006_calendar_sync_interval.py
      20251217_0001_notification_settings.py
      20251217_0007_user_reminder_prefs.py
      20251218_0009_task_id_sequence.py
    env.py
    script.py.mako
  __init__.py
  connection.py
  models.py
handlers/
  __init__.py
  calendar.py
  callbacks.py
  export.py
  recurring_task.py
  reminder.py
  settings.py
  start.py
  statistics.py
  task_assign.py
  task_create.py
  task_delete.py
  task_update.py
  task_view.py
  task_wizard.py
monitoring/
  __init__.py
  alert.py
  health_check.py
  metrics.py
  resource_monitor.py
scheduler/
  __init__.py
  reminder_scheduler.py
  report_scheduler.py
services/
  __init__.py
  calendar_service.py
  notification.py
  oauth_callback.py
  recurring_service.py
  reminder_service.py
  report_service.py
  statistics_service.py
  task_service.py
  time_parser.py
  user_service.py
static/
  config.json
  index.html
  user-guide.html
  user-guide.md
utils/
  __init__.py
  db_utils.py
  formatters.py
  keyboards.py
  messages.py
  validators.py
.gitignore
.repomixignore
alembic.ini
bot.py
CLAUDE.md
ecosystem.config.js
requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/.env.example">
# Claude Code - Global Environment Variables
# Location: .claude/.env
# Priority: LOWEST (overridden by skills/.env and skill-specific .env)
# Scope: Project-wide configuration, global defaults
# Setup: Copy to .claude/.env and configure

# ============================================
# Environment Variable Hierarchy
# ============================================
# Priority order (highest to lowest):
# 1. process.env                    - Runtime environment (HIGHEST)
# 2. .claude/skills/<skill>/.env    - Skill-specific overrides
# 3. .claude/skills/.env            - Shared across all skills
# 4. .claude/.env                   - Global defaults (this file, LOWEST)
#
# All skills use centralized resolver: ~/.claude/scripts/resolve_env.py
# Debug hierarchy: python ~/.claude/scripts/resolve_env.py --show-hierarchy

# ============================================
# Claude Code Notification Hooks
# ============================================
# Discord Webhook URL (for Discord notifications)
# Get from: Server Settings → Integrations → Webhooks → New Webhook
DISCORD_WEBHOOK_URL=

# Telegram Bot Token (for Telegram notifications)
# Get from: @BotFather in Telegram
TELEGRAM_BOT_TOKEN=

# Telegram Chat ID (your chat ID or group ID)
# Get from: https://api.telegram.org/bot<BOT_TOKEN>/getUpdates
TELEGRAM_CHAT_ID=

# ============================================
# AI/ML API Keys (Global Defaults)
# ============================================
# Google Gemini API (for ai-multimodal, docs-seeker skills)
# Get from: https://aistudio.google.com/apikey
GEMINI_API_KEY=

# Vertex AI Configuration (Optional alternative to AI Studio)
# GEMINI_USE_VERTEX=true
# VERTEX_PROJECT_ID=
# VERTEX_LOCATION=us-central1

# OpenAI API Key (if using OpenAI-based skills)
# OPENAI_API_KEY=

# Anthropic API Key (if using Claude API directly)
# ANTHROPIC_API_KEY=

# ============================================
# Development & CI/CD
# ============================================
# NODE_ENV=development
# DEBUG=false
# LOG_LEVEL=info

# ============================================
# Project Configuration
# ============================================
# PROJECT_NAME=claudekit-engineer
# ENVIRONMENT=local

# ============================================
# Example Usage Scenarios
# ============================================
# Scenario 1: Global default for all skills
# .claude/.env (this file):                GEMINI_API_KEY=global-dev-key
# Result: All skills use global-dev-key
#
# Scenario 2: Override for all skills
# .claude/.env (this file):                GEMINI_API_KEY=global-dev-key
# .claude/skills/.env:                     GEMINI_API_KEY=skills-prod-key
# Result: All skills use skills-prod-key
#
# Scenario 3: Skill-specific override
# .claude/.env (this file):                GEMINI_API_KEY=global-key
# .claude/skills/.env:                     GEMINI_API_KEY=shared-key
# .claude/skills/ai-multimodal/.env:       GEMINI_API_KEY=high-quota-key
# Result: ai-multimodal uses high-quota-key, other skills use shared-key
#
# Scenario 4: Runtime testing
# export GEMINI_API_KEY=test-key
# Result: All skills use test-key regardless of config files
#
# Priority: runtime > skill-specific > shared > global (this file)
</file>

<file path="config/__init__.py">
"""
Bot Configuration Module
"""

from .settings import Settings, get_settings

__all__ = ["Settings", "get_settings"]
</file>

<file path="config/settings.py">
"""
Bot Settings Configuration
Loads and validates environment variables
"""

import os
from dataclasses import dataclass, field
from functools import lru_cache
from typing import List, Optional

from dotenv import load_dotenv

load_dotenv()


@dataclass
class Settings:
    """Application settings loaded from environment variables."""

    # Telegram
    bot_token: str = field(default_factory=lambda: os.getenv("BOT_TOKEN", ""))
    bot_name: str = field(default_factory=lambda: os.getenv("BOT_NAME", "TeleTask"))

    # Database
    database_url: str = field(
        default_factory=lambda: os.getenv("DATABASE_URL", "")
    )
    db_pool_min: int = field(
        default_factory=lambda: int(os.getenv("DB_POOL_MIN", "2"))
    )
    db_pool_max: int = field(
        default_factory=lambda: int(os.getenv("DB_POOL_MAX", "10"))
    )

    # Timezone
    timezone: str = field(
        default_factory=lambda: os.getenv("TZ", "Asia/Ho_Chi_Minh")
    )

    # Logging
    log_level: str = field(default_factory=lambda: os.getenv("LOG_LEVEL", "INFO"))
    log_file: Optional[str] = field(default_factory=lambda: os.getenv("LOG_FILE"))

    # Admin
    admin_ids: List[int] = field(default_factory=list)

    # Features
    google_calendar_enabled: bool = field(
        default_factory=lambda: os.getenv("GOOGLE_CALENDAR_ENABLED", "false").lower()
        == "true"
    )
    google_credentials_file: Optional[str] = field(
        default_factory=lambda: os.getenv("GOOGLE_CREDENTIALS_FILE")
    )

    metrics_enabled: bool = field(
        default_factory=lambda: os.getenv("METRICS_ENABLED", "false").lower() == "true"
    )
    metrics_port: int = field(
        default_factory=lambda: int(os.getenv("METRICS_PORT", "9090"))
    )

    redis_enabled: bool = field(
        default_factory=lambda: os.getenv("REDIS_ENABLED", "false").lower() == "true"
    )
    redis_url: str = field(
        default_factory=lambda: os.getenv("REDIS_URL", "redis://localhost:6379/0")
    )

    def __post_init__(self) -> None:
        """Parse complex fields after initialization."""
        # Parse admin IDs
        admin_ids_str = os.getenv("ADMIN_IDS", "")
        if admin_ids_str:
            self.admin_ids = [
                int(id_.strip())
                for id_ in admin_ids_str.split(",")
                if id_.strip().isdigit()
            ]

    def validate(self) -> None:
        """Validate required settings."""
        if not self.bot_token:
            raise ValueError("BOT_TOKEN is required")
        if not self.database_url:
            raise ValueError("DATABASE_URL is required")

    def is_admin(self, user_id: int) -> bool:
        """Check if user ID is an admin."""
        return user_id in self.admin_ids


@lru_cache()
def get_settings() -> Settings:
    """Get cached settings instance."""
    settings = Settings()
    settings.validate()
    return settings
</file>

<file path="database/migrations/versions/20241214_0001_initial_schema.py">
"""Initial schema - Create all tables

Revision ID: 0001
Revises:
Create Date: 2024-12-14

Creates:
- users: Telegram users
- groups: Telegram groups
- group_members: User-group relationships
- tasks: Main task table
- reminders: Scheduled reminders
- task_history: Audit trail
- user_statistics: Aggregated stats
- deleted_tasks_undo: Undo buffer
- bot_config: Key-value settings
"""

from typing import Sequence, Union
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers
revision: str = "0001"
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # 1. Users table
    op.create_table(
        "users",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("telegram_id", sa.BigInteger(), nullable=False),
        sa.Column("username", sa.String(255), nullable=True),
        sa.Column("first_name", sa.String(255), nullable=True),
        sa.Column("last_name", sa.String(255), nullable=True),
        sa.Column("display_name", sa.String(500), nullable=True),
        sa.Column("timezone", sa.String(50), server_default="Asia/Ho_Chi_Minh"),
        sa.Column("language", sa.String(10), server_default="vi"),
        sa.Column("notify_reminder", sa.Boolean(), server_default="true"),
        sa.Column("notify_weekly_report", sa.Boolean(), server_default="true"),
        sa.Column("notify_monthly_report", sa.Boolean(), server_default="true"),
        sa.Column("google_calendar_token", sa.Text(), nullable=True),
        sa.Column("google_calendar_refresh_token", sa.Text(), nullable=True),
        sa.Column("is_active", sa.Boolean(), server_default="true"),
        sa.Column("created_at", sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.Column("updated_at", sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("telegram_id"),
    )
    op.create_index("idx_users_telegram", "users", ["telegram_id"])
    op.create_index("idx_users_username", "users", ["username"], postgresql_where="username IS NOT NULL")

    # 2. Groups table
    op.create_table(
        "groups",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("telegram_id", sa.BigInteger(), nullable=False),
        sa.Column("title", sa.String(255), nullable=True),
        sa.Column("is_active", sa.Boolean(), server_default="true"),
        sa.Column("created_at", sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.Column("updated_at", sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("telegram_id"),
    )
    op.create_index("idx_groups_telegram", "groups", ["telegram_id"])

    # 3. Group members table
    op.create_table(
        "group_members",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("group_id", sa.Integer(), nullable=False),
        sa.Column("user_id", sa.Integer(), nullable=False),
        sa.Column("role", sa.String(50), server_default="member"),
        sa.Column("joined_at", sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.PrimaryKeyConstraint("id"),
        sa.ForeignKeyConstraint(["group_id"], ["groups.id"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["user_id"], ["users.id"], ondelete="CASCADE"),
        sa.UniqueConstraint("group_id", "user_id", name="uq_group_user"),
    )
    op.create_index("idx_gm_group", "group_members", ["group_id"])
    op.create_index("idx_gm_user", "group_members", ["user_id"])

    # 4. Tasks table
    op.create_table(
        "tasks",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("public_id", sa.String(20), nullable=False),
        sa.Column("group_task_id", sa.String(20), nullable=True),
        sa.Column("content", sa.Text(), nullable=False),
        sa.Column("description", sa.Text(), nullable=True),
        sa.Column("status", sa.String(20), server_default="pending", nullable=False),
        sa.Column("priority", sa.String(20), server_default="normal", nullable=False),
        sa.Column("progress", sa.Integer(), server_default="0"),
        sa.Column("creator_id", sa.Integer(), nullable=True),
        sa.Column("assignee_id", sa.Integer(), nullable=True),
        sa.Column("group_id", sa.Integer(), nullable=True),
        sa.Column("deadline", sa.DateTime(timezone=True), nullable=True),
        sa.Column("completed_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("is_recurring", sa.Boolean(), server_default="false"),
        sa.Column("recurring_pattern", sa.String(100), nullable=True),
        sa.Column("recurring_config", postgresql.JSONB(), nullable=True),
        sa.Column("parent_recurring_id", sa.Integer(), nullable=True),
        sa.Column("google_event_id", sa.String(255), nullable=True),
        sa.Column("is_personal", sa.Boolean(), server_default="false"),
        sa.Column("is_deleted", sa.Boolean(), server_default="false"),
        sa.Column("deleted_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("deleted_by", sa.Integer(), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.Column("updated_at", sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("public_id"),
        sa.ForeignKeyConstraint(["creator_id"], ["users.id"]),
        sa.ForeignKeyConstraint(["assignee_id"], ["users.id"]),
        sa.ForeignKeyConstraint(["group_id"], ["groups.id"]),
        sa.ForeignKeyConstraint(["parent_recurring_id"], ["tasks.id"]),
        sa.ForeignKeyConstraint(["deleted_by"], ["users.id"]),
        sa.CheckConstraint("status IN ('pending', 'in_progress', 'completed')", name="ck_task_status"),
        sa.CheckConstraint("priority IN ('low', 'normal', 'high', 'urgent')", name="ck_task_priority"),
        sa.CheckConstraint("progress >= 0 AND progress <= 100", name="ck_task_progress"),
    )
    op.create_index("idx_tasks_public", "tasks", ["public_id"])
    op.create_index("idx_tasks_group_task", "tasks", ["group_task_id"], postgresql_where="group_task_id IS NOT NULL")
    op.create_index("idx_tasks_assignee_status", "tasks", ["assignee_id", "status"], postgresql_where="is_deleted = false")
    op.create_index("idx_tasks_creator", "tasks", ["creator_id"], postgresql_where="is_deleted = false")
    op.create_index("idx_tasks_deadline", "tasks", ["deadline"], postgresql_where="is_deleted = false AND status != 'completed'")
    op.create_index("idx_tasks_group", "tasks", ["group_id"], postgresql_where="is_deleted = false")

    # 5. Reminders table
    op.create_table(
        "reminders",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("task_id", sa.Integer(), nullable=False),
        sa.Column("user_id", sa.Integer(), nullable=True),
        sa.Column("remind_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("reminder_type", sa.String(50), nullable=False),
        sa.Column("reminder_offset", sa.String(20), nullable=True),
        sa.Column("is_sent", sa.Boolean(), server_default="false"),
        sa.Column("sent_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("error_message", sa.Text(), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.PrimaryKeyConstraint("id"),
        sa.ForeignKeyConstraint(["task_id"], ["tasks.id"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["user_id"], ["users.id"]),
        sa.CheckConstraint("reminder_type IN ('before_deadline', 'after_deadline', 'custom')", name="ck_reminder_type"),
    )
    op.create_index("idx_reminders_pending", "reminders", ["remind_at"], postgresql_where="is_sent = false")
    op.create_index("idx_reminders_task", "reminders", ["task_id"])

    # 6. Task history table
    op.create_table(
        "task_history",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("task_id", sa.Integer(), nullable=False),
        sa.Column("user_id", sa.Integer(), nullable=True),
        sa.Column("action", sa.String(50), nullable=False),
        sa.Column("field_name", sa.String(100), nullable=True),
        sa.Column("old_value", sa.Text(), nullable=True),
        sa.Column("new_value", sa.Text(), nullable=True),
        sa.Column("note", sa.Text(), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.PrimaryKeyConstraint("id"),
        sa.ForeignKeyConstraint(["task_id"], ["tasks.id"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["user_id"], ["users.id"]),
    )
    op.create_index("idx_history_task", "task_history", ["task_id", "created_at"])

    # 7. User statistics table
    op.create_table(
        "user_statistics",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("user_id", sa.Integer(), nullable=True),
        sa.Column("group_id", sa.Integer(), nullable=True),
        sa.Column("period_type", sa.String(20), nullable=False),
        sa.Column("period_start", sa.Date(), nullable=False),
        sa.Column("period_end", sa.Date(), nullable=False),
        sa.Column("tasks_assigned_total", sa.Integer(), server_default="0"),
        sa.Column("tasks_assigned_completed", sa.Integer(), server_default="0"),
        sa.Column("tasks_assigned_overdue", sa.Integer(), server_default="0"),
        sa.Column("tasks_received_total", sa.Integer(), server_default="0"),
        sa.Column("tasks_received_completed", sa.Integer(), server_default="0"),
        sa.Column("tasks_received_overdue", sa.Integer(), server_default="0"),
        sa.Column("tasks_personal_total", sa.Integer(), server_default="0"),
        sa.Column("tasks_personal_completed", sa.Integer(), server_default="0"),
        sa.Column("created_at", sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.PrimaryKeyConstraint("id"),
        sa.ForeignKeyConstraint(["user_id"], ["users.id"]),
        sa.ForeignKeyConstraint(["group_id"], ["groups.id"]),
        sa.UniqueConstraint("user_id", "group_id", "period_type", "period_start", name="uq_user_stats"),
    )
    op.create_index("idx_stats_user", "user_statistics", ["user_id", "period_type", "period_start"])

    # 8. Deleted tasks undo table
    op.create_table(
        "deleted_tasks_undo",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("task_id", sa.Integer(), nullable=False),
        sa.Column("task_data", postgresql.JSONB(), nullable=False),
        sa.Column("deleted_by", sa.Integer(), nullable=True),
        sa.Column("deleted_at", sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.Column("expires_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("is_restored", sa.Boolean(), server_default="false"),
        sa.PrimaryKeyConstraint("id"),
        sa.ForeignKeyConstraint(["deleted_by"], ["users.id"]),
    )
    op.create_index("idx_undo_expires", "deleted_tasks_undo", ["expires_at"], postgresql_where="is_restored = false")

    # 9. Bot config table
    op.create_table(
        "bot_config",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("key", sa.String(100), nullable=False),
        sa.Column("value", sa.Text(), nullable=True),
        sa.Column("description", sa.Text(), nullable=True),
        sa.Column("updated_at", sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("key"),
    )

    # Insert default config
    op.execute("""
        INSERT INTO bot_config (key, value, description) VALUES
        ('bot_name', 'Task Manager Bot', 'Ten hien thi'),
        ('bot_description', 'He thong quan ly va nhac viec', 'Mo ta bot'),
        ('support_telegram', '@support', 'Telegram ho tro'),
        ('support_phone', '', 'SDT ho tro'),
        ('support_email', '', 'Email ho tro'),
        ('admin_telegram_id', '', 'Admin ID nhan alert'),
        ('timezone', 'Asia/Ho_Chi_Minh', 'Timezone mac dinh'),
        ('task_id_counter', '0', 'Counter cho task ID');
    """)


def downgrade() -> None:
    # Drop in reverse order
    op.drop_table("bot_config")
    op.drop_table("deleted_tasks_undo")
    op.drop_table("user_statistics")
    op.drop_table("task_history")
    op.drop_table("reminders")
    op.drop_table("tasks")
    op.drop_table("group_members")
    op.drop_table("groups")
    op.drop_table("users")
</file>

<file path="database/migrations/versions/20241215_0002_recurring_templates.py">
"""Add recurring_templates table

Revision ID: 0002
Revises: 0001
Create Date: 2024-12-15

Creates recurring_templates table for storing recurring task definitions.
"""

from typing import Sequence, Union
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

revision: str = "0002"
down_revision: Union[str, None] = "0001"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # Recurring templates table
    op.create_table(
        "recurring_templates",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("public_id", sa.String(20), nullable=False),
        sa.Column("content", sa.Text(), nullable=False),
        sa.Column("description", sa.Text(), nullable=True),
        sa.Column("priority", sa.String(20), server_default="normal", nullable=False),
        sa.Column("creator_id", sa.Integer(), nullable=False),
        sa.Column("assignee_id", sa.Integer(), nullable=True),
        sa.Column("group_id", sa.Integer(), nullable=True),
        sa.Column("is_personal", sa.Boolean(), server_default="true"),
        # Recurrence config
        sa.Column("recurrence_type", sa.String(20), nullable=False),  # daily, weekly, monthly
        sa.Column("recurrence_interval", sa.Integer(), server_default="1"),  # every N days/weeks/months
        sa.Column("recurrence_days", postgresql.ARRAY(sa.Integer()), nullable=True),  # days of week (0-6) or month (1-31)
        sa.Column("recurrence_time", sa.Time(), nullable=True),  # time of day for deadline
        sa.Column("recurrence_end_date", sa.Date(), nullable=True),  # when to stop generating
        sa.Column("recurrence_count", sa.Integer(), nullable=True),  # max instances to generate
        # Tracking
        sa.Column("last_generated", sa.DateTime(timezone=True), nullable=True),
        sa.Column("next_due", sa.DateTime(timezone=True), nullable=True),
        sa.Column("instances_created", sa.Integer(), server_default="0"),
        sa.Column("is_active", sa.Boolean(), server_default="true"),
        sa.Column("created_at", sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.Column("updated_at", sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.PrimaryKeyConstraint("id"),
        sa.UniqueConstraint("public_id"),
        sa.ForeignKeyConstraint(["creator_id"], ["users.id"]),
        sa.ForeignKeyConstraint(["assignee_id"], ["users.id"]),
        sa.ForeignKeyConstraint(["group_id"], ["groups.id"]),
        sa.CheckConstraint(
            "recurrence_type IN ('daily', 'weekly', 'monthly')",
            name="ck_recurrence_type"
        ),
    )
    op.create_index("idx_recurring_creator", "recurring_templates", ["creator_id"])
    op.create_index("idx_recurring_next", "recurring_templates", ["next_due"], postgresql_where="is_active = true")
    op.create_index("idx_recurring_public", "recurring_templates", ["public_id"])

    # Add recurring template reference to tasks
    op.add_column(
        "tasks",
        sa.Column("recurring_template_id", sa.Integer(), nullable=True)
    )
    op.create_foreign_key(
        "fk_task_recurring_template",
        "tasks", "recurring_templates",
        ["recurring_template_id"], ["id"]
    )

    # Add counter for recurring IDs
    op.execute("""
        INSERT INTO bot_config (key, value, description) VALUES
        ('recurring_id_counter', '0', 'Counter cho recurring task ID')
        ON CONFLICT (key) DO NOTHING;
    """)


def downgrade() -> None:
    op.drop_constraint("fk_task_recurring_template", "tasks", type_="foreignkey")
    op.drop_column("tasks", "recurring_template_id")
    op.drop_table("recurring_templates")
    op.execute("DELETE FROM bot_config WHERE key = 'recurring_id_counter';")
</file>

<file path="database/migrations/versions/20251215_0003_group_tasks.py">
"""Add parent_task_id for group tasks (G-ID/P-ID system)

Revision ID: 20251215_0003
Revises: 20241215_0002
Create Date: 2025-12-15

"""
from typing import Sequence, Union
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '0003'
down_revision: Union[str, None] = '0002'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # Add parent_task_id column for G-ID/P-ID group task relationships
    op.add_column(
        'tasks',
        sa.Column('parent_task_id', sa.Integer(), nullable=True)
    )

    # Add foreign key constraint
    op.create_foreign_key(
        'tasks_parent_task_id_fkey',
        'tasks',
        'tasks',
        ['parent_task_id'],
        ['id'],
        ondelete='SET NULL'
    )

    # Add index for faster child task lookups
    op.create_index(
        'ix_tasks_parent_task_id',
        'tasks',
        ['parent_task_id']
    )


def downgrade() -> None:
    op.drop_index('ix_tasks_parent_task_id', table_name='tasks')
    op.drop_constraint('tasks_parent_task_id_fkey', 'tasks', type_='foreignkey')
    op.drop_column('tasks', 'parent_task_id')
</file>

<file path="database/migrations/versions/20251216_0004_export_reports.py">
"""Export reports table for statistical exports

Revision ID: 0004
Revises: 0003
Create Date: 2025-12-16

Creates:
- export_reports: Track generated export reports with password and TTL
"""

from typing import Sequence, Union
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers
revision: str = "0004"
down_revision: Union[str, None] = "0003"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    op.create_table(
        "export_reports",
        sa.Column("id", sa.Integer(), nullable=False),
        sa.Column("report_id", sa.String(32), nullable=False, unique=True),
        sa.Column("password_hash", sa.String(128), nullable=False),
        sa.Column("user_id", sa.Integer(), nullable=False),
        sa.Column("report_type", sa.String(20), nullable=False),  # weekly, monthly, custom
        sa.Column("file_format", sa.String(10), nullable=False),  # csv, xlsx, pdf
        sa.Column("task_filter", sa.String(20), nullable=False),  # all, created, assigned, received
        sa.Column("period_start", sa.DateTime(timezone=True), nullable=True),
        sa.Column("period_end", sa.DateTime(timezone=True), nullable=True),
        sa.Column("file_path", sa.String(500), nullable=False),
        sa.Column("file_size", sa.Integer(), nullable=True),
        sa.Column("download_count", sa.Integer(), server_default="0"),
        sa.Column("expires_at", sa.DateTime(timezone=True), nullable=False),
        sa.Column("created_at", sa.DateTime(timezone=True), server_default=sa.func.now()),
        sa.PrimaryKeyConstraint("id"),
        sa.ForeignKeyConstraint(["user_id"], ["users.id"], ondelete="CASCADE"),
    )
    op.create_index("idx_export_report_id", "export_reports", ["report_id"])
    op.create_index("idx_export_user", "export_reports", ["user_id"])
    op.create_index("idx_export_expires", "export_reports", ["expires_at"])


def downgrade() -> None:
    op.drop_index("idx_export_expires", table_name="export_reports")
    op.drop_index("idx_export_user", table_name="export_reports")
    op.drop_index("idx_export_report_id", table_name="export_reports")
    op.drop_table("export_reports")
</file>

<file path="database/migrations/versions/20251216_0005_reminder_source.py">
"""
Add reminder_source column to users table.
Allows users to choose between Telegram, Google Calendar, or both for reminders.

Revision ID: 0005
Revises: 0004
Create Date: 2025-12-16
"""
from typing import Sequence, Union
from alembic import op
import sqlalchemy as sa

revision: str = "0005"
down_revision: Union[str, None] = "0004"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # Add reminder_source column (telegram, google_calendar, both)
    # Default is 'both' to enable all reminders by default
    op.add_column(
        'users',
        sa.Column(
            'reminder_source',
            sa.String(20),
            server_default='both',
            nullable=False
        )
    )


def downgrade() -> None:
    op.drop_column('users', 'reminder_source')
</file>

<file path="database/migrations/versions/20251216_0006_calendar_sync_interval.py">
"""
Add calendar_sync_interval column to users table.
Allows users to set auto-sync frequency with Google Calendar.

Revision ID: 0006
Revises: 0005
Create Date: 2025-12-16
"""
from typing import Sequence, Union
from alembic import op
import sqlalchemy as sa

revision: str = "0006"
down_revision: Union[str, None] = "0005"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # Add calendar_sync_interval column (24h, 12h, weekly, manual)
    # Default is 'manual' - user manually syncs when needed
    op.add_column(
        'users',
        sa.Column(
            'calendar_sync_interval',
            sa.String(20),
            server_default='manual',
            nullable=False
        )
    )


def downgrade() -> None:
    op.drop_column('users', 'calendar_sync_interval')
</file>

<file path="database/migrations/versions/20251217_0001_notification_settings.py">
"""Add notification settings columns

Revision ID: 0008
Revises: 0007
Create Date: 2025-12-17

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '0008'
down_revision = '0007'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # Add notification settings columns to users table
    op.add_column('users', sa.Column('notify_all', sa.Boolean(), nullable=False, server_default='true'))
    op.add_column('users', sa.Column('notify_task_assigned', sa.Boolean(), nullable=False, server_default='true'))
    op.add_column('users', sa.Column('notify_task_status', sa.Boolean(), nullable=False, server_default='true'))


def downgrade() -> None:
    op.drop_column('users', 'notify_task_status')
    op.drop_column('users', 'notify_task_assigned')
    op.drop_column('users', 'notify_all')
</file>

<file path="database/migrations/versions/20251217_0007_user_reminder_prefs.py">
"""Add user reminder preference columns

Revision ID: 0007
Revises: 0006
Create Date: 2025-12-17

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '0007'
down_revision = '0006'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # Add reminder preference columns to users table
    op.add_column('users', sa.Column('remind_24h', sa.Boolean(), nullable=False, server_default='true'))
    op.add_column('users', sa.Column('remind_1h', sa.Boolean(), nullable=False, server_default='true'))
    op.add_column('users', sa.Column('remind_30m', sa.Boolean(), nullable=False, server_default='true'))
    op.add_column('users', sa.Column('remind_5m', sa.Boolean(), nullable=False, server_default='true'))
    op.add_column('users', sa.Column('remind_overdue', sa.Boolean(), nullable=False, server_default='true'))


def downgrade() -> None:
    op.drop_column('users', 'remind_overdue')
    op.drop_column('users', 'remind_5m')
    op.drop_column('users', 'remind_30m')
    op.drop_column('users', 'remind_1h')
    op.drop_column('users', 'remind_24h')
</file>

<file path="database/migrations/versions/20251218_0009_task_id_sequence.py">
"""Add PostgreSQL sequence for atomic task ID generation.

Revision ID: 0009
Revises: 0008
Create Date: 2025-12-18

Fixes race condition where concurrent task creation could get duplicate IDs.
"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '0009'
down_revision = '0008'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # Get current counter value from bot_config
    conn = op.get_bind()
    result = conn.execute(
        sa.text("SELECT value FROM bot_config WHERE key = 'task_id_counter'")
    ).fetchone()

    # Start sequence from current counter + 1 to avoid duplicates
    start_value = int(result[0]) + 1 if result else 1

    # Create sequence for atomic task ID generation
    op.execute(f"CREATE SEQUENCE IF NOT EXISTS task_id_seq START WITH {start_value}")


def downgrade() -> None:
    # Get current sequence value before dropping
    conn = op.get_bind()
    result = conn.execute(sa.text("SELECT last_value FROM task_id_seq")).fetchone()

    if result:
        # Store value back in bot_config
        conn.execute(
            sa.text("UPDATE bot_config SET value = :val WHERE key = 'task_id_counter'"),
            {"val": str(result[0])}
        )

    op.execute("DROP SEQUENCE IF EXISTS task_id_seq")
</file>

<file path="database/migrations/env.py">
"""
Alembic Environment Configuration
TeleTask Bot Database Migrations
"""

import os
import sys
from logging.config import fileConfig

from sqlalchemy import engine_from_config, pool
from alembic import context

# Add parent directory to path for model imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Alembic Config object
config = context.config

# Set SQLAlchemy URL from environment
database_url = os.getenv("DATABASE_URL")
if database_url:
    config.set_main_option("sqlalchemy.url", database_url)

# Interpret the config file for logging
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# Import models for autogenerate support
from database.models import Base

target_metadata = Base.metadata


def run_migrations_offline() -> None:
    """
    Run migrations in 'offline' mode.
    Generates SQL script without connecting to database.
    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """
    Run migrations in 'online' mode.
    Creates connection and runs migrations directly.
    """
    connectable = engine_from_config(
        config.get_section(config.config_ini_section, {}),
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata,
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
</file>

<file path="database/migrations/script.py.mako">
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    ${downgrades if downgrades else "pass"}
</file>

<file path="database/__init__.py">
"""
Database Module
PostgreSQL connection and models with Alembic migrations

Tables:
- users: Telegram users
- groups: Telegram groups
- group_members: User-group relationships
- tasks: Main task table
- reminders: Scheduled reminders
- task_history: Audit trail
- user_statistics: Aggregated stats
- deleted_tasks_undo: 30-second undo buffer
- bot_config: Key-value settings
"""

from .connection import Database, db, init_database, close_database, get_db
from .models import (
    Base,
    User,
    Group,
    GroupMember,
    Task,
    Reminder,
    TaskHistory,
    UserStatistics,
    DeletedTaskUndo,
    BotConfig,
)

__all__ = [
    # Connection
    "Database",
    "db",
    "init_database",
    "close_database",
    "get_db",
    # Models
    "Base",
    "User",
    "Group",
    "GroupMember",
    "Task",
    "Reminder",
    "TaskHistory",
    "UserStatistics",
    "DeletedTaskUndo",
    "BotConfig",
]
</file>

<file path="database/connection.py">
"""
Database Connection Module
Async PostgreSQL connection pooling with asyncpg
"""

import asyncio
import logging
from typing import Any, Optional

import asyncpg
from asyncpg import Pool, Connection, Record

logger = logging.getLogger(__name__)


class Database:
    """
    Async PostgreSQL database connection manager.
    Uses connection pooling for efficient resource usage.
    """

    def __init__(self):
        self.pool: Optional[Pool] = None
        self._dsn: Optional[str] = None

    async def connect(
        self,
        dsn: str,
        min_size: int = 2,
        max_size: int = 10,
        timeout: float = 60.0,
        timezone: str = "Asia/Ho_Chi_Minh",
    ) -> None:
        """
        Initialize connection pool.

        Args:
            dsn: PostgreSQL connection string
            min_size: Minimum pool connections
            max_size: Maximum pool connections
            timeout: Command timeout in seconds
            timezone: Database timezone
        """
        if self.pool is not None:
            logger.warning("Pool already exists, closing existing pool")
            await self.close()

        self._dsn = dsn

        try:
            self.pool = await asyncpg.create_pool(
                dsn=dsn,
                min_size=min_size,
                max_size=max_size,
                command_timeout=timeout,
                server_settings={"timezone": timezone},
            )
            logger.info(f"Database pool created (min={min_size}, max={max_size})")
        except Exception as e:
            logger.error(f"Failed to create database pool: {e}")
            raise

    async def close(self) -> None:
        """Close connection pool."""
        if self.pool:
            await self.pool.close()
            self.pool = None
            logger.info("Database pool closed")

    async def _ensure_pool(self) -> Pool:
        """Ensure pool exists."""
        if self.pool is None:
            raise RuntimeError("Database pool not initialized. Call connect() first.")
        return self.pool

    # Query methods

    async def fetch_one(self, query: str, *args: Any) -> Optional[Record]:
        """
        Fetch single row.

        Args:
            query: SQL query
            *args: Query parameters

        Returns:
            Record or None
        """
        pool = await self._ensure_pool()
        async with pool.acquire() as conn:
            return await conn.fetchrow(query, *args)

    async def fetch_all(self, query: str, *args: Any) -> list[Record]:
        """
        Fetch all rows.

        Args:
            query: SQL query
            *args: Query parameters

        Returns:
            List of records
        """
        pool = await self._ensure_pool()
        async with pool.acquire() as conn:
            return await conn.fetch(query, *args)

    async def fetch_val(self, query: str, *args: Any) -> Any:
        """
        Fetch single value.

        Args:
            query: SQL query
            *args: Query parameters

        Returns:
            Single value or None
        """
        pool = await self._ensure_pool()
        async with pool.acquire() as conn:
            return await conn.fetchval(query, *args)

    async def execute(self, query: str, *args: Any) -> str:
        """
        Execute query without return.

        Args:
            query: SQL query
            *args: Query parameters

        Returns:
            Status string (e.g., 'INSERT 0 1')
        """
        pool = await self._ensure_pool()
        async with pool.acquire() as conn:
            return await conn.execute(query, *args)

    async def execute_many(self, query: str, args_list: list[tuple]) -> None:
        """
        Execute query with multiple parameter sets.

        Args:
            query: SQL query
            args_list: List of parameter tuples
        """
        pool = await self._ensure_pool()
        async with pool.acquire() as conn:
            await conn.executemany(query, args_list)

    # Transaction support

    async def transaction(self) -> Connection:
        """
        Get connection for manual transaction management.

        Usage:
            async with db.transaction() as conn:
                await conn.execute(...)
                await conn.execute(...)

        Returns:
            Connection with transaction started
        """
        pool = await self._ensure_pool()
        conn = await pool.acquire()
        return conn

    # Health check

    async def health_check(self) -> bool:
        """
        Check if database is accessible.

        Returns:
            True if healthy, False otherwise
        """
        try:
            result = await self.fetch_val("SELECT 1")
            return result == 1
        except Exception as e:
            logger.error(f"Database health check failed: {e}")
            return False

    @property
    def is_connected(self) -> bool:
        """Check if pool exists."""
        return self.pool is not None


# Singleton instance
db = Database()


async def init_database(dsn: str, **kwargs) -> Database:
    """
    Initialize database connection.

    Args:
        dsn: PostgreSQL connection string
        **kwargs: Additional pool options

    Returns:
        Database instance
    """
    await db.connect(dsn, **kwargs)
    return db


async def close_database() -> None:
    """Close database connection."""
    await db.close()


def get_db() -> Database:
    """Get database instance."""
    return db
</file>

<file path="database/models.py">
"""
SQLAlchemy Models for TeleTask Bot
Database schema for task management system
"""

from datetime import datetime
from typing import Optional

from sqlalchemy import (
    BigInteger,
    Boolean,
    Column,
    Date,
    DateTime,
    ForeignKey,
    Index,
    Integer,
    String,
    Text,
    UniqueConstraint,
    CheckConstraint,
    func,
)
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import DeclarativeBase, relationship


class Base(DeclarativeBase):
    """Base class for all models."""
    pass


class User(Base):
    """
    Telegram user model.
    Stores user profile and notification preferences.
    """
    __tablename__ = "users"

    id = Column(Integer, primary_key=True)
    telegram_id = Column(BigInteger, unique=True, nullable=False, index=True)
    username = Column(String(255), index=True)
    first_name = Column(String(255))
    last_name = Column(String(255))
    display_name = Column(String(500))

    # Settings
    timezone = Column(String(50), default="Asia/Ho_Chi_Minh")
    language = Column(String(10), default="vi")

    # Notification preferences
    notify_reminder = Column(Boolean, default=True)
    notify_weekly_report = Column(Boolean, default=True)
    notify_monthly_report = Column(Boolean, default=True)

    # Google Calendar (Phase 09)
    google_calendar_token = Column(Text)
    google_calendar_refresh_token = Column(Text)

    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

    # Relationships
    created_tasks = relationship("Task", back_populates="creator", foreign_keys="Task.creator_id")
    assigned_tasks = relationship("Task", back_populates="assignee", foreign_keys="Task.assignee_id")
    group_memberships = relationship("GroupMember", back_populates="user")
    statistics = relationship("UserStatistics", back_populates="user")

    def __repr__(self):
        return f"<User(id={self.id}, telegram_id={self.telegram_id}, username={self.username})>"


class Group(Base):
    """
    Telegram group model.
    Stores group information for group task management.
    """
    __tablename__ = "groups"

    id = Column(Integer, primary_key=True)
    telegram_id = Column(BigInteger, unique=True, nullable=False, index=True)
    title = Column(String(255))
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

    # Relationships
    members = relationship("GroupMember", back_populates="group")
    tasks = relationship("Task", back_populates="group")
    statistics = relationship("UserStatistics", back_populates="group")

    def __repr__(self):
        return f"<Group(id={self.id}, telegram_id={self.telegram_id}, title={self.title})>"


class GroupMember(Base):
    """
    Group membership model.
    Links users to groups with role information.
    """
    __tablename__ = "group_members"

    id = Column(Integer, primary_key=True)
    group_id = Column(Integer, ForeignKey("groups.id", ondelete="CASCADE"), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    role = Column(String(50), default="member")  # 'admin', 'member'
    joined_at = Column(DateTime(timezone=True), server_default=func.now())

    # Relationships
    group = relationship("Group", back_populates="members")
    user = relationship("User", back_populates="group_memberships")

    __table_args__ = (
        UniqueConstraint("group_id", "user_id", name="uq_group_user"),
        Index("idx_gm_group", "group_id"),
        Index("idx_gm_user", "user_id"),
    )

    def __repr__(self):
        return f"<GroupMember(group_id={self.group_id}, user_id={self.user_id}, role={self.role})>"


class Task(Base):
    """
    Main task model.
    Stores task information, status, and relationships.
    """
    __tablename__ = "tasks"

    id = Column(Integer, primary_key=True)
    public_id = Column(String(20), unique=True, nullable=False, index=True)  # P-1234 or G-500
    group_task_id = Column(String(20), index=True)  # Parent G-ID for group tasks

    content = Column(Text, nullable=False)
    description = Column(Text)

    status = Column(
        String(20),
        default="pending",
        nullable=False,
    )
    priority = Column(
        String(20),
        default="normal",
        nullable=False,
    )
    progress = Column(Integer, default=0)

    # Relationships
    creator_id = Column(Integer, ForeignKey("users.id"))
    assignee_id = Column(Integer, ForeignKey("users.id"))
    group_id = Column(Integer, ForeignKey("groups.id"))

    # Timestamps
    deadline = Column(DateTime(timezone=True))
    completed_at = Column(DateTime(timezone=True))

    # Recurring (Phase 09)
    is_recurring = Column(Boolean, default=False)
    recurring_pattern = Column(String(100))  # 'daily', 'weekly', 'monthly', 'custom'
    recurring_config = Column(JSONB)  # {'interval': 1, 'days': [1,3,5], ...}
    parent_recurring_id = Column(Integer, ForeignKey("tasks.id"))

    # Google Calendar
    google_event_id = Column(String(255))

    # Flags
    is_personal = Column(Boolean, default=False)
    is_deleted = Column(Boolean, default=False, index=True)
    deleted_at = Column(DateTime(timezone=True))
    deleted_by = Column(Integer, ForeignKey("users.id"))

    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

    # Relationships
    creator = relationship("User", back_populates="created_tasks", foreign_keys=[creator_id])
    assignee = relationship("User", back_populates="assigned_tasks", foreign_keys=[assignee_id])
    group = relationship("Group", back_populates="tasks")
    reminders = relationship("Reminder", back_populates="task", cascade="all, delete-orphan")
    history = relationship("TaskHistory", back_populates="task", cascade="all, delete-orphan")
    parent_recurring = relationship("Task", remote_side=[id], foreign_keys=[parent_recurring_id])

    __table_args__ = (
        CheckConstraint("status IN ('pending', 'in_progress', 'completed')", name="ck_task_status"),
        CheckConstraint("priority IN ('low', 'normal', 'high', 'urgent')", name="ck_task_priority"),
        CheckConstraint("progress >= 0 AND progress <= 100", name="ck_task_progress"),
        Index("idx_tasks_assignee_status", "assignee_id", "status", postgresql_where="is_deleted = false"),
        Index("idx_tasks_creator", "creator_id", postgresql_where="is_deleted = false"),
        Index("idx_tasks_deadline", "deadline", postgresql_where="is_deleted = false AND status != 'completed'"),
        Index("idx_tasks_group", "group_id", postgresql_where="is_deleted = false"),
    )

    def __repr__(self):
        return f"<Task(id={self.id}, public_id={self.public_id}, status={self.status})>"


class Reminder(Base):
    """
    Reminder model.
    Scheduled notifications for tasks.
    """
    __tablename__ = "reminders"

    id = Column(Integer, primary_key=True)
    task_id = Column(Integer, ForeignKey("tasks.id", ondelete="CASCADE"), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"))

    remind_at = Column(DateTime(timezone=True), nullable=False)
    reminder_type = Column(
        String(50),
        nullable=False,
    )
    reminder_offset = Column(String(20))  # '3d', '24h', '1h'

    is_sent = Column(Boolean, default=False)
    sent_at = Column(DateTime(timezone=True))
    error_message = Column(Text)

    created_at = Column(DateTime(timezone=True), server_default=func.now())

    # Relationships
    task = relationship("Task", back_populates="reminders")
    user = relationship("User")

    __table_args__ = (
        CheckConstraint(
            "reminder_type IN ('before_deadline', 'after_deadline', 'custom')",
            name="ck_reminder_type"
        ),
        Index("idx_reminders_pending", "remind_at", postgresql_where="is_sent = false"),
        Index("idx_reminders_task", "task_id"),
    )

    def __repr__(self):
        return f"<Reminder(id={self.id}, task_id={self.task_id}, remind_at={self.remind_at})>"


class TaskHistory(Base):
    """
    Task history model.
    Audit trail for task changes.
    """
    __tablename__ = "task_history"

    id = Column(Integer, primary_key=True)
    task_id = Column(Integer, ForeignKey("tasks.id", ondelete="CASCADE"), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"))

    action = Column(String(50), nullable=False)  # 'created', 'updated', 'completed', 'deleted'
    field_name = Column(String(100))  # 'status', 'deadline', 'assignee', etc.
    old_value = Column(Text)
    new_value = Column(Text)
    note = Column(Text)

    created_at = Column(DateTime(timezone=True), server_default=func.now())

    # Relationships
    task = relationship("Task", back_populates="history")
    user = relationship("User")

    __table_args__ = (
        Index("idx_history_task", "task_id", "created_at"),
    )

    def __repr__(self):
        return f"<TaskHistory(id={self.id}, task_id={self.task_id}, action={self.action})>"


class UserStatistics(Base):
    """
    User statistics model.
    Aggregated task statistics per period.
    """
    __tablename__ = "user_statistics"

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    group_id = Column(Integer, ForeignKey("groups.id"))

    period_type = Column(String(20), nullable=False)  # 'weekly', 'monthly'
    period_start = Column(Date, nullable=False)
    period_end = Column(Date, nullable=False)

    # Tasks assigned by user (giao viec)
    tasks_assigned_total = Column(Integer, default=0)
    tasks_assigned_completed = Column(Integer, default=0)
    tasks_assigned_overdue = Column(Integer, default=0)

    # Tasks received by user (nhan viec)
    tasks_received_total = Column(Integer, default=0)
    tasks_received_completed = Column(Integer, default=0)
    tasks_received_overdue = Column(Integer, default=0)

    # Personal tasks
    tasks_personal_total = Column(Integer, default=0)
    tasks_personal_completed = Column(Integer, default=0)

    created_at = Column(DateTime(timezone=True), server_default=func.now())

    # Relationships
    user = relationship("User", back_populates="statistics")
    group = relationship("Group", back_populates="statistics")

    __table_args__ = (
        UniqueConstraint("user_id", "group_id", "period_type", "period_start", name="uq_user_stats"),
        Index("idx_stats_user", "user_id", "period_type", "period_start"),
    )

    def __repr__(self):
        return f"<UserStatistics(user_id={self.user_id}, period={self.period_type})>"


class DeletedTaskUndo(Base):
    """
    Deleted tasks undo buffer.
    Stores deleted tasks for 30-second undo window.
    """
    __tablename__ = "deleted_tasks_undo"

    id = Column(Integer, primary_key=True)
    task_id = Column(Integer, nullable=False)  # Original task ID
    task_data = Column(JSONB, nullable=False)  # Full task snapshot
    deleted_by = Column(Integer, ForeignKey("users.id"))
    deleted_at = Column(DateTime(timezone=True), server_default=func.now())
    expires_at = Column(DateTime(timezone=True))  # Calculated: deleted_at + 30 seconds
    is_restored = Column(Boolean, default=False)

    # Relationships
    user = relationship("User")

    __table_args__ = (
        Index("idx_undo_expires", "expires_at", postgresql_where="is_restored = false"),
    )

    def __repr__(self):
        return f"<DeletedTaskUndo(task_id={self.task_id}, expires_at={self.expires_at})>"


class BotConfig(Base):
    """
    Bot configuration model.
    Key-value store for bot settings.
    """
    __tablename__ = "bot_config"

    id = Column(Integer, primary_key=True)
    key = Column(String(100), unique=True, nullable=False)
    value = Column(Text)
    description = Column(Text)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

    def __repr__(self):
        return f"<BotConfig(key={self.key})>"
</file>

<file path="handlers/__init__.py">
"""
Bot Handlers Module
Command and callback handlers for Telegram bot

Handlers:
- start: /start, /help, /thongtin
- task_wizard: /taoviec (wizard mode, step-by-step)
- task_create: /vieccanhan
- task_assign: /giaoviec, /viecdagiao
- task_view: /xemviec, /viecnhom, /timviec, /deadline
- task_update: /xong, /danglam, /tiendo
- task_delete: /xoa
- reminder: /nhacviec, /xemnhac
- recurring_task: /vieclaplai, /danhsachvieclaplai
- calendar: /lichgoogle
- settings: /caidat
- callbacks: Inline button handlers
"""

from telegram.ext import Application

from .start import get_handlers as get_start_handlers
from .task_wizard import get_handlers as get_task_wizard_handlers
from .task_create import get_handlers as get_task_create_handlers
from .task_assign import get_handlers as get_task_assign_handlers
from .task_view import get_handlers as get_task_view_handlers
from .task_update import get_handlers as get_task_update_handlers
from .task_delete import get_handlers as get_task_delete_handlers
from .reminder import get_handlers as get_reminder_handlers
from .statistics import get_handlers as get_statistics_handlers
from .recurring_task import get_handlers as get_recurring_handlers
from .calendar import get_handlers as get_calendar_handlers
from .export import get_handlers as get_export_handlers
from .settings import get_handlers as get_settings_handlers
from .callbacks import get_handlers as get_callback_handlers


def register_handlers(application: Application) -> None:
    """Register all bot handlers."""
    # Start/Help handlers
    for handler in get_start_handlers():
        application.add_handler(handler)

    # Task wizard handlers (must be before task_create for /taoviec)
    for handler in get_task_wizard_handlers():
        application.add_handler(handler)

    # Task create handlers
    for handler in get_task_create_handlers():
        application.add_handler(handler)

    # Task assign handlers
    for handler in get_task_assign_handlers():
        application.add_handler(handler)

    # Task view handlers
    for handler in get_task_view_handlers():
        application.add_handler(handler)

    # Task update handlers
    for handler in get_task_update_handlers():
        application.add_handler(handler)

    # Task delete handlers
    for handler in get_task_delete_handlers():
        application.add_handler(handler)

    # Reminder handlers
    for handler in get_reminder_handlers():
        application.add_handler(handler)

    # Statistics handlers
    for handler in get_statistics_handlers():
        application.add_handler(handler)

    # Recurring task handlers
    for handler in get_recurring_handlers():
        application.add_handler(handler)

    # Calendar handlers
    for handler in get_calendar_handlers():
        application.add_handler(handler)

    # Export handlers
    for handler in get_export_handlers():
        application.add_handler(handler)

    # Settings handlers
    for handler in get_settings_handlers():
        application.add_handler(handler)

    # Callback handlers (must be last)
    for handler in get_callback_handlers():
        application.add_handler(handler)


__all__ = ["register_handlers"]
</file>

<file path="handlers/calendar.py">
"""
Google Calendar Handler
Commands for calendar connection, sync, and settings
"""

import logging
from typing import Optional

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CommandHandler, CallbackQueryHandler

from database import get_db
from services import get_or_create_user
from utils.db_utils import validate_user_setting_column, InvalidColumnError
from services.calendar_service import (
    is_calendar_enabled,
    get_oauth_url,
    is_user_connected,
    disconnect_calendar,
    get_user_token_data,
    create_calendar_event,
    get_user_reminder_source,
)

logger = logging.getLogger(__name__)

# Sync mode options
SYNC_OPTIONS = [
    ("auto", "🔄 Tự động khi có thay đổi"),
    ("manual", "👆 Thủ công (bấm đồng bộ)"),
]


def get_sync_display(sync_mode: str) -> str:
    """Get sync mode display name."""
    for code, label in SYNC_OPTIONS:
        if code == sync_mode:
            return label
    return "🔄 Tự động"


async def get_user_calendar_data(db, telegram_id: int) -> dict:
    """Get user calendar settings from database."""
    result = await db.fetch_one(
        """SELECT id, calendar_sync_interval
           FROM users WHERE telegram_id = $1""",
        telegram_id
    )
    if result:
        return dict(result)
    return {}


async def update_user_setting(db, telegram_id: int, column: str, value) -> None:
    """Update a single user setting in database with column validation."""
    try:
        validated_column = validate_user_setting_column(column)
    except InvalidColumnError:
        logger.warning(f"Attempted invalid column update: {column}")
        return

    await db.execute(
        f"UPDATE users SET {validated_column} = $1 WHERE telegram_id = $2",
        value, telegram_id
    )


def calendar_connected_keyboard(sync_mode: str) -> InlineKeyboardMarkup:
    """Create keyboard for connected calendar."""
    sync_display = get_sync_display(sync_mode)
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(f"⚙️ Chế độ: {sync_display}", callback_data="cal_edit_sync")],
        [InlineKeyboardButton("📤 Đồng bộ ngay", callback_data="cal_sync_all")],
        [InlineKeyboardButton("❌ Ngắt kết nối", callback_data="cal_disconnect")],
    ])


def sync_mode_keyboard(current: str) -> InlineKeyboardMarkup:
    """Create sync mode selection keyboard."""
    buttons = []
    for code, label in SYNC_OPTIONS:
        prefix = "✅ " if code == current else ""
        buttons.append([
            InlineKeyboardButton(
                f"{prefix}{label}",
                callback_data=f"cal_set_sync:{code}"
            )
        ])
    buttons.append([InlineKeyboardButton("« Quay lại", callback_data="cal_back")])
    return InlineKeyboardMarkup(buttons)


async def calendar_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    /lichgoogle - Show calendar connection status and options.
    """
    user = update.effective_user

    if not is_calendar_enabled():
        await update.message.reply_text(
            "⚠️ Tính năng Google Calendar chưa được kích hoạt.\n\n"
            "Liên hệ admin để cấu hình."
        )
        return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)
        connected = await is_user_connected(db, db_user["id"])

        if connected:
            # User is connected - show settings
            user_data = await get_user_calendar_data(db, user.id)
            sync_mode = user_data.get("calendar_sync_interval", "auto")

            await update.message.reply_text(
                "📅 <b>GOOGLE CALENDAR</b>\n\n"
                "✅ Đã kết nối Google Calendar!\n\n"
                "Các việc mới sẽ tự động được thêm vào lịch của bạn.",
                reply_markup=calendar_connected_keyboard(sync_mode),
                parse_mode="HTML",
            )
        else:
            # User not connected
            auth_url = get_oauth_url(user.id)

            if auth_url:
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("🔗 Kết nối Google Calendar", url=auth_url)],
                ])

                await update.message.reply_text(
                    "📅 <b>GOOGLE CALENDAR</b>\n\n"
                    "Kết nối Google Calendar để tự động đồng bộ các việc.\n\n"
                    "Bấm nút bên dưới để đăng nhập Google:",
                    reply_markup=keyboard,
                    parse_mode="HTML",
                )
            else:
                await update.message.reply_text(
                    "⚠️ Không thể tạo liên kết kết nối.\n"
                    "Vui lòng liên hệ admin."
                )

    except Exception as e:
        logger.error(f"Error in calendar_command: {e}")
        await update.message.reply_text("Lỗi hệ thống. Vui lòng thử lại.")


async def calendar_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle calendar-related callbacks."""
    query = update.callback_query
    await query.answer()

    data = query.data
    user = update.effective_user

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        # ---- DISCONNECT ----
        if data == "cal_disconnect":
            await disconnect_calendar(db, db_user["id"])

            await query.edit_message_text(
                "✅ Đã ngắt kết nối Google Calendar.\n\n"
                "Sử dụng /lichgoogle để kết nối lại."
            )

        # ---- SYNC ALL ----
        elif data == "cal_sync_all":
            await query.edit_message_text(
                "🔄 Đang đồng bộ các việc vào Google Calendar...\n\n"
                "Vui lòng đợi..."
            )

            synced = await sync_all_tasks_to_calendar(db, db_user)

            user_data = await get_user_calendar_data(db, user.id)
            sync_mode = user_data.get("calendar_sync_interval", "auto")

            await query.edit_message_text(
                f"📅 <b>GOOGLE CALENDAR</b>\n\n"
                f"✅ Đã đồng bộ {synced} việc vào lịch!",
                reply_markup=calendar_connected_keyboard(sync_mode),
                parse_mode="HTML",
            )

        # ---- EDIT SYNC MODE ----
        elif data == "cal_edit_sync":
            user_data = await get_user_calendar_data(db, user.id)
            current_mode = user_data.get("calendar_sync_interval", "auto")

            await query.edit_message_text(
                "⚙️ <b>CHẾ ĐỘ ĐỒNG BỘ</b>\n\n"
                "Chọn cách đồng bộ với Google Calendar:",
                reply_markup=sync_mode_keyboard(current_mode),
                parse_mode="HTML",
            )

        # ---- SET SYNC MODE ----
        elif data.startswith("cal_set_sync:"):
            value = data.split(":")[1]
            valid_modes = [m[0] for m in SYNC_OPTIONS]
            if value not in valid_modes:
                return

            await update_user_setting(db, user.id, "calendar_sync_interval", value)
            mode_display = get_sync_display(value)
            await query.answer(f"✅ {mode_display}")

            # Return to main calendar menu
            await query.edit_message_text(
                "📅 <b>GOOGLE CALENDAR</b>\n\n"
                "✅ Đã kết nối Google Calendar!\n\n"
                "Các việc mới sẽ tự động được thêm vào lịch của bạn.",
                reply_markup=calendar_connected_keyboard(value),
                parse_mode="HTML",
            )

        # ---- BACK TO MAIN ----
        elif data == "cal_back":
            user_data = await get_user_calendar_data(db, user.id)
            sync_mode = user_data.get("calendar_sync_interval", "auto")

            await query.edit_message_text(
                "📅 <b>GOOGLE CALENDAR</b>\n\n"
                "✅ Đã kết nối Google Calendar!\n\n"
                "Các việc mới sẽ tự động được thêm vào lịch của bạn.",
                reply_markup=calendar_connected_keyboard(sync_mode),
                parse_mode="HTML",
            )

    except Exception as e:
        logger.error(f"Error in calendar_callback: {e}")
        await query.edit_message_text("Lỗi hệ thống. Vui lòng thử lại.")


async def sync_all_tasks_to_calendar(db, db_user: dict) -> int:
    """
    Sync all pending tasks with deadline to calendar.

    Args:
        db: Database connection
        db_user: Database user dict

    Returns:
        Number of tasks synced
    """
    try:
        token_data = await get_user_token_data(db, db_user["id"])
        if not token_data:
            return 0

        # Get tasks with deadline that don't have calendar event
        tasks = await db.fetch_all(
            """
            SELECT id, public_id, content, description, deadline, priority
            FROM tasks
            WHERE assignee_id = $1
            AND deadline IS NOT NULL
            AND status != 'completed'
            AND is_deleted = false
            AND google_event_id IS NULL
            ORDER BY deadline ASC
            LIMIT 50
            """,
            db_user["id"]
        )

        synced = 0
        reminder_source = await get_user_reminder_source(db, db_user["id"])
        for task in tasks:
            event_id = await create_calendar_event(
                token_data,
                task["public_id"],
                task["content"],
                task["deadline"],
                task.get("description", ""),
                task.get("priority", "normal"),
                reminder_source,
            )

            if event_id:
                # Save event ID to task
                await db.execute(
                    "UPDATE tasks SET google_event_id = $2 WHERE id = $1",
                    task["id"], event_id
                )
                synced += 1

        logger.info(f"Synced {synced} tasks to calendar for user {db_user['id']}")
        return synced

    except Exception as e:
        logger.error(f"Error syncing tasks to calendar: {e}")
        return 0


async def sync_task_to_calendar(db, task: dict, user_id: int) -> Optional[str]:
    """
    Sync a single task to user's calendar.

    Args:
        db: Database connection
        task: Task dict
        user_id: Database user ID

    Returns:
        Event ID or None
    """
    if not is_calendar_enabled():
        return None

    if not task.get("deadline"):
        return None

    try:
        token_data = await get_user_token_data(db, user_id)
        if not token_data:
            return None

        reminder_source = await get_user_reminder_source(db, user_id)
        event_id = await create_calendar_event(
            token_data,
            task["public_id"],
            task["content"],
            task["deadline"],
            task.get("description", ""),
            task.get("priority", "normal"),
            reminder_source,
        )

        if event_id:
            await db.execute(
                "UPDATE tasks SET google_event_id = $2 WHERE id = $1",
                task["id"], event_id
            )

        return event_id

    except Exception as e:
        logger.error(f"Error syncing task to calendar: {e}")
        return None


def get_handlers() -> list:
    """Return calendar handlers."""
    return [
        CommandHandler("lichgoogle", calendar_command),
        CallbackQueryHandler(calendar_callback, pattern="^cal_"),
    ]
</file>

<file path="handlers/callbacks.py">
"""
Callback Query Handler
Routes inline button callbacks to appropriate handlers
"""

import logging
import re
from typing import Optional, Tuple
from telegram import Update
from telegram.ext import ContextTypes, CallbackQueryHandler, MessageHandler, filters

from database import get_db
from services import (
    get_or_create_user,
    get_task_by_public_id,
    update_task_status,
    update_task_progress,
    update_task_content,
    update_task_deadline,
    update_task_priority,
    update_task_assignee,
    restore_task,
    parse_vietnamese_time,
    get_user_by_username,
    bulk_delete_tasks,
)
from utils import (
    MSG_TASK_RESTORED,
    ERR_TASK_NOT_FOUND,
    ERR_NO_PERMISSION,
    ERR_UNDO_EXPIRED,
    format_task_detail,
    format_datetime,
    format_priority,
    task_detail_keyboard,
    task_category_keyboard,
    progress_keyboard,
    undo_keyboard,
    edit_menu_keyboard,
    edit_priority_keyboard,
    mention_user,
)
from handlers.task_delete import process_delete, process_restore

logger = logging.getLogger(__name__)


# Callback validation constants
# Task ID pattern: P0001, G0001, etc.
TASK_ID_PATTERN = re.compile(r'^[PG]\d{4,8}$')

# Valid priorities
VALID_PRIORITIES = {"low", "normal", "high", "urgent"}

# Valid list types
VALID_LIST_TYPES = {"all", "personal", "assigned", "received"}

# Valid filter types
VALID_FILTER_TYPES = {"all", "individual", "group"}

# Valid category types
VALID_CATEGORIES = {"menu", "personal", "assigned", "received", "all"}


def validate_task_id(task_id: str) -> Optional[str]:
    """
    Validate task ID format.

    Args:
        task_id: Task ID to validate

    Returns:
        Validated task ID or None if invalid
    """
    if not task_id:
        return None

    task_id = task_id.strip().upper()

    if not TASK_ID_PATTERN.match(task_id):
        return None

    return task_id


def validate_int(value: str, min_val: int = 0, max_val: int = 10000) -> Optional[int]:
    """
    Validate and convert string to integer with bounds.

    Args:
        value: String value to convert
        min_val: Minimum allowed value
        max_val: Maximum allowed value

    Returns:
        Validated integer or None if invalid
    """
    if not value:
        return None

    try:
        num = int(value)
        if min_val <= num <= max_val:
            return num
        return None
    except (ValueError, TypeError):
        return None


def validate_priority(priority: str) -> Optional[str]:
    """
    Validate priority value.

    Args:
        priority: Priority string

    Returns:
        Validated priority or None if invalid
    """
    if not priority:
        return None

    priority = priority.strip().lower()
    return priority if priority in VALID_PRIORITIES else None


def validate_list_type(list_type: str) -> str:
    """
    Validate list type, default to 'all'.

    Args:
        list_type: List type string

    Returns:
        Validated list type or 'all'
    """
    if not list_type:
        return "all"

    list_type = list_type.strip().lower()
    return list_type if list_type in VALID_LIST_TYPES else "all"


def parse_callback_data(data: str) -> Tuple[str, list]:
    """
    Parse callback data safely.

    Args:
        data: Raw callback data string

    Returns:
        Tuple of (action, params)
    """
    if not data:
        return ("", [])

    # Limit total length to prevent abuse
    if len(data) > 200:
        return ("", [])

    parts = data.split(":")
    action = parts[0].strip().lower() if parts else ""

    return (action, parts[1:])


async def callback_router(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Route callback queries to appropriate handlers.

    Callback data format: action:param1:param2:...
    All parameters are validated before use.
    """
    query = update.callback_query
    await query.answer()

    data = query.data

    # Parse and validate callback data
    action, params = parse_callback_data(data)

    # Handle special prefixes first (before main routing)
    if data and data.startswith("overdue_"):
        from handlers.statistics import handle_overdue_callback
        await handle_overdue_callback(update, context)
        return

    if data and data.startswith("cal_"):
        # Calendar callbacks handled elsewhere
        return

    try:
        db = get_db()
        user = update.effective_user
        db_user = await get_or_create_user(db, user)

        # Task complete
        if action == "task_complete":
            task_id = validate_task_id(params[0] if params else "")
            if not task_id:
                await query.edit_message_text("Mã việc không hợp lệ.")
                return
            await handle_complete(query, db, db_user, task_id, context.bot)

        # Task progress
        elif action == "task_progress":
            task_id = validate_task_id(params[0] if params else "")
            if not task_id:
                await query.edit_message_text("Mã việc không hợp lệ.")
                return
            await handle_progress_menu(query, task_id)

        # Progress update
        elif action == "progress":
            task_id = validate_task_id(params[0] if params else "")
            value = validate_int(params[1] if len(params) > 1 else "", min_val=0, max_val=100)

            if not task_id:
                await query.edit_message_text("Mã việc không hợp lệ.")
                return
            if value is None:
                await query.edit_message_text("Giá trị tiến độ phải từ 0-100.")
                return

            await handle_progress_update(query, db, db_user, task_id, value)

        # Task detail
        elif action == "task_detail":
            task_id = validate_task_id(params[0] if params else "")
            if not task_id:
                await query.edit_message_text("Mã việc không hợp lệ.")
                return
            await handle_detail(query, db, db_user, task_id)

        # Task delete
        elif action == "task_delete":
            task_id = validate_task_id(params[0] if params else "")
            if not task_id:
                await query.edit_message_text("Mã việc không hợp lệ.")
                return
            await handle_delete_confirm(query, task_id)

        # Confirm delete
        elif action == "confirm":
            if len(params) >= 2 and params[0] == "delete":
                task_id = validate_task_id(params[1])
                if not task_id:
                    await query.edit_message_text("Mã việc không hợp lệ.")
                    return
                await handle_delete(query, db, db_user, task_id, context.bot, context)

        # Cancel action
        elif action == "cancel":
            await query.edit_message_text("Đã huỷ.")

        # Undo delete
        elif action == "task_undo":
            undo_id = validate_int(params[0] if params else "", min_val=1)
            if undo_id is None:
                await query.edit_message_text("Dữ liệu không hợp lệ.")
                return
            await handle_undo(query, db, undo_id, context)

        # Bulk undo delete
        elif action == "bulk_undo":
            undo_id = validate_int(params[0] if params else "", min_val=1)
            if undo_id is None:
                await query.edit_message_text("Dữ liệu không hợp lệ.")
                return
            await handle_bulk_undo(query, db, undo_id, context)

        # List navigation
        elif action == "list":
            list_type = validate_list_type(params[0] if params else "all")
            page = validate_int(params[1] if len(params) > 1 else "1", min_val=1, max_val=1000) or 1
            await handle_list_page(query, db, db_user, list_type, page)

        # No-op (for pagination display)
        elif action == "noop":
            pass

        # Task edit menu
        elif action == "task_edit":
            task_id = validate_task_id(params[0] if params else "")
            if not task_id:
                await query.edit_message_text("Mã việc không hợp lệ.")
                return
            await handle_edit_menu(query, db, db_user, task_id)

        # Edit content prompt
        elif action == "edit_content":
            task_id = validate_task_id(params[0] if params else "")
            if not task_id:
                await query.edit_message_text("Mã việc không hợp lệ.")
                return
            await handle_edit_content_prompt(query, db, db_user, task_id, context)

        # Edit deadline prompt
        elif action == "edit_deadline":
            task_id = validate_task_id(params[0] if params else "")
            if not task_id:
                await query.edit_message_text("Mã việc không hợp lệ.")
                return
            await handle_edit_deadline_prompt(query, db, db_user, task_id, context)

        # Edit priority menu
        elif action == "edit_priority":
            task_id = validate_task_id(params[0] if params else "")
            if not task_id:
                await query.edit_message_text("Mã việc không hợp lệ.")
                return
            await handle_edit_priority_menu(query, db, db_user, task_id)

        # Set priority
        elif action == "set_priority":
            task_id = validate_task_id(params[0] if params else "")
            priority = validate_priority(params[1] if len(params) > 1 else "")

            if not task_id:
                await query.edit_message_text("Mã việc không hợp lệ.")
                return
            if not priority:
                await query.edit_message_text("Độ ưu tiên không hợp lệ.")
                return

            await handle_set_priority(query, db, db_user, task_id, priority)

        # Edit assignee prompt
        elif action == "edit_assignee":
            task_id = validate_task_id(params[0] if params else "")
            if not task_id:
                await query.edit_message_text("Mã việc không hợp lệ.")
                return
            await handle_edit_assignee_prompt(query, db, db_user, task_id, context)

        # Task category menu
        elif action == "task_category":
            category = params[0].lower() if params else "menu"
            if category not in VALID_CATEGORIES:
                category = "menu"
            await handle_task_category(query, db, db_user, category)

        # Task type filter (Individual/Group)
        elif action == "task_filter":
            filter_type = params[0].lower() if params else "all"
            if filter_type not in VALID_FILTER_TYPES:
                filter_type = "all"
            list_type = validate_list_type(params[1] if len(params) > 1 else "all")
            await handle_task_filter(query, db, db_user, filter_type, list_type)

        # Statistics callbacks
        elif action in ("stats_weekly", "stats_monthly"):
            from handlers.statistics import handle_stats_callback
            await handle_stats_callback(update, context)

        # Bulk delete callbacks
        elif action == "bulk_delete":
            if len(params) < 2:
                await query.edit_message_text("Dữ liệu không hợp lệ.")
                return

            delete_type = params[0].lower()
            confirm_action = params[1].lower()

            if delete_type not in {"all", "assigned"}:
                await query.edit_message_text("Loại xóa không hợp lệ.")
                return
            if confirm_action not in {"confirm", "cancel"}:
                await query.edit_message_text("Hành động không hợp lệ.")
                return

            await handle_bulk_delete(query, db, db_user, delete_type, confirm_action, context)

        else:
            if action:
                logger.warning(f"Unknown callback action: {action}")

    except IndexError:
        logger.warning(f"Callback data missing params: {data}")
        await query.edit_message_text("Dữ liệu không đầy đủ.")
    except Exception as e:
        logger.error(f"Error in callback_router: {e}")
        await query.edit_message_text("Lỗi hệ thống. Vui lòng thử lại.")


async def handle_complete(query, db, db_user, task_id: str, bot) -> None:
    """Handle task completion callback."""
    task = await get_task_by_public_id(db, task_id)

    if not task:
        await query.edit_message_text(ERR_TASK_NOT_FOUND.format(task_id=task_id))
        return

    # Check permission
    if task["assignee_id"] != db_user["id"] and task["creator_id"] != db_user["id"]:
        await query.edit_message_text(ERR_NO_PERMISSION)
        return

    # Update status
    updated_task = await update_task_status(db, task["id"], "completed", db_user["id"])

    await query.edit_message_text(
        f"Đã hoàn thành việc {task_id}!\n\n"
        f"{task['content']}"
    )

    # Notify task creator/assigner
    from services.notification import send_task_completed_to_assigner
    await send_task_completed_to_assigner(bot, db, updated_task or task, db_user)


async def handle_progress_menu(query, task_id: str) -> None:
    """Show progress selection menu."""
    await query.edit_message_text(
        f"Chọn tiến độ mới cho {task_id}:",
        reply_markup=progress_keyboard(task_id),
    )


async def handle_progress_update(query, db, db_user, task_id: str, value: int) -> None:
    """Handle progress update callback."""
    task = await get_task_by_public_id(db, task_id)

    if not task:
        await query.edit_message_text(ERR_TASK_NOT_FOUND.format(task_id=task_id))
        return

    if task["assignee_id"] != db_user["id"]:
        await query.edit_message_text(ERR_NO_PERMISSION)
        return

    await update_task_progress(db, task["id"], value, db_user["id"])

    # Progress bar
    filled = int(10 * value / 100)
    bar = "█" * filled + "░" * (10 - filled)

    status = "Hoàn thành!" if value == 100 else "Đang làm"

    await query.edit_message_text(
        f"Cập nhật tiến độ <b>{task_id}</b>!\n\n"
        f"{bar} {value}%\n"
        f"<b>Trạng thái:</b> {status}",
        parse_mode="HTML",
    )


async def handle_detail(query, db, db_user, task_id: str) -> None:
    """Show task detail."""
    task = await get_task_by_public_id(db, task_id)

    if not task:
        await query.edit_message_text(ERR_TASK_NOT_FOUND.format(task_id=task_id))
        return

    can_edit = task["creator_id"] == db_user["id"]
    can_complete = task["assignee_id"] == db_user["id"] and task["status"] != "completed"

    msg = format_task_detail(task)
    keyboard = task_detail_keyboard(task_id, can_edit=can_edit, can_complete=can_complete)

    await query.edit_message_text(msg, reply_markup=keyboard, parse_mode="HTML")


async def handle_delete_confirm(query, task_id: str) -> None:
    """Show delete confirmation."""
    from utils import confirm_keyboard

    await query.edit_message_text(
        f"Xác nhận xóa việc {task_id}?",
        reply_markup=confirm_keyboard("delete", task_id),
    )


async def handle_delete(query, db, db_user, task_id: str, bot, context=None) -> None:
    """Process task deletion with countdown timer (10 seconds)."""
    success, result = await process_delete(db, task_id, db_user["id"], bot)

    if success:
        undo_id = result
        message = await query.edit_message_text(
            f"🗑️ Đã xóa việc {task_id}!\n\n"
            f"Bấm nút bên dưới để hoàn tác.",
            reply_markup=undo_keyboard(undo_id, 10),
        )

        # Schedule countdown updates if context is available
        if context and context.job_queue:
            chat_id = query.message.chat_id
            message_id = query.message.message_id

            # Schedule countdown updates every second (10s -> 1s)
            for seconds in range(9, 0, -1):
                context.job_queue.run_once(
                    countdown_update_job,
                    when=10 - seconds,
                    data={
                        "chat_id": chat_id,
                        "message_id": message_id,
                        "task_id": task_id,
                        "undo_id": undo_id,
                        "seconds": seconds,
                    },
                    name=f"undo_countdown_{undo_id}_{seconds}",
                )

            # Schedule final expiry message at 10 seconds
            context.job_queue.run_once(
                countdown_expired_job,
                when=10,
                data={
                    "chat_id": chat_id,
                    "message_id": message_id,
                    "task_id": task_id,
                    "undo_id": undo_id,
                },
                name=f"undo_expired_{undo_id}",
            )
    else:
        await query.edit_message_text(result)


async def countdown_update_job(context) -> None:
    """Job to update undo button countdown."""
    job_data = context.job.data
    chat_id = job_data["chat_id"]
    message_id = job_data["message_id"]
    task_id = job_data["task_id"]
    undo_id = job_data["undo_id"]
    seconds = job_data["seconds"]

    try:
        # Check if undo was already performed
        db = get_db()
        undo_record = await db.fetch_one(
            "SELECT is_restored FROM deleted_tasks_undo WHERE id = $1",
            undo_id
        )
        if not undo_record or undo_record["is_restored"]:
            return  # Undo already performed, skip update

        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=message_id,
            text=f"🗑️ Đã xóa việc {task_id}!\n\n"
                 f"Bấm nút bên dưới để hoàn tác.",
            reply_markup=undo_keyboard(undo_id, seconds),
        )
    except Exception as e:
        # Message may have been modified by user clicking undo
        logger.debug(f"Could not update countdown: {e}")


async def countdown_expired_job(context) -> None:
    """Job to handle undo expiry."""
    job_data = context.job.data
    chat_id = job_data["chat_id"]
    message_id = job_data["message_id"]
    task_id = job_data["task_id"]
    undo_id = job_data["undo_id"]

    try:
        # Check if undo was already performed
        db = get_db()
        undo_record = await db.fetch_one(
            "SELECT is_restored FROM deleted_tasks_undo WHERE id = $1",
            undo_id
        )
        if not undo_record or undo_record["is_restored"]:
            return  # Undo already performed, skip expiry message

        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=message_id,
            text=f"🗑️ Đã xóa việc {task_id}!\n\n"
                 f"⏰ Đã hết thời gian hoàn tác.",
        )
    except Exception as e:
        logger.debug(f"Could not update expired message: {e}")


async def handle_undo(query, db, undo_id: int, context=None) -> None:
    """Handle undo deletion."""
    # Cancel any pending countdown jobs (9s -> 1s)
    if context and context.job_queue:
        for seconds in range(9, 0, -1):
            jobs = context.job_queue.get_jobs_by_name(f"undo_countdown_{undo_id}_{seconds}")
            for job in jobs:
                job.schedule_removal()
        # Cancel expired job
        expired_jobs = context.job_queue.get_jobs_by_name(f"undo_expired_{undo_id}")
        for job in expired_jobs:
            job.schedule_removal()

    success, result = await process_restore(db, undo_id)

    if success:
        task = result
        await query.edit_message_text(
            MSG_TASK_RESTORED.format(task_id=task["public_id"])
        )
    else:
        await query.edit_message_text(result)


async def handle_bulk_undo(query, db, undo_id: int, context=None) -> None:
    """Handle bulk undo deletion."""
    from services import bulk_restore_tasks

    # Cancel any pending countdown jobs
    if context:
        job_queue = context.application.job_queue if hasattr(context, 'application') else context.job_queue
        if job_queue:
            current_jobs = job_queue.jobs()
            for job in current_jobs:
                if job.name and f"bulk_undo_{undo_id}" in job.name:
                    job.schedule_removal()

    restored_count = await bulk_restore_tasks(db, undo_id)

    if restored_count > 0:
        await query.edit_message_text(
            f"↩️ Đã hoàn tác xóa <b>{restored_count}</b> việc!",
            parse_mode="HTML",
        )
    else:
        await query.edit_message_text(
            "❌ Không thể hoàn tác. Đã hết thời gian (10 giây).",
        )


async def handle_list_page(query, db, db_user, list_type: str, page: int) -> None:
    """Handle list pagination."""
    from services import (
        get_user_personal_tasks,
        get_user_created_tasks,
        get_user_received_tasks,
        get_all_user_related_tasks,
    )
    from utils import task_list_with_pagination

    page_size = 10
    offset = (page - 1) * page_size

    if list_type == "personal":
        tasks = await get_user_personal_tasks(db, db_user["id"], limit=page_size, offset=offset)
        title = "📋 VIỆC CÁ NHÂN"
    elif list_type == "assigned":
        tasks = await get_user_created_tasks(db, db_user["id"], limit=page_size, offset=offset)
        title = "📤 VIỆC ĐÃ GIAO"
    elif list_type == "received":
        tasks = await get_user_received_tasks(db, db_user["id"], limit=page_size, offset=offset)
        title = "📥 VIỆC ĐÃ NHẬN"
    else:  # all
        tasks = await get_all_user_related_tasks(db, db_user["id"], limit=page_size, offset=offset)
        title = "📊 TẤT CẢ VIỆC"

    if not tasks:
        await query.edit_message_text(
            f"{title}\n\nKhông có việc nào.",
            reply_markup=task_category_keyboard(),
        )
        return

    # Estimate total pages (simplified)
    total_pages = page + (1 if len(tasks) == page_size else 0)
    total_count = len(tasks) + offset

    # Show only title with count - task list is in buttons
    msg = f"{title}\n\nTổng: {total_count} việc | Trang {page}/{total_pages}\n\nChọn việc để xem chi tiết:"

    await query.edit_message_text(
        msg,
        reply_markup=task_list_with_pagination(tasks, page, total_pages, list_type),
    )


async def handle_task_category(query, db, db_user, category: str) -> None:
    """Handle task category selection."""
    from services import (
        get_user_personal_tasks,
        get_user_created_tasks,
        get_user_received_tasks,
        get_all_user_related_tasks,
    )
    from utils import task_list_with_pagination

    page_size = 10

    if category == "menu":
        # Show category menu with filter options
        from telegram import InlineKeyboardButton, InlineKeyboardMarkup

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("📋 Việc cá nhân", callback_data="task_category:personal")],
            [InlineKeyboardButton("📤 Việc đã giao", callback_data="task_category:assigned")],
            [InlineKeyboardButton("📥 Việc đã nhận", callback_data="task_category:received")],
            [InlineKeyboardButton("📊 Tất cả việc", callback_data="task_category:all")],
            [
                InlineKeyboardButton("👤 Lọc: Cá nhân", callback_data="task_filter:individual"),
                InlineKeyboardButton("👥 Lọc: Nhóm", callback_data="task_filter:group"),
            ],
        ])

        await query.edit_message_text(
            "📋 CHỌN DANH MỤC VIỆC\n\n"
            "📋 Việc cá nhân - Việc bạn tự tạo cho mình\n"
            "📤 Việc đã giao - Việc bạn giao cho người khác\n"
            "📥 Việc đã nhận - Việc người khác giao cho bạn\n"
            "📊 Tất cả việc - Toàn bộ việc liên quan\n\n"
            "🔍 Lọc theo loại: Cá nhân (P-ID) | Nhóm (G-ID)",
            reply_markup=keyboard,
        )
        return

    if category == "personal":
        tasks = await get_user_personal_tasks(db, db_user["id"], limit=page_size)
        title = "📋 VIỆC CÁ NHÂN"
        list_type = "personal"
    elif category == "assigned":
        tasks = await get_user_created_tasks(db, db_user["id"], limit=page_size)
        title = "📤 VIỆC ĐÃ GIAO"
        list_type = "assigned"
    elif category == "received":
        tasks = await get_user_received_tasks(db, db_user["id"], limit=page_size)
        title = "📥 VIỆC ĐÃ NHẬN"
        list_type = "received"
    else:  # all
        tasks = await get_all_user_related_tasks(db, db_user["id"], limit=page_size)
        title = "📊 TẤT CẢ VIỆC"
        list_type = "all"

    if not tasks:
        await query.edit_message_text(
            f"{title}\n\nKhông có việc nào trong danh mục này.",
            reply_markup=task_category_keyboard(),
        )
        return

    total = len(tasks)
    total_pages = max(1, (total + page_size - 1) // page_size)

    # Show only title with count - task list is in buttons
    msg = f"{title}\n\nTổng: {total} việc | Trang 1/{total_pages}\n\nChọn việc để xem chi tiết:"

    await query.edit_message_text(
        msg,
        reply_markup=task_list_with_pagination(tasks, 1, total_pages, list_type),
    )


async def handle_task_filter(query, db, db_user, filter_type: str, list_type: str) -> None:
    """Handle task type filter (Individual/Group)."""
    from services import get_all_user_related_tasks
    from utils import task_type_filter_keyboard
    from telegram import InlineKeyboardMarkup, InlineKeyboardButton

    # Get all tasks first
    all_tasks = await get_all_user_related_tasks(db, db_user["id"], limit=50)

    if not all_tasks:
        await query.edit_message_text(
            "Không có việc nào.",
            reply_markup=task_category_keyboard(),
        )
        return

    # Filter by type
    if filter_type == "individual":
        # P-ID tasks (not starting with G)
        tasks = [t for t in all_tasks if not t.get("public_id", "").upper().startswith("G")]
        title = "👤 VIỆC CÁ NHÂN"
    elif filter_type == "group":
        # G-ID tasks (group tasks)
        tasks = [t for t in all_tasks if t.get("public_id", "").upper().startswith("G")]
        title = "👥 VIỆC NHÓM"
    else:
        tasks = all_tasks
        title = "📊 TẤT CẢ VIỆC"

    # Build filter buttons row
    filter_kb = task_type_filter_keyboard(filter_type)

    if not tasks:
        buttons = list(filter_kb.inline_keyboard) + [
            [InlineKeyboardButton("« Quay lại danh mục", callback_data="task_category:menu")]
        ]
        await query.edit_message_text(
            f"{title}\n\nKhông có việc nào trong danh mục này.",
            reply_markup=InlineKeyboardMarkup(buttons),
        )
        return

    total = len(tasks)
    total_pages = max(1, (total + 9) // 10)
    tasks = tasks[:10]  # First page

    # Show only title with count - task list is in buttons
    msg = f"{title}\n\nTổng: {total} việc | Trang 1/{total_pages}\n\nChọn việc để xem chi tiết:"

    # Build task buttons with longer content display
    task_buttons = []
    for task in tasks:
        task_id = task.get("public_id", "")
        content = task.get("content", "")[:40]
        if len(task.get("content", "")) > 40:
            content += "..."
        task_buttons.append([
            InlineKeyboardButton(f"{task_id}: {content}", callback_data=f"task_detail:{task_id}")
        ])

    # Pagination buttons
    nav_row = []
    nav_row.append(InlineKeyboardButton("1/{}".format(total_pages), callback_data="noop"))
    if total_pages > 1:
        nav_row.append(InlineKeyboardButton("Sau »", callback_data=f"task_filter:{filter_type}:2"))
    task_buttons.append(nav_row)

    # Combine: filter row + task buttons + back button
    all_buttons = list(filter_kb.inline_keyboard) + task_buttons + [
        [InlineKeyboardButton("« Quay lại danh mục", callback_data="task_category:menu")]
    ]

    await query.edit_message_text(
        msg,
        reply_markup=InlineKeyboardMarkup(all_buttons),
    )


async def handle_edit_menu(query, db, db_user, task_id: str) -> None:
    """Show edit options menu."""
    task = await get_task_by_public_id(db, task_id)

    if not task:
        await query.edit_message_text(ERR_TASK_NOT_FOUND.format(task_id=task_id))
        return

    # Only creator can edit
    if task["creator_id"] != db_user["id"]:
        await query.edit_message_text(ERR_NO_PERMISSION)
        return

    current_deadline = format_datetime(task.get("deadline")) if task.get("deadline") else "Không có"
    current_priority = format_priority(task.get("priority", "normal"))

    await query.edit_message_text(
        f"✏️ <b>SỬA VIỆC {task_id}</b>\n\n"
        f"📝 <b>Nội dung:</b> {task['content'][:100]}{'...' if len(task['content']) > 100 else ''}\n"
        f"📅 <b>Deadline:</b> {current_deadline}\n"
        f"🔔 <b>Độ ưu tiên:</b> {current_priority}\n\n"
        f"Chọn mục cần sửa:",
        reply_markup=edit_menu_keyboard(task_id),
        parse_mode="HTML",
    )


async def handle_edit_content_prompt(query, db, db_user, task_id: str, context) -> None:
    """Prompt user to enter new content."""
    task = await get_task_by_public_id(db, task_id)

    if not task:
        await query.edit_message_text(ERR_TASK_NOT_FOUND.format(task_id=task_id))
        return

    if task["creator_id"] != db_user["id"]:
        await query.edit_message_text(ERR_NO_PERMISSION)
        return

    # Store pending edit in user_data
    context.user_data["pending_edit"] = {
        "type": "content",
        "task_id": task_id,
        "task_db_id": task["id"],
    }

    await query.edit_message_text(
        f"📝 SỬA NỘI DUNG {task_id}\n\n"
        f"Nội dung hiện tại:\n{task['content']}\n\n"
        f"Hãy gửi nội dung mới cho việc này.\n"
        f"⚠️ REPLY tin nhắn này khi nhập (vuốt phải)\n"
        f"(Gửi /huy để hủy)"
    )


async def handle_edit_deadline_prompt(query, db, db_user, task_id: str, context) -> None:
    """Prompt user to enter new deadline."""
    task = await get_task_by_public_id(db, task_id)

    if not task:
        await query.edit_message_text(ERR_TASK_NOT_FOUND.format(task_id=task_id))
        return

    if task["creator_id"] != db_user["id"]:
        await query.edit_message_text(ERR_NO_PERMISSION)
        return

    # Store pending edit in user_data
    context.user_data["pending_edit"] = {
        "type": "deadline",
        "task_id": task_id,
        "task_db_id": task["id"],
    }

    current_deadline = format_datetime(task.get("deadline")) if task.get("deadline") else "Không có"

    await query.edit_message_text(
        f"📅 SỬA DEADLINE {task_id}\n\n"
        f"Deadline hiện tại: {current_deadline}\n\n"
        f"Hãy gửi deadline mới.\n"
        f"Ví dụ: ngày mai 9h, thứ 6, 25/12, cuối tuần\n\n"
        f"⚠️ REPLY tin nhắn này khi nhập (vuốt phải)\n"
        f"(Gửi /huy để hủy, gửi 'xóa' để xóa deadline)"
    )


async def handle_edit_priority_menu(query, db, db_user, task_id: str) -> None:
    """Show priority selection menu."""
    task = await get_task_by_public_id(db, task_id)

    if not task:
        await query.edit_message_text(ERR_TASK_NOT_FOUND.format(task_id=task_id))
        return

    if task["creator_id"] != db_user["id"]:
        await query.edit_message_text(ERR_NO_PERMISSION)
        return

    current_priority = format_priority(task.get("priority", "normal"))

    await query.edit_message_text(
        f"🔔 SỬA ĐỘ ƯU TIÊN {task_id}\n\n"
        f"Độ ưu tiên hiện tại: {current_priority}\n\n"
        f"Chọn độ ưu tiên mới:",
        reply_markup=edit_priority_keyboard(task_id),
    )


async def handle_set_priority(query, db, db_user, task_id: str, priority: str) -> None:
    """Set task priority."""
    task = await get_task_by_public_id(db, task_id)

    if not task:
        await query.edit_message_text(ERR_TASK_NOT_FOUND.format(task_id=task_id))
        return

    if task["creator_id"] != db_user["id"]:
        await query.edit_message_text(ERR_NO_PERMISSION)
        return

    await update_task_priority(db, task["id"], priority, db_user["id"])

    priority_text = format_priority(priority)

    await query.edit_message_text(
        f"✅ Đã cập nhật độ ưu tiên {task_id}!\n\n"
        f"🔔 Độ ưu tiên mới: {priority_text}"
    )


async def handle_edit_assignee_prompt(query, db, db_user, task_id: str, context) -> None:
    """Prompt user to enter new assignee(s)."""
    from services import is_group_task, get_child_tasks

    task = await get_task_by_public_id(db, task_id)

    if not task:
        await query.edit_message_text(ERR_TASK_NOT_FOUND.format(task_id=task_id))
        return

    if task["creator_id"] != db_user["id"]:
        await query.edit_message_text(ERR_NO_PERMISSION)
        return

    is_group = await is_group_task(db, task_id)

    # Store pending edit in user_data
    context.user_data["pending_edit"] = {
        "type": "assignee",
        "task_id": task_id,
        "task_db_id": task["id"],
        "is_group": is_group,
    }
    logger.info(f"Set pending_edit for assignee: task_id={task_id}, user_id={db_user['id']}")

    if is_group:
        # Get current assignees for group task with @username mentions
        children = await get_child_tasks(db, task_id)
        assignee_mentions = []
        for c in children:
            username = c.get("assignee_username")
            name = c.get("assignee_name", "?")
            if username:
                assignee_mentions.append(f"@{username} ({name})")
            else:
                assignee_mentions.append(name)
        current_assignees = ", ".join(assignee_mentions)
        await query.edit_message_text(
            f"👥 SỬA NGƯỜI NHẬN VIỆC NHÓM {task_id}\n\n"
            f"Người nhận hiện tại:\n{current_assignees}\n\n"
            f"📝 Nhập danh sách người nhận mới (cách nhau bằng dấu phẩy):\n"
            f"Ví dụ: @user1, @user2, @user3\n\n"
            f"💡 Nhập 1 người để chuyển thành việc cá nhân\n"
            f"⚠️ REPLY tin nhắn này khi nhập (vuốt phải)\n"
            f"(Gửi /huy để hủy)"
        )
    else:
        # Get username for individual task
        assignee_info = await db.fetch_one(
            "SELECT display_name, username FROM users WHERE id = $1",
            task.get("assignee_id")
        )
        if assignee_info:
            username = assignee_info.get("username")
            name = assignee_info.get("display_name", "?")
            current_assignee = f"@{username} ({name})" if username else name
        else:
            current_assignee = "Không rõ"
        await query.edit_message_text(
            f"👤 SỬA NGƯỜI NHẬN {task_id}\n\n"
            f"Người nhận hiện tại: {current_assignee}\n\n"
            f"📝 Nhập người nhận mới:\n"
            f"• 1 người: @username → việc cá nhân\n"
            f"• Nhiều người: @user1, @user2 → việc nhóm\n\n"
            f"⚠️ REPLY tin nhắn này khi nhập (vuốt phải)\n"
            f"(Gửi /huy để hủy)"
        )


async def handle_pending_edit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle text messages for pending edits (content/deadline)."""
    logger.info(f"handle_pending_edit called with text: {update.message.text[:50] if update.message and update.message.text else 'None'}")
    logger.info(f"user_data keys: {list(context.user_data.keys())}")

    pending = context.user_data.get("pending_edit")
    logger.info(f"pending_edit value: {pending}")

    if not pending:
        logger.info("No pending edit, returning")
        return  # No pending edit, let other handlers process

    user = update.effective_user
    text = update.message.text.strip()

    # Handle cancel
    if text.lower() in ("/huy", "/cancel", "hủy"):
        context.user_data.pop("pending_edit", None)
        await update.message.reply_text("Đã hủy chỉnh sửa.")
        return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)
        task_id = pending["task_id"]
        task_db_id = pending["task_db_id"]
        edit_type = pending["type"]

        if edit_type == "content":
            # Update content
            if len(text) < 3:
                await update.message.reply_text("Nội dung quá ngắn. Vui lòng nhập ít nhất 3 ký tự.")
                return

            await update_task_content(db, task_db_id, text, db_user["id"])
            context.user_data.pop("pending_edit", None)

            await update.message.reply_text(
                f"✅ Đã cập nhật nội dung {task_id}!\n\n"
                f"📝 Nội dung mới: {text[:200]}{'...' if len(text) > 200 else ''}"
            )

        elif edit_type == "deadline":
            # Handle remove deadline
            if text.lower() in ("xóa", "xoa", "remove", "clear"):
                await update_task_deadline(db, task_db_id, None, db_user["id"])
                context.user_data.pop("pending_edit", None)
                await update.message.reply_text(f"✅ Đã xóa deadline của {task_id}!")
                return

            # Parse deadline - returns (datetime, remaining_text) tuple
            deadline, _ = parse_vietnamese_time(text)
            if not deadline:
                await update.message.reply_text(
                    "Không hiểu được thời gian. Vui lòng thử lại.\n\n"
                    "Ví dụ: ngày mai 9h, thứ 6, 25/12, cuối tuần"
                )
                return

            await update_task_deadline(db, task_db_id, deadline, db_user["id"])
            context.user_data.pop("pending_edit", None)

            deadline_str = format_datetime(deadline)
            await update.message.reply_text(
                f"✅ Đã cập nhật deadline {task_id}!\n\n"
                f"📅 Deadline mới: {deadline_str}"
            )

        elif edit_type == "assignee":
            from services import convert_individual_to_group, update_group_assignees

            message = update.message
            assignees = []

            # Method 1: Check message entities for text_mention (users without @username)
            if message.entities:
                for entity in message.entities:
                    if entity.type == "text_mention" and entity.user:
                        # User without @username - get or create from entity.user
                        mentioned_user = await get_or_create_user(db, entity.user)
                        if not any(u["id"] == mentioned_user["id"] for u in assignees):
                            assignees.append(mentioned_user)
                            logger.info(f"Edit assignee - Found text_mention: {entity.user.first_name} (id={entity.user.id})")
                    elif entity.type == "mention":
                        # @username mention
                        full_text = message.text or ""
                        username_with_at = full_text[entity.offset:entity.offset + entity.length]
                        username = username_with_at.lstrip("@")
                        found_user = await get_user_by_username(db, username)
                        if found_user and not any(u["id"] == found_user["id"] for u in assignees):
                            assignees.append(found_user)
                            logger.info(f"Edit assignee - Found @mention: @{username} (id={found_user['id']})")

            # Method 2: Parse @username from text if no entities found
            if not assignees:
                raw_inputs = [x.strip().lstrip("@") for x in text.replace(",", " ").split()]
                raw_inputs = [x for x in raw_inputs if x]  # Remove empty
                not_found = []

                for inp in raw_inputs:
                    found = None
                    if inp.isdigit():
                        found = await db.fetch_one(
                            "SELECT id, display_name, telegram_id, username FROM users WHERE telegram_id = $1",
                            int(inp)
                        )
                    if not found:
                        found = await db.fetch_one(
                            "SELECT id, display_name, telegram_id, username FROM users WHERE LOWER(username) = LOWER($1)",
                            inp
                        )
                    if found:
                        assignees.append(dict(found))
                    else:
                        not_found.append(inp)

                if not_found:
                    await update.message.reply_text(
                        f"Không tìm thấy: {', '.join(not_found)}\n\n"
                        f"Người này cần đã từng tương tác với bot.\n"
                        f"💡 Hoặc dùng text mention (chạm tên trong nhóm)"
                    )
                    return

            if not assignees:
                await update.message.reply_text(
                    "Vui lòng nhập ít nhất 1 người nhận.\n\n"
                    "💡 Dùng @username hoặc text mention (chạm tên trong nhóm)"
                )
                return

            # Remove duplicates
            seen_ids = set()
            unique_assignees = []
            for a in assignees:
                if a["id"] not in seen_ids:
                    seen_ids.add(a["id"])
                    unique_assignees.append(a)
            assignees = unique_assignees

            is_group = pending.get("is_group", False)
            task = await get_task_by_public_id(db, task_id)

            if len(assignees) == 1:
                # Single assignee - update or convert to individual
                new_assignee = assignees[0]

                if is_group:
                    # Convert group to individual - soft delete group and children, create new P-ID
                    from services import get_child_tasks, soft_delete_task

                    children = await get_child_tasks(db, task_id)
                    # Delete all children
                    for child in children:
                        await soft_delete_task(db, child["id"], db_user["id"])
                    # Delete parent
                    await soft_delete_task(db, task_db_id, db_user["id"])

                    # Create new individual task
                    from services import create_task
                    new_task = await create_task(
                        db=db,
                        content=task["content"],
                        creator_id=task["creator_id"],
                        assignee_id=new_assignee["id"],
                        deadline=task.get("deadline"),
                        priority=task.get("priority", "normal"),
                    )

                    context.user_data.pop("pending_edit", None)
                    assignee_mention = mention_user(new_assignee)
                    await update.message.reply_text(
                        f"✅ Đã chuyển việc nhóm {task_id} → việc cá nhân {new_task['public_id']}!\n\n"
                        f"👤 Người nhận: {assignee_mention}",
                        parse_mode="Markdown"
                    )
                else:
                    # Simple update
                    await update_task_assignee(db, task_db_id, new_assignee["id"], db_user["id"])
                    context.user_data.pop("pending_edit", None)
                    assignee_mention = mention_user(new_assignee)
                    await update.message.reply_text(
                        f"✅ Đã cập nhật người nhận {task_id}!\n\n"
                        f"👤 Người nhận mới: {assignee_mention}",
                        parse_mode="Markdown"
                    )

                # Notify new assignee
                if new_assignee["telegram_id"] != user.id:
                    try:
                        await context.bot.send_message(
                            chat_id=new_assignee["telegram_id"],
                            text=f"📋 Bạn được giao việc!\n\n"
                                 f"Nội dung: {task['content']}\n"
                                 f"Từ: {db_user.get('display_name', 'N/A')}"
                        )
                    except Exception as e:
                        logger.warning(f"Could not notify assignee: {e}")

            else:
                # Multiple assignees - convert to group or update group
                assignee_mentions = ", ".join([mention_user(a) for a in assignees])

                if is_group:
                    # Update existing group
                    new_children = await update_group_assignees(db, task_id, assignees, db_user["id"])
                    context.user_data.pop("pending_edit", None)

                    await update.message.reply_text(
                        f"✅ Đã cập nhật việc nhóm {task_id}!\n\n"
                        f"👥 Người nhận: {assignee_mentions}",
                        parse_mode="Markdown"
                    )
                else:
                    # Convert individual to group
                    parent, children = await convert_individual_to_group(
                        db, task_db_id, assignees, db_user["id"]
                    )
                    context.user_data.pop("pending_edit", None)

                    child_ids = ", ".join([c[0]["public_id"] for c in children])
                    await update.message.reply_text(
                        f"✅ Đã chuyển việc cá nhân {task_id} → việc nhóm {parent['public_id']}!\n\n"
                        f"👥 Người nhận: {assignee_mentions}\n"
                        f"📋 Việc con: {child_ids}",
                        parse_mode="Markdown"
                    )

                # Notify all assignees
                for assignee in assignees:
                    if assignee["telegram_id"] != user.id:
                        try:
                            await context.bot.send_message(
                                chat_id=assignee["telegram_id"],
                                text=f"📋 Bạn được giao việc!\n\n"
                                     f"Nội dung: {task['content']}\n"
                                     f"Từ: {db_user.get('display_name', 'N/A')}"
                            )
                        except Exception as e:
                            logger.warning(f"Could not notify assignee: {e}")

    except Exception as e:
        logger.error(f"Error handling pending edit: {e}")
        await update.message.reply_text("Lỗi hệ thống. Vui lòng thử lại.")


async def handle_bulk_delete(query, db, db_user, delete_type: str, action: str, context) -> None:
    """Handle bulk delete confirmation/cancellation."""
    if action == "cancel":
        await query.edit_message_text("Đã hủy xóa hàng loạt.")
        return

    if action == "confirm":
        # Get task IDs from context
        task_ids = context.user_data.get("bulk_delete_ids", [])
        stored_type = context.user_data.get("bulk_delete_type", "")

        if not task_ids:
            await query.edit_message_text("Không tìm thấy danh sách việc cần xóa.")
            return

        if stored_type != delete_type:
            await query.edit_message_text("Lỗi xác thực. Vui lòng thử lại.")
            return

        # Process bulk deletion
        count = await bulk_delete_tasks(db, task_ids, db_user["id"])

        # Clear context data
        context.user_data.pop("bulk_delete_ids", None)
        context.user_data.pop("bulk_delete_type", None)

        if delete_type == "all":
            msg = f"✅ Đã xóa *{count}* việc thành công."
        else:
            msg = f"✅ Đã xóa *{count}* việc đã giao thành công."

        await query.edit_message_text(msg, parse_mode="Markdown")
        logger.info(f"Bulk deleted {count} tasks for user {db_user['id']} (type: {delete_type})")


def get_handlers() -> list:
    """Return callback query handler and pending edit message handler."""
    return [
        CallbackQueryHandler(callback_router),
        MessageHandler(
            filters.TEXT & ~filters.COMMAND,
            handle_pending_edit
        ),
    ]
</file>

<file path="handlers/export.py">
"""
Export Handler
Step-by-step export wizard for statistical reports
"""

import warnings
warnings.filterwarnings("ignore", message=".*per_message.*", category=UserWarning)

import os
import logging
from datetime import datetime, timedelta

import pytz
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ContextTypes,
    CommandHandler,
    CallbackQueryHandler,
    ConversationHandler,
    MessageHandler,
    filters,
)

from database import get_db
from services import get_or_create_user, create_export_report, REPORT_TTL_HOURS
from utils import ERR_DATABASE

logger = logging.getLogger(__name__)

TZ = pytz.timezone("Asia/Ho_Chi_Minh")

# Conversation states
PERIOD, CUSTOM_DATE, TASK_FILTER, FILE_FORMAT, CONFIRM = range(200, 205)

# Period options
PERIOD_OPTIONS = {
    "last7": "7 ngày qua",
    "last30": "30 ngày qua",
    "this_week": "Tuần này",
    "last_week": "Tuần trước",
    "this_month": "Tháng này",
    "last_month": "Tháng trước",
    "custom": "Tùy chọn ngày",
    "all": "Tất cả",
}

# Task filter options
FILTER_OPTIONS = {
    "all": "Tất cả việc",
    "created": "Việc đã tạo",
    "assigned": "Việc đã giao",
    "received": "Việc được giao",
}

# File format options
FORMAT_OPTIONS = {
    "csv": "CSV (đơn giản)",
    "xlsx": "Excel (có biểu đồ)",
    "pdf": "PDF (báo cáo đẹp)",
}


def get_export_data(context: ContextTypes.DEFAULT_TYPE) -> dict:
    """Get export wizard data from user_data."""
    if "export" not in context.user_data:
        context.user_data["export"] = {}
    return context.user_data["export"]


def clear_export_data(context: ContextTypes.DEFAULT_TYPE) -> None:
    """Clear export wizard data."""
    if "export" in context.user_data:
        del context.user_data["export"]


def period_keyboard() -> InlineKeyboardMarkup:
    """Create period selection keyboard."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("📅 7 ngày qua", callback_data="export_period:last7"),
            InlineKeyboardButton("📅 30 ngày qua", callback_data="export_period:last30"),
        ],
        [
            InlineKeyboardButton("📆 Tuần này", callback_data="export_period:this_week"),
            InlineKeyboardButton("📆 Tuần trước", callback_data="export_period:last_week"),
        ],
        [
            InlineKeyboardButton("📊 Tháng này", callback_data="export_period:this_month"),
            InlineKeyboardButton("📊 Tháng trước", callback_data="export_period:last_month"),
        ],
        [
            InlineKeyboardButton("📋 Tất cả thời gian", callback_data="export_period:all"),
        ],
        [
            InlineKeyboardButton("📆 Tùy chọn ngày", callback_data="export_period:custom"),
        ],
        [
            InlineKeyboardButton("❌ Hủy", callback_data="export_cancel"),
        ],
    ])


def filter_keyboard() -> InlineKeyboardMarkup:
    """Create task filter selection keyboard."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("📋 Tất cả việc", callback_data="export_filter:all"),
        ],
        [
            InlineKeyboardButton("✏️ Việc đã tạo", callback_data="export_filter:created"),
            InlineKeyboardButton("👤 Việc đã giao", callback_data="export_filter:assigned"),
        ],
        [
            InlineKeyboardButton("📬 Việc được giao", callback_data="export_filter:received"),
        ],
        [
            InlineKeyboardButton("« Quay lại", callback_data="export_back:period"),
            InlineKeyboardButton("❌ Hủy", callback_data="export_cancel"),
        ],
    ])


def format_keyboard() -> InlineKeyboardMarkup:
    """Create file format selection keyboard."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("📄 CSV", callback_data="export_format:csv"),
        ],
        [
            InlineKeyboardButton("📊 Excel (biểu đồ)", callback_data="export_format:xlsx"),
        ],
        [
            InlineKeyboardButton("📑 PDF (báo cáo)", callback_data="export_format:pdf"),
        ],
        [
            InlineKeyboardButton("« Quay lại", callback_data="export_back:filter"),
            InlineKeyboardButton("❌ Hủy", callback_data="export_cancel"),
        ],
    ])


def confirm_keyboard() -> InlineKeyboardMarkup:
    """Create confirmation keyboard."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("✅ Tạo báo cáo", callback_data="export_confirm:create"),
            InlineKeyboardButton("❌ Hủy bỏ", callback_data="export_confirm:cancel"),
        ],
        [
            InlineKeyboardButton("« Quay lại", callback_data="export_back:format"),
        ],
    ])


def format_summary(data: dict) -> str:
    """Format export settings summary."""
    period_key = data.get("period", "")
    if period_key == "custom":
        period = data.get("custom_display", "Tùy chọn ngày")
    else:
        period = PERIOD_OPTIONS.get(period_key, "?")
    task_filter = FILTER_OPTIONS.get(data.get("filter", ""), "?")
    file_format = FORMAT_OPTIONS.get(data.get("format", ""), "?")

    return f"""📊 XUẤT BÁO CÁO THỐNG KÊ

Khoảng thời gian: {period}
Loại việc: {task_filter}
Định dạng: {file_format}

Xác nhận tạo báo cáo?

⏱ Báo cáo sẽ hết hạn sau {REPORT_TTL_HOURS} giờ."""


# =============================================================================
# Entry Point
# =============================================================================


async def export_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Start export wizard."""
    user = update.effective_user
    if not user:
        return ConversationHandler.END

    clear_export_data(context)

    await update.message.reply_text(
        "📊 XUẤT BÁO CÁO THỐNG KÊ\n\n"
        "Bước 1/4: Chọn khoảng thời gian\n\n"
        "Chọn khoảng thời gian cho báo cáo:",
        reply_markup=period_keyboard(),
    )

    return PERIOD


# =============================================================================
# Step 1: Period Selection
# =============================================================================


async def period_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle period selection."""
    query = update.callback_query
    await query.answer()

    data = get_export_data(context)
    action = query.data.split(":")[1] if ":" in query.data else ""

    if action not in PERIOD_OPTIONS:
        return PERIOD

    data["period"] = action

    # Handle custom date range
    if action == "custom":
        await query.edit_message_text(
            "📅 NHẬP KHOẢNG THỜI GIAN TÙY CHỌN\n\n"
            "Nhập ngày bắt đầu và kết thúc theo định dạng:\n"
            "`DD/MM/YYYY - DD/MM/YYYY`\n\n"
            "Ví dụ: `01/12/2025 - 15/12/2025`\n\n"
            "Hoặc nhấn nút bên dưới để quay lại:",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("« Quay lại", callback_data="export_back:period")],
                [InlineKeyboardButton("❌ Hủy", callback_data="export_cancel")],
            ]),
        )
        return CUSTOM_DATE

    await query.edit_message_text(
        f"Khoảng thời gian: {PERIOD_OPTIONS[action]}\n\n"
        "Bước 2/4: Chọn loại việc\n\n"
        "Chọn loại việc cần xuất:",
        reply_markup=filter_keyboard(),
    )

    return TASK_FILTER


# =============================================================================
# Step 1b: Custom Date Input
# =============================================================================


async def custom_date_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle custom date input."""
    text = update.message.text.strip()
    data = get_export_data(context)

    try:
        # Parse format: DD/MM/YYYY - DD/MM/YYYY
        if " - " not in text:
            raise ValueError("Thiếu dấu ' - ' phân cách")

        parts = text.split(" - ")
        if len(parts) != 2:
            raise ValueError("Định dạng không hợp lệ")

        start_str, end_str = parts[0].strip(), parts[1].strip()

        # Parse dates
        start_date = datetime.strptime(start_str, "%d/%m/%Y")
        end_date = datetime.strptime(end_str, "%d/%m/%Y")

        # Validate date range
        if end_date < start_date:
            raise ValueError("Ngày kết thúc phải sau ngày bắt đầu")

        if (end_date - start_date).days > 365:
            raise ValueError("Khoảng thời gian không quá 1 năm")

        # Store custom dates with timezone
        data["custom_start"] = TZ.localize(start_date.replace(hour=0, minute=0, second=0))
        data["custom_end"] = TZ.localize(end_date.replace(hour=23, minute=59, second=59))
        data["custom_display"] = f"{start_str} - {end_str}"

        await update.message.reply_text(
            f"Khoảng thời gian: {start_str} đến {end_str}\n\n"
            "Bước 2/4: Chọn loại việc\n\n"
            "Chọn loại việc cần xuất:",
            reply_markup=filter_keyboard(),
        )
        return TASK_FILTER

    except ValueError as e:
        await update.message.reply_text(
            f"❌ Lỗi: {e}\n\n"
            "Vui lòng nhập đúng định dạng:\n"
            "`DD/MM/YYYY - DD/MM/YYYY`\n\n"
            "Ví dụ: `01/12/2025 - 15/12/2025`",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("« Quay lại", callback_data="export_back:period")],
                [InlineKeyboardButton("❌ Hủy", callback_data="export_cancel")],
            ]),
        )
        return CUSTOM_DATE


# =============================================================================
# Step 2: Task Filter Selection
# =============================================================================


async def filter_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle task filter selection."""
    query = update.callback_query
    await query.answer()

    data = get_export_data(context)
    action = query.data.split(":")[1] if ":" in query.data else ""

    if action not in FILTER_OPTIONS:
        return TASK_FILTER

    data["filter"] = action

    await query.edit_message_text(
        f"Loại việc: {FILTER_OPTIONS[action]}\n\n"
        "Bước 3/4: Chọn định dạng file\n\n"
        "📄 CSV - Đơn giản, mở được trong Excel\n"
        "📊 Excel - Có biểu đồ và màu sắc\n"
        "📑 PDF - Báo cáo đẹp, dễ chia sẻ",
        reply_markup=format_keyboard(),
    )

    return FILE_FORMAT


# =============================================================================
# Step 3: File Format Selection
# =============================================================================


async def format_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle file format selection."""
    query = update.callback_query
    await query.answer()

    data = get_export_data(context)
    action = query.data.split(":")[1] if ":" in query.data else ""

    if action not in FORMAT_OPTIONS:
        return FILE_FORMAT

    data["format"] = action

    summary = format_summary(data)
    await query.edit_message_text(
        f"Bước 4/4: Xác nhận\n\n{summary}",
        reply_markup=confirm_keyboard(),
    )

    return CONFIRM


# =============================================================================
# Step 4: Confirm and Generate
# =============================================================================


async def confirm_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle confirmation and generate report."""
    query = update.callback_query
    await query.answer()

    data = get_export_data(context)
    action = query.data.split(":")[1] if ":" in query.data else ""

    if action == "cancel":
        clear_export_data(context)
        await query.edit_message_text("Đã hủy xuất báo cáo.")
        return ConversationHandler.END

    if action == "create":
        await query.edit_message_text("⏳ Đang tạo báo cáo, vui lòng chờ...")

        try:
            db = get_db()
            user = update.effective_user
            db_user = await get_or_create_user(db, user)

            # Create the report with optional custom dates
            result = await create_export_report(
                db=db,
                user_id=db_user["id"],
                user_name=db_user.get("display_name") or user.full_name,
                report_type=data.get("period", "all"),
                file_format=data.get("format", "csv"),
                task_filter=data.get("filter", "all"),
                period_start=data.get("custom_start"),
                period_end=data.get("custom_end"),
            )

            # Get report URL from environment
            base_url = os.getenv("EXPORT_BASE_URL", "http://localhost:8080")
            report_url = f"{base_url}/report/{result['report_id']}"

            # Format file size
            file_size = result.get("file_size", 0)
            if file_size > 1024 * 1024:
                size_str = f"{file_size / 1024 / 1024:.1f} MB"
            elif file_size > 1024:
                size_str = f"{file_size / 1024:.1f} KB"
            else:
                size_str = f"{file_size} bytes"

            # Format expiry time
            expires_at = result.get("expires_at")
            if expires_at:
                expiry_str = expires_at.strftime("%H:%M %d/%m/%Y")
            else:
                expiry_str = "72 giờ"

            format_name = FORMAT_OPTIONS.get(data.get("format", "csv"), "File")

            message = f"""✅ BÁO CÁO ĐÃ TẠO THÀNH CÔNG!

📊 Định dạng: {format_name}
📦 Kích thước: {size_str}

🔗 Link tải về:
{report_url}

🔐 Mật khẩu: `{result['password']}`

⏱ Hết hạn: {expiry_str}

💡 Mở link trên trình duyệt, nhập mật khẩu để tải file."""

            await query.edit_message_text(message, parse_mode="Markdown")

            logger.info(f"Export: User {user.id} created report {result['report_id']}")

        except Exception as e:
            logger.error(f"Error creating export report: {e}")
            await query.edit_message_text(f"❌ Lỗi tạo báo cáo: {str(e)}")

        clear_export_data(context)
        return ConversationHandler.END

    return CONFIRM


# =============================================================================
# Back Handler
# =============================================================================


async def back_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle back button."""
    query = update.callback_query
    await query.answer()

    target = query.data.split(":")[1] if ":" in query.data else ""
    data = get_export_data(context)

    if target == "period":
        await query.edit_message_text(
            "📊 XUẤT BÁO CÁO THỐNG KÊ\n\n"
            "Bước 1/4: Chọn khoảng thời gian\n\n"
            "Chọn khoảng thời gian cho báo cáo:",
            reply_markup=period_keyboard(),
        )
        return PERIOD

    elif target == "filter":
        period = PERIOD_OPTIONS.get(data.get("period", ""), "?")
        await query.edit_message_text(
            f"Khoảng thời gian: {period}\n\n"
            "Bước 2/4: Chọn loại việc\n\n"
            "Chọn loại việc cần xuất:",
            reply_markup=filter_keyboard(),
        )
        return TASK_FILTER

    elif target == "format":
        task_filter = FILTER_OPTIONS.get(data.get("filter", ""), "?")
        await query.edit_message_text(
            f"Loại việc: {task_filter}\n\n"
            "Bước 3/4: Chọn định dạng file\n\n"
            "📄 CSV - Đơn giản, mở được trong Excel\n"
            "📊 Excel - Có biểu đồ và màu sắc\n"
            "📑 PDF - Báo cáo đẹp, dễ chia sẻ",
            reply_markup=format_keyboard(),
        )
        return FILE_FORMAT

    return PERIOD


# =============================================================================
# Cancel Handler
# =============================================================================


async def cancel_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle cancel button."""
    query = update.callback_query
    await query.answer()

    clear_export_data(context)
    await query.edit_message_text("Đã hủy xuất báo cáo.")
    return ConversationHandler.END


async def cancel_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle /huy command."""
    clear_export_data(context)
    await update.message.reply_text("Đã hủy xuất báo cáo.")
    return ConversationHandler.END


# =============================================================================
# Handler Registration
# =============================================================================


def get_export_conversation_handler() -> ConversationHandler:
    """Get the export wizard ConversationHandler."""
    return ConversationHandler(
        entry_points=[
            CommandHandler("export", export_start),
            CommandHandler("xuatbaocao", export_start),
        ],
        states={
            PERIOD: [
                CallbackQueryHandler(period_callback, pattern=r"^export_period:"),
                CallbackQueryHandler(cancel_callback, pattern=r"^export_cancel$"),
            ],
            CUSTOM_DATE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, custom_date_handler),
                CallbackQueryHandler(back_callback, pattern=r"^export_back:"),
                CallbackQueryHandler(cancel_callback, pattern=r"^export_cancel$"),
            ],
            TASK_FILTER: [
                CallbackQueryHandler(filter_callback, pattern=r"^export_filter:"),
                CallbackQueryHandler(back_callback, pattern=r"^export_back:"),
                CallbackQueryHandler(cancel_callback, pattern=r"^export_cancel$"),
            ],
            FILE_FORMAT: [
                CallbackQueryHandler(format_callback, pattern=r"^export_format:"),
                CallbackQueryHandler(back_callback, pattern=r"^export_back:"),
                CallbackQueryHandler(cancel_callback, pattern=r"^export_cancel$"),
            ],
            CONFIRM: [
                CallbackQueryHandler(confirm_callback, pattern=r"^export_confirm:"),
                CallbackQueryHandler(back_callback, pattern=r"^export_back:"),
                CallbackQueryHandler(cancel_callback, pattern=r"^export_cancel$"),
            ],
        },
        fallbacks=[
            CommandHandler("huy", cancel_command),
            CommandHandler("cancel", cancel_command),
            CallbackQueryHandler(cancel_callback, pattern=r"^export_cancel$"),
        ],
        per_user=True,
        per_chat=True,
        per_message=False,
    )


def get_handlers() -> list:
    """Return list of handlers for this module."""
    return [
        get_export_conversation_handler(),
    ]
</file>

<file path="handlers/recurring_task.py">
"""
Recurring Task Handler
Handles commands for recurring/scheduled task templates
"""

import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ContextTypes,
    CommandHandler,
    CallbackQueryHandler,
    ConversationHandler,
    MessageHandler,
    filters,
)

from database import get_db
from services import (
    get_or_create_user,
    create_recurring_template,
    get_recurring_template,
    get_user_recurring_templates,
    toggle_recurring_template,
    delete_recurring_template,
    parse_recurrence_pattern,
    format_recurrence_description,
)
from utils import (
    ERR_DATABASE,
    ERR_NOT_FOUND,
    ERR_NO_CONTENT,
    validate_task_content,
    format_datetime,
    format_priority,
)

logger = logging.getLogger(__name__)

# Conversation states
CONTENT, RECURRENCE, CONFIRM = range(3)


async def vieclaplai_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Handle /vieclaplai command.
    Start conversation to create recurring task template.

    Format: /vieclaplai [nội dung] [lịch lặp]
    Examples:
        /vieclaplai Họp đội hàng tuần thứ 2 9h
        /vieclaplai Báo cáo tháng hàng tháng ngày 1
        /vieclaplai Kiểm tra email hàng ngày 8h
    """
    user = update.effective_user
    if not user:
        return ConversationHandler.END

    text = " ".join(context.args) if context.args else ""

    if not text:
        # Start conversation flow
        await update.message.reply_text(
            "📅 *TẠO VIỆC LẶP LẠI*\n\n"
            "Nhập nội dung việc và lịch lặp lại:\n\n"
            "Ví dụ:\n"
            "• `Họp đội hàng tuần thứ 2 9h`\n"
            "• `Báo cáo hàng tháng ngày 1 10h`\n"
            "• `Kiểm tra email hàng ngày 8h`\n\n"
            "Hoặc nhập `/huy` để hủy.",
            parse_mode="Markdown",
        )
        return CONTENT

    # Direct creation with arguments
    return await process_recurring_creation(update, context, text)


async def receive_content(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Receive task content and recurrence pattern."""
    text = update.message.text.strip()

    if text.lower() == "/huy":
        await update.message.reply_text("Đã hủy tạo việc lặp lại.")
        return ConversationHandler.END

    return await process_recurring_creation(update, context, text)


async def process_recurring_creation(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    text: str,
) -> int:
    """Process recurring task creation from text."""
    user = update.effective_user

    try:
        db = get_db()

        # Get/create user
        db_user = await get_or_create_user(db, user)
        user_id = db_user["id"]

        # Parse recurrence pattern
        recurrence, remaining = parse_recurrence_pattern(text)

        if not recurrence:
            await update.message.reply_text(
                "⚠️ Không nhận dạng được lịch lặp lại.\n\n"
                "Vui lòng thêm một trong các mẫu:\n"
                "• `hàng ngày` / `mỗi ngày`\n"
                "• `hàng tuần` / `mỗi tuần`\n"
                "• `hàng tháng` / `mỗi tháng`\n"
                "• `mỗi 2 ngày` / `mỗi 3 tuần`\n\n"
                "Ví dụ: `Họp đội hàng tuần thứ 2 9h`",
                parse_mode="Markdown",
            )
            return CONTENT if context.args is None else ConversationHandler.END

        # Validate content
        content = remaining.strip() if remaining else text
        is_valid, result = validate_task_content(content)

        if not is_valid:
            await update.message.reply_text(result)
            return CONTENT if context.args is None else ConversationHandler.END

        content = result

        # Create recurring template
        template = await create_recurring_template(
            db=db,
            content=content,
            creator_id=user_id,
            recurrence_type=recurrence["recurrence_type"],
            recurrence_interval=recurrence.get("recurrence_interval", 1),
            recurrence_days=recurrence.get("recurrence_days"),
            recurrence_time=recurrence.get("recurrence_time"),
        )

        # Format response
        recurrence_str = format_recurrence_description(template)
        next_due_str = format_datetime(template["next_due"], relative=True) if template["next_due"] else "N/A"

        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("⏸ Tạm dừng", callback_data=f"recurring_pause:{template['public_id']}"),
                InlineKeyboardButton("🗑 Xóa", callback_data=f"recurring_delete:{template['public_id']}"),
            ],
            [
                InlineKeyboardButton("📋 Danh sách việc lặp", callback_data="recurring_list"),
            ],
        ])

        await update.message.reply_text(
            f"✅ *ĐÃ TẠO VIỆC LẶP LẠI*\n\n"
            f"🆔 `{template['public_id']}`\n"
            f"📝 {content}\n\n"
            f"🔄 Lịch: {recurrence_str}\n"
            f"⏰ Việc tiếp theo: {next_due_str}\n\n"
            f"_Hệ thống sẽ tự động tạo việc theo lịch._",
            parse_mode="Markdown",
            reply_markup=keyboard,
        )

        logger.info(f"User {user.id} created recurring template {template['public_id']}")
        return ConversationHandler.END

    except Exception as e:
        logger.error(f"Error in recurring creation: {e}")
        await update.message.reply_text(ERR_DATABASE)
        return ConversationHandler.END


async def cancel_recurring(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancel recurring task creation."""
    await update.message.reply_text("Đã hủy tạo việc lặp lại.")
    return ConversationHandler.END


async def danhsachvieclaplai_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /danhsachvieclaplai command.
    List user's recurring task templates.
    """
    user = update.effective_user
    if not user:
        return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)
        user_id = db_user["id"]

        templates = await get_user_recurring_templates(db, user_id, active_only=False)

        if not templates:
            await update.message.reply_text(
                "Bạn chưa có việc lặp lại nào.\n\n"
                "Tạo mới: /vieclaplai [nội dung] [lịch lặp]"
            )
            return

        # Format list
        lines = ["📅 *DANH SÁCH VIỆC LẶP LẠI*\n"]

        for t in templates:
            status = "✅" if t["is_active"] else "⏸"
            recurrence_str = format_recurrence_description(t)
            next_str = format_datetime(t["next_due"], relative=True) if t["next_due"] else "N/A"

            lines.append(
                f"{status} `{t['public_id']}`: {t['content'][:40]}\n"
                f"   🔄 {recurrence_str}\n"
                f"   ⏰ Tiếp theo: {next_str}\n"
            )

        lines.append(f"\n_Tổng: {len(templates)} mẫu_")

        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("➕ Tạo mới", callback_data="recurring_new")],
        ])

        await update.message.reply_text(
            "\n".join(lines),
            parse_mode="Markdown",
            reply_markup=keyboard,
        )

    except Exception as e:
        logger.error(f"Error in danhsachvieclaplai: {e}")
        await update.message.reply_text(ERR_DATABASE)


async def recurring_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle recurring task callbacks."""
    query = update.callback_query
    await query.answer()

    data = query.data
    user = update.effective_user

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        if data == "recurring_list":
            # Redirect to list command
            templates = await get_user_recurring_templates(db, db_user["id"], active_only=False)

            if not templates:
                await query.edit_message_text(
                    "Bạn chưa có việc lặp lại nào.\n\n"
                    "Tạo mới: /vieclaplai [nội dung] [lịch lặp]"
                )
                return

            lines = ["📅 *DANH SÁCH VIỆC LẶP LẠI*\n"]
            for t in templates:
                status = "✅" if t["is_active"] else "⏸"
                recurrence_str = format_recurrence_description(t)
                lines.append(f"{status} `{t['public_id']}`: {t['content'][:40]}\n   🔄 {recurrence_str}\n")

            await query.edit_message_text("\n".join(lines), parse_mode="Markdown")
            return

        elif data == "recurring_new":
            await query.edit_message_text(
                "Tạo việc lặp lại mới: /vieclaplai [nội dung] [lịch lặp]\n\n"
                "Ví dụ: `/vieclaplai Họp đội hàng tuần thứ 2 9h`",
                parse_mode="Markdown",
            )
            return

        # Parse action:public_id
        parts = data.split(":")
        if len(parts) != 2:
            return

        action, public_id = parts

        template = await get_recurring_template(db, public_id)
        if not template:
            await query.edit_message_text(ERR_NOT_FOUND)
            return

        # Check ownership
        if template["creator_id"] != db_user["id"]:
            await query.edit_message_text("Bạn không có quyền thao tác với mẫu này.")
            return

        if action == "recurring_pause":
            # Toggle active state
            new_state = not template["is_active"]
            await toggle_recurring_template(db, template["id"], new_state)

            status_text = "đã kích hoạt" if new_state else "đã tạm dừng"
            status_emoji = "✅" if new_state else "⏸"

            keyboard = InlineKeyboardMarkup([
                [
                    InlineKeyboardButton(
                        "▶️ Kích hoạt" if not new_state else "⏸ Tạm dừng",
                        callback_data=f"recurring_pause:{public_id}"
                    ),
                    InlineKeyboardButton("🗑 Xóa", callback_data=f"recurring_delete:{public_id}"),
                ],
            ])

            await query.edit_message_text(
                f"{status_emoji} Việc lặp lại `{public_id}` {status_text}.\n\n"
                f"📝 {template['content']}",
                parse_mode="Markdown",
                reply_markup=keyboard,
            )

        elif action == "recurring_delete":
            # Confirm deletion
            keyboard = InlineKeyboardMarkup([
                [
                    InlineKeyboardButton("✅ Xác nhận xóa", callback_data=f"recurring_confirm_delete:{public_id}"),
                    InlineKeyboardButton("❌ Hủy", callback_data=f"recurring_cancel_delete:{public_id}"),
                ],
            ])

            await query.edit_message_text(
                f"⚠️ Xác nhận xóa việc lặp lại?\n\n"
                f"🆔 `{public_id}`\n"
                f"📝 {template['content']}\n\n"
                f"_Thao tác này không thể hoàn tác._",
                parse_mode="Markdown",
                reply_markup=keyboard,
            )

        elif action == "recurring_confirm_delete":
            await delete_recurring_template(db, template["id"])
            await query.edit_message_text(
                f"✅ Đã xóa việc lặp lại `{public_id}`.",
                parse_mode="Markdown",
            )
            logger.info(f"User {user.id} deleted recurring template {public_id}")

        elif action == "recurring_cancel_delete":
            recurrence_str = format_recurrence_description(template)

            keyboard = InlineKeyboardMarkup([
                [
                    InlineKeyboardButton(
                        "⏸ Tạm dừng" if template["is_active"] else "▶️ Kích hoạt",
                        callback_data=f"recurring_pause:{public_id}"
                    ),
                    InlineKeyboardButton("🗑 Xóa", callback_data=f"recurring_delete:{public_id}"),
                ],
            ])

            await query.edit_message_text(
                f"📅 *VIỆC LẶP LẠI*\n\n"
                f"🆔 `{public_id}`\n"
                f"📝 {template['content']}\n"
                f"🔄 {recurrence_str}\n"
                f"📊 Đã tạo: {template['instances_created']} việc",
                parse_mode="Markdown",
                reply_markup=keyboard,
            )

    except Exception as e:
        logger.error(f"Error in recurring callback: {e}")
        await query.edit_message_text(ERR_DATABASE)


def get_handlers() -> list:
    """Return list of handlers for this module."""
    # Conversation handler for /vieclaplai
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("vieclaplai", vieclaplai_command)],
        states={
            CONTENT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, receive_content),
                CommandHandler("huy", cancel_recurring),
            ],
        },
        fallbacks=[CommandHandler("huy", cancel_recurring)],
    )

    return [
        conv_handler,
        CommandHandler("danhsachvieclaplai", danhsachvieclaplai_command),
        CallbackQueryHandler(recurring_callback, pattern=r"^recurring_"),
    ]
</file>

<file path="handlers/reminder.py">
"""
Reminder Handler
Commands for managing task reminders
"""

import logging
import re
from datetime import datetime, timedelta

from telegram import Update
from telegram.ext import ContextTypes, CommandHandler
import pytz

from database import get_db
from services import get_or_create_user, get_task_by_public_id, parse_vietnamese_time
from services.reminder_service import create_reminder, get_task_reminders, snooze_reminder
from utils import ERR_TASK_NOT_FOUND, ERR_NO_PERMISSION, ERR_DATABASE

logger = logging.getLogger(__name__)

TZ = pytz.timezone("Asia/Ho_Chi_Minh")


async def nhacviec_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /nhacviec [task_id] [time] command.
    Set custom reminder for a task.

    Examples:
        /nhacviec P-0001 14h30
        /nhacviec P-0001 ngay mai 9h
        /nhacviec P-0001 2 tieng truoc deadline
    """
    user = update.effective_user
    if not user:
        return

    if len(context.args) < 2:
        await update.message.reply_text(
            "Cú pháp: /nhacviec [mã việc] [thời gian]\n\n"
            "Ví dụ:\n"
            "  /nhacviec P-0001 14h30\n"
            "  /nhacviec P-0001 ngày mai 9h\n"
            "  /nhacviec P-0001 2 tiếng trước deadline"
        )
        return

    task_id = context.args[0].upper()
    time_text = " ".join(context.args[1:])

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        # Get task
        task = await get_task_by_public_id(db, task_id)

        if not task:
            await update.message.reply_text(ERR_TASK_NOT_FOUND.format(task_id=task_id))
            return

        # Check permission (assignee or creator)
        if task["assignee_id"] != db_user["id"] and task["creator_id"] != db_user["id"]:
            await update.message.reply_text(ERR_NO_PERMISSION)
            return

        # Parse time
        remind_at = None

        # Check if relative to deadline
        if "truoc deadline" in time_text.lower() and task.get("deadline"):
            remind_at = parse_relative_to_deadline(task["deadline"], time_text)
        else:
            # Parse absolute time
            remind_at, _ = parse_vietnamese_time(time_text)

        if not remind_at:
            await update.message.reply_text(
                "Không hiểu thời gian. Vui lòng thử lại.\n\n"
                "Ví dụ: 14h30, ngày mai 9h, 2 tiếng trước deadline"
            )
            return

        now = datetime.now(TZ)
        if remind_at.tzinfo is None:
            remind_at = TZ.localize(remind_at)

        if remind_at <= now:
            await update.message.reply_text("Thời gian nhắc phải trong tương lai.")
            return

        # Create reminder
        reminder = await create_reminder(
            db, task["id"], db_user["id"], remind_at,
            "custom", time_text[:50]
        )

        if not reminder:
            await update.message.reply_text("Không thể tạo nhắc việc. Có thể đã tồn tại.")
            return

        # Schedule with APScheduler if available
        try:
            from scheduler.reminder_scheduler import reminder_scheduler
            if reminder_scheduler.scheduler:
                reminder_scheduler.add_custom_reminder(task["id"], db_user["id"], remind_at)
        except Exception as e:
            logger.warning(f"Could not schedule custom reminder: {e}")

        await update.message.reply_text(
            f"Đã đặt nhắc việc!\n\n"
            f"{task_id}: {task['content'][:50]}...\n"
            f"Sẽ nhắc lúc: {remind_at.strftime('%H:%M %d/%m/%Y')}"
        )

    except Exception as e:
        logger.error(f"Error in nhacviec_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


async def xemnhac_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /xemnhac [task_id] command.
    View reminders for a task.
    """
    user = update.effective_user
    if not user:
        return

    if not context.args:
        await update.message.reply_text(
            "Cú pháp: /xemnhac [mã việc]\n\n"
            "Ví dụ: /xemnhac P-0001"
        )
        return

    task_id = context.args[0].upper()

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        task = await get_task_by_public_id(db, task_id)

        if not task:
            await update.message.reply_text(ERR_TASK_NOT_FOUND.format(task_id=task_id))
            return

        # Get reminders
        reminders = await get_task_reminders(db, task["id"], pending_only=True)

        if not reminders:
            await update.message.reply_text(f"Không có nhắc việc nào cho {task_id}.")
            return

        lines = [f"Nhắc việc cho {task_id}:\n"]
        for r in reminders:
            remind_at = r["remind_at"]
            if remind_at.tzinfo is None:
                remind_at = TZ.localize(remind_at)
            lines.append(f"  - {remind_at.strftime('%H:%M %d/%m')} ({r['reminder_type']})")

        await update.message.reply_text("\n".join(lines))

    except Exception as e:
        logger.error(f"Error in xemnhac_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


def parse_relative_to_deadline(deadline: datetime, text: str) -> datetime:
    """
    Parse time relative to deadline.

    Examples:
        "2 tieng truoc deadline" -> deadline - 2 hours
        "30 phut truoc deadline" -> deadline - 30 minutes
    """
    if deadline.tzinfo is None:
        deadline = TZ.localize(deadline)

    text = text.lower()

    # Match pattern: number + unit + truoc
    match = re.search(r"(\d+)\s*(tieng|gio|phut|ngay)\s*truoc", text)
    if not match:
        return None

    amount = int(match.group(1))
    unit = match.group(2)

    if unit in ("tieng", "gio"):
        return deadline - timedelta(hours=amount)
    elif unit == "phut":
        return deadline - timedelta(minutes=amount)
    elif unit == "ngay":
        return deadline - timedelta(days=amount)

    return None


def get_handlers() -> list:
    """Return list of handlers for this module."""
    return [
        CommandHandler("nhacviec", nhacviec_command),
        CommandHandler("xemnhac", xemnhac_command),
    ]
</file>

<file path="handlers/settings.py">
"""
Settings Handler
User preference configuration: notifications, timezone, reminder settings
Organized with submenus for better UX
"""

import warnings
warnings.filterwarnings("ignore", message=".*per_message.*", category=UserWarning)

import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ContextTypes,
    CommandHandler,
    CallbackQueryHandler,
    ConversationHandler,
)

from database import get_db
from services.user_service import get_or_create_user
from utils.db_utils import validate_user_setting_column, InvalidColumnError

logger = logging.getLogger(__name__)

# Conversation states
SETTINGS_MENU = 0

# Timezone options (Vietnam-centric)
TIMEZONE_OPTIONS = [
    ("Asia/Ho_Chi_Minh", "🇻🇳 Việt Nam (GMT+7)"),
    ("Asia/Bangkok", "🇹🇭 Thái Lan (GMT+7)"),
    ("Asia/Singapore", "🇸🇬 Singapore (GMT+8)"),
    ("Asia/Tokyo", "🇯🇵 Nhật Bản (GMT+9)"),
    ("UTC", "🌍 UTC (GMT+0)"),
]

# Reminder time options
REMINDER_OPTIONS = [
    ("remind_24h", "24h trước"),
    ("remind_1h", "1h trước"),
    ("remind_30m", "30 phút trước"),
    ("remind_5m", "5 phút trước"),
    ("remind_overdue", "Quá hạn"),
]

# Reminder source options
REMINDER_SOURCE_OPTIONS = [
    ("telegram", "✈️ Telegram"),
    ("google_calendar", "📅 Google Calendar"),
    ("both", "✈️ + 📅 Cả hai"),
]


def on_off_button(label: str, is_on: bool, callback: str) -> InlineKeyboardButton:
    """Create a button with clear ON/OFF status."""
    status = "🟢" if is_on else "🔴"
    return InlineKeyboardButton(f"{status} {label}", callback_data=callback)


def get_tz_display(timezone: str) -> str:
    """Get timezone display name."""
    for tz_code, tz_name in TIMEZONE_OPTIONS:
        if tz_code == timezone:
            return tz_name
    return timezone


def get_source_display(source: str) -> str:
    """Get reminder source display name."""
    for src_code, src_label in REMINDER_SOURCE_OPTIONS:
        if src_code == source:
            return src_label
    return "✈️ + 📅 Cả hai"


# ============================================
# MAIN MENU - 2 categories (notifications, timezone)
# ============================================

def main_menu_keyboard(user_data: dict) -> InlineKeyboardMarkup:
    """Create main settings menu with 2 categories."""
    timezone = user_data.get("timezone", "Asia/Ho_Chi_Minh")
    tz_short = "GMT+7" if "Ho_Chi_Minh" in timezone or "Bangkok" in timezone else timezone[:10]

    return InlineKeyboardMarkup([
        [InlineKeyboardButton("🔔 Thông báo »", callback_data="settings:notifications")],
        [InlineKeyboardButton(f"🌏 Múi giờ: {tz_short}", callback_data="settings:edit:timezone")],
        [InlineKeyboardButton("❌ Đóng", callback_data="settings:close")],
    ])


# ============================================
# NOTIFICATIONS SUBMENU
# ============================================

def notifications_menu_keyboard(user_data: dict) -> InlineKeyboardMarkup:
    """Create notifications submenu."""
    notify_task_assigned = user_data.get("notify_task_assigned", True)
    notify_task_status = user_data.get("notify_task_status", True)
    weekly_report = user_data.get("notify_weekly_report", True)
    monthly_report = user_data.get("notify_monthly_report", True)

    return InlineKeyboardMarkup([
        [on_off_button("Giao việc mới", notify_task_assigned, "settings:toggle:notify_task_assigned")],
        [on_off_button("Trạng thái việc", notify_task_status, "settings:toggle:notify_task_status")],
        [InlineKeyboardButton("⏰ Nhắc việc »", callback_data="settings:reminders")],
        [on_off_button("Báo cáo tuần", weekly_report, "settings:toggle:notify_weekly_report")],
        [on_off_button("Báo cáo tháng", monthly_report, "settings:toggle:notify_monthly_report")],
        [InlineKeyboardButton("« Quay lại", callback_data="settings:back")],
    ])


# ============================================
# REMINDER SETTINGS SUBMENU
# ============================================

def reminders_menu_keyboard(user_data: dict) -> InlineKeyboardMarkup:
    """Create reminder settings submenu."""
    reminder_source = user_data.get("reminder_source", "both")
    source_display = get_source_display(reminder_source)

    buttons = [
        [InlineKeyboardButton(f"🔔 Nguồn: {source_display}", callback_data="settings:edit:reminder_source")],
    ]

    for column, label in REMINDER_OPTIONS:
        is_on = user_data.get(column, True)
        buttons.append([on_off_button(label, is_on, f"settings:toggle:{column}")])

    buttons.append([InlineKeyboardButton("« Quay lại", callback_data="settings:notifications")])

    return InlineKeyboardMarkup(buttons)


def reminder_source_keyboard(current: str) -> InlineKeyboardMarkup:
    """Create reminder source selection keyboard."""
    buttons = []
    for source_code, source_label in REMINDER_SOURCE_OPTIONS:
        prefix = "✅ " if source_code == current else ""
        buttons.append([
            InlineKeyboardButton(
                f"{prefix}{source_label}",
                callback_data=f"settings:set:reminder_source:{source_code}"
            )
        ])
    buttons.append([InlineKeyboardButton("« Quay lại", callback_data="settings:reminders")])
    return InlineKeyboardMarkup(buttons)


# ============================================
# TIMEZONE SELECTION
# ============================================

def timezone_keyboard() -> InlineKeyboardMarkup:
    """Create timezone selection keyboard."""
    buttons = []
    for tz_code, tz_name in TIMEZONE_OPTIONS:
        buttons.append([
            InlineKeyboardButton(tz_name, callback_data=f"settings:set:timezone:{tz_code}")
        ])
    buttons.append([InlineKeyboardButton("« Quay lại", callback_data="settings:back")])
    return InlineKeyboardMarkup(buttons)


# ============================================
# DATABASE HELPERS
# ============================================

async def get_user_data(db, telegram_id: int) -> dict:
    """Get user data from database."""
    result = await db.fetch_one(
        """SELECT id, notify_reminder, notify_weekly_report, notify_monthly_report, timezone,
                  remind_24h, remind_1h, remind_30m, remind_5m, remind_overdue,
                  reminder_source, notify_task_assigned, notify_task_status
           FROM users WHERE telegram_id = $1""",
        telegram_id
    )
    if result:
        return dict(result)
    return {}


async def update_user_setting(db, telegram_id: int, column: str, value) -> None:
    """Update a single user setting in database with column validation."""
    try:
        validated_column = validate_user_setting_column(column)
    except InvalidColumnError:
        logger.warning(f"Attempted invalid column update: {column}")
        return

    await db.execute(
        f"UPDATE users SET {validated_column} = $1 WHERE telegram_id = $2",
        value, telegram_id
    )


# ============================================
# COMMAND HANDLERS
# ============================================

async def caidat_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle /caidat command - show settings menu."""
    user = update.effective_user
    db = get_db()

    await get_or_create_user(db, user)
    user_data = await get_user_data(db, user.id)

    message = (
        "⚙️ <b>CÀI ĐẶT</b>\n\n"
        "Chọn mục cần thiết lập:"
    )

    await update.message.reply_text(
        message,
        reply_markup=main_menu_keyboard(user_data),
        parse_mode="HTML"
    )

    return SETTINGS_MENU


async def settings_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle settings callback buttons."""
    query = update.callback_query
    await query.answer()

    user = update.effective_user
    db = get_db()
    data = query.data

    parts = data.split(":")
    action = parts[1] if len(parts) > 1 else ""

    # ---- CLOSE ----
    if action == "close":
        await query.edit_message_text("✅ Đã lưu cài đặt.")
        return ConversationHandler.END

    # ---- BACK TO MAIN ----
    if action == "back":
        user_data = await get_user_data(db, user.id)
        await query.edit_message_text(
            "⚙️ <b>CÀI ĐẶT</b>\n\nChọn mục cần thiết lập:",
            reply_markup=main_menu_keyboard(user_data),
            parse_mode="HTML"
        )
        return SETTINGS_MENU

    # ---- NOTIFICATIONS SUBMENU ----
    if action == "notifications":
        user_data = await get_user_data(db, user.id)
        await query.edit_message_text(
            "🔔 <b>THÔNG BÁO</b>\n\n"
            "Cài đặt các loại thông báo:\n\n"
            "<i>🟢 Bật | 🔴 Tắt</i>",
            reply_markup=notifications_menu_keyboard(user_data),
            parse_mode="HTML"
        )
        return SETTINGS_MENU

    # ---- REMINDERS SUBMENU ----
    if action == "reminders":
        user_data = await get_user_data(db, user.id)
        await query.edit_message_text(
            "⏰ <b>NHẮC VIỆC</b>\n\n"
            "Cài đặt nguồn và thời điểm nhắc:\n\n"
            "<i>🟢 Bật | 🔴 Tắt</i>",
            reply_markup=reminders_menu_keyboard(user_data),
            parse_mode="HTML"
        )
        return SETTINGS_MENU

    # ---- TOGGLE SETTINGS ----
    if action == "toggle":
        column = parts[2] if len(parts) > 2 else ""

        valid_columns = [
            "notify_reminder", "notify_weekly_report", "notify_monthly_report",
            "remind_24h", "remind_1h", "remind_30m", "remind_5m", "remind_overdue",
            "notify_task_assigned", "notify_task_status"
        ]
        if column not in valid_columns:
            return SETTINGS_MENU

        user_data = await get_user_data(db, user.id)
        current = user_data.get(column, True)
        new_value = not current

        await update_user_setting(db, user.id, column, new_value)
        user_data[column] = new_value

        status = "🟢 BẬT" if new_value else "🔴 TẮT"
        setting_names = {
            "notify_reminder": "Nhắc việc",
            "notify_weekly_report": "Báo cáo tuần",
            "notify_monthly_report": "Báo cáo tháng",
            "remind_24h": "Nhắc 24h",
            "remind_1h": "Nhắc 1h",
            "remind_30m": "Nhắc 30p",
            "remind_5m": "Nhắc 5p",
            "remind_overdue": "Nhắc quá hạn",
            "notify_task_assigned": "Giao việc mới",
            "notify_task_status": "Trạng thái việc",
        }
        setting_name = setting_names.get(column, column)
        await query.answer(f"{setting_name}: {status}")

        # Determine which menu to return to
        if column.startswith("remind_"):
            # Reminder submenu
            await query.edit_message_text(
                "⏰ <b>NHẮC VIỆC</b>\n\n"
                "Cài đặt nguồn và thời điểm nhắc:\n\n"
                "<i>🟢 Bật | 🔴 Tắt</i>",
                reply_markup=reminders_menu_keyboard(user_data),
                parse_mode="HTML"
            )
        else:
            # Notifications submenu
            await query.edit_message_text(
                "🔔 <b>THÔNG BÁO</b>\n\n"
                "Cài đặt các loại thông báo:\n\n"
                "<i>🟢 Bật | 🔴 Tắt</i>",
                reply_markup=notifications_menu_keyboard(user_data),
                parse_mode="HTML"
            )

        return SETTINGS_MENU

    # ---- EDIT SELECTIONS ----
    if action == "edit":
        edit_type = parts[2] if len(parts) > 2 else ""

        if edit_type == "timezone":
            await query.edit_message_text(
                "🌏 <b>MÚI GIỜ</b>\n\n"
                "Chọn múi giờ của bạn:",
                reply_markup=timezone_keyboard(),
                parse_mode="HTML"
            )
            return SETTINGS_MENU

        if edit_type == "reminder_source":
            user_data = await get_user_data(db, user.id)
            current_source = user_data.get("reminder_source", "both")
            await query.edit_message_text(
                "🔔 <b>NGUỒN NHẮC VIỆC</b>\n\n"
                "Chọn nơi nhận nhắc nhở:",
                reply_markup=reminder_source_keyboard(current_source),
                parse_mode="HTML"
            )
            return SETTINGS_MENU

        return SETTINGS_MENU

    # ---- SET VALUES ----
    if action == "set":
        set_type = parts[2] if len(parts) > 2 else ""
        value = parts[3] if len(parts) > 3 else ""

        if set_type == "timezone" and value:
            valid_timezones = [tz[0] for tz in TIMEZONE_OPTIONS]
            if value not in valid_timezones:
                return SETTINGS_MENU

            await update_user_setting(db, user.id, "timezone", value)
            tz_display = get_tz_display(value)
            await query.answer(f"✅ {tz_display}")

            # Return to main menu
            user_data = await get_user_data(db, user.id)
            await query.edit_message_text(
                "⚙️ <b>CÀI ĐẶT</b>\n\nChọn mục cần thiết lập:",
                reply_markup=main_menu_keyboard(user_data),
                parse_mode="HTML"
            )
            return SETTINGS_MENU

        if set_type == "reminder_source" and value:
            valid_sources = [src[0] for src in REMINDER_SOURCE_OPTIONS]
            if value not in valid_sources:
                return SETTINGS_MENU

            await update_user_setting(db, user.id, "reminder_source", value)
            source_display = get_source_display(value)
            await query.answer(f"✅ {source_display}")

            # Return to reminders menu
            user_data = await get_user_data(db, user.id)
            await query.edit_message_text(
                "⏰ <b>NHẮC VIỆC</b>\n\n"
                "Cài đặt nguồn và thời điểm nhắc:\n\n"
                "<i>🟢 Bật | 🔴 Tắt</i>",
                reply_markup=reminders_menu_keyboard(user_data),
                parse_mode="HTML"
            )
            return SETTINGS_MENU

        return SETTINGS_MENU

    return SETTINGS_MENU


async def settings_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancel settings conversation."""
    await update.message.reply_text("✅ Đã lưu cài đặt.")
    return ConversationHandler.END


def get_handlers():
    """Get settings handlers."""
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("caidat", caidat_command)],
        states={
            SETTINGS_MENU: [
                CallbackQueryHandler(settings_callback, pattern=r"^settings:"),
            ],
        },
        fallbacks=[
            CommandHandler("cancel", settings_cancel),
            CommandHandler("huy", settings_cancel),
        ],
        name="settings_conversation",
        persistent=False,
        per_message=False,
    )

    return [conv_handler]
</file>

<file path="handlers/start.py">
"""
Start Handler
Handles /start, /help, /thongtin, /menu commands
"""

import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CommandHandler, CallbackQueryHandler

from database import get_db
from services import get_or_create_user, get_user_tasks
from utils import MSG_START, MSG_START_GROUP, MSG_HELP, MSG_HELP_GROUP, MSG_INFO, ERR_DATABASE

logger = logging.getLogger(__name__)


def main_menu_keyboard(is_group: bool = False) -> InlineKeyboardMarkup:
    """Create main menu keyboard with feature buttons."""
    buttons = [
        [InlineKeyboardButton("➕ Tạo việc mới", callback_data="menu:taoviec")],
    ]

    # Only show "Giao việc" in group chats
    if is_group:
        buttons.append([InlineKeyboardButton("👥 Giao việc", callback_data="menu:giaoviec")])

    buttons.extend([
        [InlineKeyboardButton("📋 Xem việc của tôi", callback_data="menu:xemviec")],
        [InlineKeyboardButton("🔄 Việc lặp lại", callback_data="menu:vieclaplai")],
        [InlineKeyboardButton("🗑️ Xóa việc", callback_data="menu:xoaviec")],
        [InlineKeyboardButton("📊 Thống kê", callback_data="menu:thongke")],
        [InlineKeyboardButton("📤 Xuất báo cáo", callback_data="menu:export")],
        [InlineKeyboardButton("📅 Google Calendar", callback_data="menu:lichgoogle")],
        [InlineKeyboardButton("⚙️ Cài đặt", callback_data="menu:caidat")],
        [InlineKeyboardButton("❓ Hướng dẫn", callback_data="menu:help")],
    ])

    return InlineKeyboardMarkup(buttons)


async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /start command.
    Register user and show welcome message.
    """
    user = update.effective_user
    if not user:
        return

    try:
        db = get_db()
        # Register/update user
        db_user = await get_or_create_user(db, user)

        # Use different message for private chat vs group
        chat = update.effective_chat
        is_private = chat.type == "private"
        msg = MSG_START if is_private else MSG_START_GROUP

        # Send welcome message
        await update.message.reply_text(
            msg.format(name=db_user.get("display_name", user.first_name))
        )

        logger.info(f"User {user.id} started bot")

    except Exception as e:
        logger.error(f"Error in start_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /help command.
    Show detailed help message (different for private vs group).
    """
    chat = update.effective_chat
    is_private = chat.type == "private"
    msg = MSG_HELP if is_private else MSG_HELP_GROUP
    await update.message.reply_text(msg)


async def info_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /thongtin command.
    Show user account information and statistics.
    """
    user = update.effective_user
    if not user:
        return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)
        user_id = db_user["id"]

        # Get task counts
        all_tasks = await get_user_tasks(db, user_id, include_completed=True)
        in_progress = [t for t in all_tasks if t.get("status") == "in_progress"]
        completed = [t for t in all_tasks if t.get("status") == "completed"]

        # Count overdue (deadline passed, not completed)
        from datetime import datetime
        import pytz
        tz = pytz.timezone("Asia/Ho_Chi_Minh")
        now = datetime.now(tz)

        overdue = []
        for t in all_tasks:
            if t.get("status") != "completed" and t.get("deadline"):
                deadline = t["deadline"]
                if deadline.tzinfo is None:
                    deadline = tz.localize(deadline)
                if deadline < now:
                    overdue.append(t)

        await update.message.reply_text(
            MSG_INFO.format(
                name=db_user.get("display_name", "N/A"),
                username=db_user.get("username") or "Không có",
                telegram_id=user.id,
                total_tasks=len(all_tasks),
                in_progress=len(in_progress),
                completed=len(completed),
                overdue=len(overdue),
                timezone=db_user.get("timezone", "Asia/Ho_Chi_Minh"),
            )
        )

    except Exception as e:
        logger.error(f"Error in info_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


async def menu_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /menu command.
    Show interactive menu with feature buttons.
    """
    user = update.effective_user
    if not user:
        return

    chat = update.effective_chat
    is_group = chat.type in ("group", "supergroup")

    await update.message.reply_text(
        "📱 <b>MENU CHÍNH</b>\n\n"
        "Chọn chức năng bạn muốn sử dụng:",
        reply_markup=main_menu_keyboard(is_group=is_group),
        parse_mode="HTML",
    )


async def menu_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle menu button callbacks."""
    query = update.callback_query
    await query.answer()

    action = query.data.split(":")[1] if ":" in query.data else ""

    if action == "taoviec":
        # Trigger task wizard
        await query.message.reply_text(
            "📝 <b>TẠO VIỆC MỚI</b>\n\n"
            "Nhập nội dung việc cần làm:\n"
            "Ví dụ: <code>Họp đội 14h30</code>\n\n"
            "Hoặc dùng lệnh: /taoviec [nội dung]",
            parse_mode="HTML",
        )

    elif action == "xemviec":
        # Show task category menu
        from utils import task_category_keyboard
        await query.message.reply_text(
            "📋 <b>XEM VIỆC</b>\n\n"
            "Chọn loại việc muốn xem:",
            reply_markup=task_category_keyboard(),
            parse_mode="HTML",
        )

    elif action == "vieclaplai":
        await query.message.reply_text(
            "🔄 <b>VIỆC LẶP LẠI</b>\n\n"
            "• /vieclaplai - Tạo việc lặp lại mới\n"
            "• /danhsachvieclaplai - Xem danh sách việc lặp\n\n"
            "Ví dụ:\n"
            "<code>/vieclaplai Họp đội hàng tuần thứ 2 9h</code>",
            parse_mode="HTML",
        )

    elif action == "xoaviec":
        # Show delete menu
        from handlers.task_delete import delete_menu_keyboard
        await query.message.reply_text(
            "🗑️ <b>XÓA VIỆC</b>\n\n"
            "Chọn loại việc muốn xóa:",
            reply_markup=delete_menu_keyboard(),
            parse_mode="HTML",
        )

    elif action == "thongke":
        await query.message.reply_text(
            "📊 <b>THỐNG KÊ</b>\n\n"
            "• /thongke - Thống kê tổng hợp\n"
            "• /thongketuan - Thống kê tuần này\n"
            "• /thongkethang - Thống kê tháng này\n"
            "• /viectrehan - Xem việc trễ hạn",
            parse_mode="HTML",
        )

    elif action == "export":
        await query.message.reply_text(
            "📤 <b>XUẤT BÁO CÁO</b>\n\n"
            "Dùng lệnh /export để xuất báo cáo.\n\n"
            "Định dạng hỗ trợ: CSV, Excel, PDF",
            parse_mode="HTML",
        )

    elif action == "giaoviec":
        await query.message.reply_text(
            "👥 <b>GIAO VIỆC</b>\n\n"
            "Dùng lệnh /giaoviec để giao việc cho thành viên trong nhóm.\n\n"
            "Cách dùng:\n"
            "<code>/giaoviec @username Nội dung việc</code>\n\n"
            "Ví dụ:\n"
            "<code>/giaoviec @nam Hoàn thành báo cáo 17h</code>",
            parse_mode="HTML",
        )

    elif action == "lichgoogle":
        await query.message.reply_text(
            "📅 <b>GOOGLE CALENDAR</b>\n\n"
            "Dùng lệnh /lichgoogle để kết nối và cài đặt Google Calendar.\n\n"
            "<b>🔗 Kết nối:</b> Đăng nhập Google để đồng bộ lịch\n"
            "<b>⚙️ Chế độ đồng bộ:</b> Tự động hoặc thủ công\n"
            "<b>📤 Đồng bộ ngay:</b> Đồng bộ tất cả việc vào lịch",
            parse_mode="HTML",
        )

    elif action == "caidat":
        await query.message.reply_text(
            "⚙️ <b>CÀI ĐẶT</b>\n\n"
            "Dùng lệnh /caidat để mở menu cài đặt cá nhân.\n\n"
            "<b>🔔 Thông báo:</b> Giao việc mới, trạng thái việc, nhắc việc, báo cáo\n"
            "<b>🌏 Múi giờ:</b> Chọn múi giờ hiển thị",
            parse_mode="HTML",
        )

    elif action == "help":
        chat = update.effective_chat
        is_private = chat.type == "private"
        msg = MSG_HELP if is_private else MSG_HELP_GROUP
        await query.message.reply_text(msg)

    elif action == "back":
        chat = update.effective_chat
        is_group = chat.type in ("group", "supergroup")
        await query.edit_message_text(
            "📱 <b>MENU CHÍNH</b>\n\n"
            "Chọn chức năng bạn muốn sử dụng:",
            reply_markup=main_menu_keyboard(is_group=is_group),
            parse_mode="HTML",
        )


def get_handlers() -> list:
    """Return list of handlers for this module."""
    return [
        CommandHandler("start", start_command),
        CommandHandler("help", help_command),
        CommandHandler("thongtin", info_command),
        CommandHandler("menu", menu_command),
        CallbackQueryHandler(menu_callback, pattern=r"^menu:"),
    ]
</file>

<file path="handlers/statistics.py">
"""
Statistics Handler
Commands for viewing user statistics
"""

import logging

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CommandHandler

from database import get_db
from services import get_or_create_user
from services.statistics_service import (
    calculate_user_stats,
    calculate_all_time_stats,
    get_week_range,
    get_previous_week_range,
    get_month_range,
    get_previous_month_range,
    get_overdue_tasks,
    get_overdue_stats,
)
from utils.formatters import (
    format_stats_overview,
    format_weekly_report,
    format_monthly_report,
)
from utils import ERR_DATABASE

logger = logging.getLogger(__name__)


async def thongke_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /thongke command.
    Show overview statistics.
    """
    user = update.effective_user
    if not user:
        return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        # Get all-time stats
        stats = await calculate_all_time_stats(db, db_user["id"])

        keyboard = InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton("Tuần này", callback_data="stats_weekly"),
                    InlineKeyboardButton("Tháng này", callback_data="stats_monthly"),
                ],
            ]
        )

        text = format_stats_overview(stats, db_user.get("display_name") or user.full_name)
        await update.message.reply_text(text, reply_markup=keyboard)

    except Exception as e:
        logger.error(f"Error in thongke_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


async def thongketuan_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /thongketuan command.
    Show this week's statistics.
    """
    user = update.effective_user
    if not user:
        return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        week_start, week_end = get_week_range()
        stats = await calculate_user_stats(db, db_user["id"], "weekly", week_start, week_end)

        prev_start, prev_end = get_previous_week_range()
        prev_stats = await calculate_user_stats(db, db_user["id"], "weekly", prev_start, prev_end)

        text = format_weekly_report(
            db_user.get("display_name") or user.full_name,
            stats,
            week_start,
            week_end,
            prev_stats=prev_stats,
        )
        await update.message.reply_text(text)

    except Exception as e:
        logger.error(f"Error in thongketuan_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


async def thongkethang_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /thongkethang command.
    Show this month's statistics.
    """
    user = update.effective_user
    if not user:
        return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        month_start, month_end = get_month_range()
        stats = await calculate_user_stats(db, db_user["id"], "monthly", month_start, month_end)

        prev_start, prev_end = get_previous_month_range()
        prev_stats = await calculate_user_stats(db, db_user["id"], "monthly", prev_start, prev_end)

        text = format_monthly_report(
            db_user.get("display_name") or user.full_name,
            stats,
            prev_stats,
            month_start,
            month_end,
        )
        await update.message.reply_text(text)

    except Exception as e:
        logger.error(f"Error in thongkethang_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


async def handle_stats_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle statistics callback queries."""
    query = update.callback_query
    await query.answer()

    user = query.from_user
    data = query.data

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        if data == "stats_weekly":
            week_start, week_end = get_week_range()
            stats = await calculate_user_stats(db, db_user["id"], "weekly", week_start, week_end)

            prev_start, prev_end = get_previous_week_range()
            prev_stats = await calculate_user_stats(db, db_user["id"], "weekly", prev_start, prev_end)

            text = format_weekly_report(
                db_user.get("display_name") or user.full_name,
                stats,
                week_start,
                week_end,
                prev_stats=prev_stats,
            )
            await query.edit_message_text(text)

        elif data == "stats_monthly":
            month_start, month_end = get_month_range()
            stats = await calculate_user_stats(db, db_user["id"], "monthly", month_start, month_end)

            prev_start, prev_end = get_previous_month_range()
            prev_stats = await calculate_user_stats(db, db_user["id"], "monthly", prev_start, prev_end)

            text = format_monthly_report(
                db_user.get("display_name") or user.full_name,
                stats,
                prev_stats,
                month_start,
                month_end,
            )
            await query.edit_message_text(text)

    except Exception as e:
        logger.error(f"Error in stats callback: {e}")
        await query.edit_message_text(ERR_DATABASE)


async def viectrehan_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /viectrehan command.
    Show overdue tasks for current month by default.
    """
    user = update.effective_user
    if not user:
        return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        # Get overdue statistics
        stats = await get_overdue_stats(db, db_user["id"])

        # Get current month name in Vietnamese
        import datetime
        now = datetime.datetime.now()
        month_names = ["", "Tháng 1", "Tháng 2", "Tháng 3", "Tháng 4", "Tháng 5", "Tháng 6",
                       "Tháng 7", "Tháng 8", "Tháng 9", "Tháng 10", "Tháng 11", "Tháng 12"]
        current_month = month_names[now.month]

        # Default: show current month overdue
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton(f"📅 Hôm nay ({stats['today']})", callback_data="overdue_day"),
                InlineKeyboardButton(f"📆 Tuần này ({stats['this_week']})", callback_data="overdue_week"),
            ],
            [
                InlineKeyboardButton(f"📊 Tất cả ({stats['total']})", callback_data="overdue_all"),
            ],
        ])

        text = f"""🔴 VIỆC TRỄ HẠN - {current_month.upper()}

📊 Trễ hạn tháng này: {stats['this_month']} việc

Thống kê chi tiết:
• Hôm nay: {stats['today']} việc
• Tuần này: {stats['this_week']} việc
• Tổng tất cả: {stats['total']} việc

Xem theo khoảng thời gian khác:"""

        # If there are overdue tasks this month, show them directly
        if stats['this_month'] > 0:
            tasks = await get_overdue_tasks(db, db_user["id"], "month")
            from utils.formatters import format_datetime, get_status_icon

            lines = []
            for task in tasks[:10]:  # Show first 10
                icon = get_status_icon(task)
                deadline_str = format_datetime(task.get("deadline"), relative=True)
                content = task.get("content", "")[:35]
                if len(task.get("content", "")) > 35:
                    content += "..."
                lines.append(f"{icon} {task['public_id']}: {content}\n   📅 {deadline_str}")

            task_list = "\n\n".join(lines)
            shown = min(10, stats['this_month'])

            text = f"""🔴 VIỆC TRỄ HẠN - {current_month.upper()}

Tổng: {stats['this_month']} việc trễ hạn{f' (hiện {shown} đầu tiên)' if stats["this_month"] > 10 else ''}

{task_list}

Xem chi tiết: /xemviec [mã việc]
Hoàn thành: /xong [mã việc]

📊 Xem thêm:"""

        await update.message.reply_text(text, reply_markup=keyboard)

    except Exception as e:
        logger.error(f"Error in viectrehan_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


async def handle_overdue_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle overdue task list callback queries."""
    query = update.callback_query
    await query.answer()

    user = query.from_user
    data = query.data

    # Get current month name
    import datetime
    now = datetime.datetime.now()
    month_names = ["", "Tháng 1", "Tháng 2", "Tháng 3", "Tháng 4", "Tháng 5", "Tháng 6",
                   "Tháng 7", "Tháng 8", "Tháng 9", "Tháng 10", "Tháng 11", "Tháng 12"]

    period_map = {
        "overdue_day": ("day", "HÔM NAY"),
        "overdue_week": ("week", "TUẦN NÀY"),
        "overdue_month": ("month", month_names[now.month].upper()),
        "overdue_all": ("all", "TẤT CẢ THỜI GIAN"),
    }

    if data not in period_map:
        return

    period, period_label = period_map[data]

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        tasks = await get_overdue_tasks(db, db_user["id"], period)

        if not tasks:
            await query.edit_message_text(
                f"🔴 VIỆC TRỄ HẠN - {period_label}\n\n"
                "✅ Không có việc trễ hạn trong khoảng thời gian này!"
            )
            return

        # Format task list
        from utils.formatters import format_datetime, get_status_icon

        lines = []
        for task in tasks[:20]:  # Limit to 20 tasks
            icon = get_status_icon(task)
            deadline_str = format_datetime(task.get("deadline"), relative=True)
            content = task.get("content", "")[:40]
            if len(task.get("content", "")) > 40:
                content += "..."
            lines.append(f"{icon} {task['public_id']}: {content}\n   📅 {deadline_str}")

        task_list = "\n\n".join(lines)
        total = len(tasks)
        shown = min(20, total)

        text = f"""🔴 VIỆC TRỄ HẠN - {period_label}

Tổng: {total} việc{f' (hiện {shown} đầu tiên)' if total > 20 else ''}

{task_list}

Xem chi tiết: /xemviec [mã việc]
Hoàn thành: /xong [mã việc]"""

        await query.edit_message_text(text)

    except Exception as e:
        logger.error(f"Error in overdue callback: {e}")
        await query.edit_message_text(ERR_DATABASE)


def get_handlers() -> list:
    """Return list of handlers for this module."""
    return [
        CommandHandler("thongke", thongke_command),
        CommandHandler("thongketuan", thongketuan_command),
        CommandHandler("thongkethang", thongkethang_command),
        CommandHandler(["viectrehan", "trehan"], viectrehan_command),
    ]
</file>

<file path="handlers/task_assign.py">
"""
Task Assign Handler
Handles /giaoviec command for assigning tasks to others
Supports multi-assignee with G-ID/P-ID system
"""

import re
import logging
from typing import List, Dict, Any
from telegram import Update
from telegram.ext import ContextTypes, CommandHandler

from database import get_db
from services import (
    get_or_create_user,
    get_or_create_group,
    add_group_member,
    get_user_by_username,
    find_users_by_mention,
    create_task,
    create_group_task,
    get_user_created_tasks,
    parse_vietnamese_time,
)
from utils import (
    MSG_TASK_ASSIGNED,
    MSG_TASK_RECEIVED,
    ERR_NO_CONTENT,
    ERR_NO_ASSIGNEE,
    ERR_USER_NOT_FOUND,
    ERR_GROUP_ONLY,
    ERR_DATABASE,
    extract_mentions,
    validate_task_content,
    parse_task_command,
    format_datetime,
    format_priority,
    task_actions_keyboard,
    mention_user,
)

logger = logging.getLogger(__name__)

# Messages with mention support (Markdown format)
MSG_TASK_ASSIGNED_MD = """✅ *Đã giao việc thành công!*

📋 *{task_id}*: {content}
👤 Giao cho: {assignee}
📅 Deadline: {deadline}

Xem chi tiết: /xemviec {task_id}"""

MSG_TASK_RECEIVED_MD = """📬 *Bạn có việc mới!*

📋 *{task_id}*: {content}
👤 Từ: {creator}
📅 Deadline: {deadline}

Trả lời /xong {task_id} khi hoàn thành."""

MSG_GROUP_TASK_CREATED_MD = """✅ *Đã tạo việc nhóm thành công!*

📋 *{task_id}*: {content}
👥 Người nhận: {assignees}
📅 Deadline: {deadline}

Theo dõi tiến độ: /xemviec {task_id}"""

MSG_GROUP_TASK_RECEIVED_MD = """📬 *Bạn có việc nhóm mới!*

📋 *{task_id}*: {content}
👤 Từ: {creator}
📅 Deadline: {deadline}
👥 Thành viên: {total_members} người

🔖 Việc của bạn: *{personal_id}*
Trả lời /xong {personal_id} khi hoàn thành."""


async def giaoviec_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /giaoviec command.
    Assign task to one or multiple users.

    Format: /giaoviec @user1 [@user2 ...] [content] [time]
    Examples:
        /giaoviec @nam Chuan bi slide 10h ngay mai
        /giaoviec @nam @linh @hoa Review code truoc 17h

    Can also reply to a message to assign to that user.
    """
    user = update.effective_user
    chat = update.effective_chat
    message = update.message

    if not user or not chat or not message:
        return

    # Get text after command
    text = " ".join(context.args) if context.args else ""

    # Check if this is a group or private chat
    is_group = chat.type in ["group", "supergroup"]

    try:
        db = get_db()

        # Register/get creator
        db_user = await get_or_create_user(db, user)
        creator_id = db_user["id"]

        # Handle group context
        group_id = None
        if is_group:
            group = await get_or_create_group(db, chat.id, chat.title or "Unknown")
            group_id = group["id"]
            await add_group_member(db, group_id, creator_id, "member")

        # Find assignees
        assignees: List[Dict[str, Any]] = []
        remaining_text = text

        # Method 1: Reply to message (single assignee)
        # Skip if replying to own message (creator should not auto-assign to self)
        if message.reply_to_message and message.reply_to_message.from_user:
            assignee_tg_user = message.reply_to_message.from_user
            # Only add if NOT the creator (avoid auto-assigning to self)
            if assignee_tg_user.id != user.id:
                assignee = await get_or_create_user(db, assignee_tg_user)
                if is_group:
                    await add_group_member(db, group_id, assignee["id"], "member")
                assignees.append(assignee)

        # Method 2: Process message entities for mentions
        # - text_mention: for users without username (has user_id in entity)
        # - mention: for @username mentions (username is in message text)
        mention_ranges = []
        if message.entities:
            full_text = message.text or ""
            for entity in message.entities:
                # Text mention - user clicked on name (most reliable, has user_id)
                if entity.type == "text_mention" and entity.user:
                    mentioned_user = await get_or_create_user(db, entity.user)
                    if not any(a["id"] == mentioned_user["id"] for a in assignees):
                        assignees.append(mentioned_user)
                        if is_group:
                            await add_group_member(db, group_id, mentioned_user["id"], "member")
                    mention_ranges.append((entity.offset, entity.offset + entity.length))
                    logger.info(f"Found text_mention: {entity.user.first_name} (id={entity.user.id})")

                # @mention - username mention
                elif entity.type == "mention":
                    # Extract username from message text (includes @)
                    username_with_at = full_text[entity.offset:entity.offset + entity.length]
                    username = username_with_at.lstrip("@")
                    found_user = await get_user_by_username(db, username)
                    if found_user:
                        if not any(a["id"] == found_user["id"] for a in assignees):
                            assignees.append(found_user)
                            if is_group:
                                await add_group_member(db, group_id, found_user["id"], "member")
                        mention_ranges.append((entity.offset, entity.offset + entity.length))
                        logger.info(f"Found @mention entity: @{username} (id={found_user['id']})")
                    else:
                        logger.warning(f"User @{username} not found in database")

        # Remove mentions from remaining text
        if mention_ranges:
            # Work with full message text, then extract content
            full_text = message.text or ""
            # Sort by offset descending to remove from end first
            for start, end in sorted(mention_ranges, reverse=True):
                full_text = full_text[:start] + full_text[end:]
            # Remove command and clean up
            remaining_text = re.sub(r"^/\w+\s*", "", full_text).strip()
            remaining_text = re.sub(r"\s+", " ", remaining_text)

        # Method 3: @mentions in text (supports multiple)
        # Also process @mentions even if text_mentions were found
        if remaining_text:
            mentions, remaining_text = extract_mentions(remaining_text)
            if mentions:
                not_found = []
                for username in mentions:
                    found_user = await get_user_by_username(db, username)
                    if found_user:
                        # Avoid duplicates
                        if not any(a["id"] == found_user["id"] for a in assignees):
                            assignees.append(found_user)
                            if is_group:
                                await add_group_member(db, group_id, found_user["id"], "member")
                            logger.info(f"Found @mention: @{username} (id={found_user['id']})")
                    else:
                        not_found.append(username)

                # Report users not found
                if not_found and not assignees:
                    await message.reply_text(
                        ERR_USER_NOT_FOUND.format(user=f"@{not_found[0]}")
                        + "\n\nNgười này chưa dùng bot. Họ cần /start bot trước."
                    )
                    return
                elif not_found:
                    logger.warning(f"Some users not found: {not_found}")

        if not assignees:
            await message.reply_text(
                ERR_NO_ASSIGNEE + "\n\nVí dụ:\n/giaoviec @user Nội dung việc\n/giaoviec @user1 @user2 Việc nhóm"
            )
            return

        # Parse remaining text
        if not remaining_text.strip():
            await message.reply_text(
                ERR_NO_CONTENT + "\n\nVí dụ: /giaoviec @username Nội dung việc 14h"
            )
            return

        parsed = parse_task_command(remaining_text.strip())

        # Extract time
        deadline, remaining = parse_vietnamese_time(parsed["content"])
        content = remaining.strip() if remaining else parsed["content"]

        # Validate content
        is_valid, result = validate_task_content(content)
        if not is_valid:
            await message.reply_text(result)
            return
        content = result

        # Format deadline for messages
        deadline_str = format_datetime(deadline, relative=True) if deadline else "Không có"

        # Single assignee: regular task (T-ID)
        if len(assignees) == 1:
            assignee = assignees[0]
            task = await create_task(
                db=db,
                content=content,
                creator_id=creator_id,
                assignee_id=assignee["id"],
                deadline=deadline,
                priority=parsed["priority"],
                is_personal=False,
                group_id=group_id,
            )

            # Send confirmation to creator with mention
            assignee_mention = mention_user(assignee)
            await message.reply_text(
                MSG_TASK_ASSIGNED_MD.format(
                    task_id=task["public_id"],
                    content=content,
                    assignee=assignee_mention,
                    deadline=deadline_str,
                ),
                parse_mode="Markdown",
            )

            # Notify assignee with mention (check notification preferences)
            try:
                if assignee.get("telegram_id") != user.id:
                    # Check if user wants to receive notifications
                    assignee_prefs = await db.fetch_one(
                        "SELECT notify_all, notify_task_assigned FROM users WHERE id = $1",
                        assignee["id"]
                    )
                    should_notify = (
                        assignee_prefs
                        and assignee_prefs.get("notify_all", True)
                        and assignee_prefs.get("notify_task_assigned", True)
                    )
                    if should_notify:
                        creator_mention = mention_user(db_user)
                        await context.bot.send_message(
                            chat_id=assignee["telegram_id"],
                            text=MSG_TASK_RECEIVED_MD.format(
                                task_id=task["public_id"],
                                content=content,
                                creator=creator_mention,
                                deadline=deadline_str,
                            ),
                            parse_mode="Markdown",
                            reply_markup=task_actions_keyboard(task["public_id"]),
                        )
            except Exception as e:
                logger.warning(f"Could not notify assignee {assignee['telegram_id']}: {e}")

            logger.info(
                f"User {user.id} assigned task {task['public_id']} to {assignee['telegram_id']}"
            )

        # Multiple assignees: group task (G-ID + P-IDs)
        else:
            group_task, child_tasks = await create_group_task(
                db=db,
                content=content,
                creator_id=creator_id,
                assignees=assignees,
                deadline=deadline,
                priority=parsed["priority"],
                group_id=group_id,
            )

            # Format assignee mentions
            assignee_mentions = ", ".join(mention_user(a) for a in assignees)

            # Send confirmation to creator with mentions
            await message.reply_text(
                MSG_GROUP_TASK_CREATED_MD.format(
                    task_id=group_task["public_id"],
                    content=content,
                    assignees=assignee_mentions,
                    deadline=deadline_str,
                ),
                parse_mode="Markdown",
            )

            # Notify each assignee with their personal P-ID (check notification preferences)
            creator_mention = mention_user(db_user)
            for i, assignee in enumerate(assignees):
                try:
                    if assignee.get("telegram_id") != user.id:
                        # Check if user wants to receive notifications
                        assignee_prefs = await db.fetch_one(
                            "SELECT notify_all, notify_task_assigned FROM users WHERE id = $1",
                            assignee["id"]
                        )
                        should_notify = (
                            assignee_prefs
                            and assignee_prefs.get("notify_all", True)
                            and assignee_prefs.get("notify_task_assigned", True)
                        )
                        if should_notify:
                            # child_tasks[i] is tuple of (task_dict, assignee_dict)
                            child_task, _ = child_tasks[i]
                            await context.bot.send_message(
                                chat_id=assignee["telegram_id"],
                                text=MSG_GROUP_TASK_RECEIVED_MD.format(
                                    task_id=group_task["public_id"],
                                    content=content,
                                    creator=creator_mention,
                                    deadline=deadline_str,
                                    total_members=len(assignees),
                                    personal_id=child_task["public_id"],
                                ),
                                parse_mode="Markdown",
                                reply_markup=task_actions_keyboard(child_task["public_id"]),
                            )
                except Exception as e:
                    logger.warning(f"Could not notify assignee {assignee['telegram_id']}: {e}")

            logger.info(
                f"User {user.id} created group task {group_task['public_id']} for {len(assignees)} assignees"
            )

    except Exception as e:
        logger.error(f"Error in giaoviec_command: {e}")
        await message.reply_text(ERR_DATABASE)


async def viecdagiao_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /viecdagiao command.
    List tasks created by user and assigned to others.
    """
    user = update.effective_user
    if not user:
        return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)
        user_id = db_user["id"]

        # Get tasks assigned to others
        tasks = await get_user_created_tasks(db, user_id, limit=10)

        if not tasks:
            await update.message.reply_text(
                "Bạn chưa giao việc cho ai.\n\nGiao việc:\n/giaoviec @user Nội dung\n/giaoviec @user1 @user2 Việc nhóm"
            )
            return

        # Format task list
        from utils import format_task_list, task_list_with_pagination

        total = len(tasks)
        total_pages = (total + 9) // 10

        msg = format_task_list(
            tasks=tasks,
            title="VIỆC BẠN ĐÃ GIAO",
            page=1,
            total=total,
        )

        await update.message.reply_text(
            msg,
            reply_markup=task_list_with_pagination(tasks, 1, total_pages, "assigned"),
        )

    except Exception as e:
        logger.error(f"Error in viecdagiao_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


def get_handlers() -> list:
    """Return list of handlers for this module."""
    # Note: /giaoviec is now handled by task_wizard.py (wizard mode)
    # The wizard calls giaoviec_command when args are provided
    return [
        # /viecdagiao and /viectoigiao - Tasks you assigned to others
        CommandHandler(["viecdagiao", "viectoigiao"], viecdagiao_command),
    ]
</file>

<file path="handlers/task_create.py">
"""
Task Create Handler
Handles /taoviec command for personal task creation
"""

import logging
from telegram import Update
from telegram.ext import ContextTypes, CommandHandler

from database import get_db
from services import (
    get_or_create_user,
    create_task,
    parse_vietnamese_time,
)
from utils import (
    MSG_TASK_CREATED,
    ERR_NO_CONTENT,
    ERR_INVALID_TIME,
    ERR_DATABASE,
    validate_task_content,
    parse_task_command,
    format_datetime,
    format_priority,
    task_actions_keyboard,
)

logger = logging.getLogger(__name__)


async def taoviec_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /taoviec command.
    Create personal task for the user.

    Format: /taoviec [content] [time]
    Examples:
        /taoviec Hop doi 14h30
        /taoviec Nop bao cao ngay mai 10h
        /taoviec Mua qua sinh nhat 15/12
    """
    user = update.effective_user
    if not user:
        return

    # Get text after command
    text = " ".join(context.args) if context.args else ""

    if not text:
        await update.message.reply_text(
            ERR_NO_CONTENT + "\n\nVí dụ: /taoviec Họp đội 14h30"
        )
        return

    try:
        db = get_db()

        # Register/get user
        db_user = await get_or_create_user(db, user)
        user_id = db_user["id"]

        # Parse command
        parsed = parse_task_command(text)

        # Extract time from content
        deadline, remaining = parse_vietnamese_time(parsed["content"])

        # Validate content
        content = remaining.strip() if remaining else parsed["content"]
        is_valid, result = validate_task_content(content)

        if not is_valid:
            await update.message.reply_text(result)
            return

        content = result

        # Create task
        task = await create_task(
            db=db,
            content=content,
            creator_id=user_id,
            assignee_id=user_id,  # Personal task: assign to self
            deadline=deadline,
            priority=parsed["priority"],
            is_personal=True,
        )

        # Format response
        deadline_str = format_datetime(deadline, relative=True) if deadline else "Không có"
        priority_str = format_priority(parsed["priority"])

        await update.message.reply_text(
            MSG_TASK_CREATED.format(
                task_id=task["public_id"],
                content=content,
                deadline=deadline_str,
                priority=priority_str,
            ),
            reply_markup=task_actions_keyboard(task["public_id"]),
        )

        logger.info(f"User {user.id} created task {task['public_id']}: {content[:30]}")

    except Exception as e:
        logger.error(f"Error in taoviec_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


async def vieccanhan_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /vieccanhan command.
    List personal tasks for the user.
    """
    user = update.effective_user
    if not user:
        return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)
        user_id = db_user["id"]

        # Get user's tasks
        from services import get_user_tasks
        tasks = await get_user_tasks(db, user_id, limit=10)

        if not tasks:
            await update.message.reply_text(
                "Bạn chưa có việc nào.\n\nTạo việc mới: /taoviec [nội dung]"
            )
            return

        # Format task list
        from utils import format_task_list, task_list_with_pagination

        total = len(tasks)
        total_pages = (total + 9) // 10

        msg = format_task_list(
            tasks=tasks,
            title="VIỆC CÁ NHÂN CỦA BẠN",
            page=1,
            total=total,
        )

        await update.message.reply_text(
            msg,
            reply_markup=task_list_with_pagination(tasks, 1, total_pages, "personal"),
        )

    except Exception as e:
        logger.error(f"Error in vieccanhan_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


def get_handlers() -> list:
    """Return list of handlers for this module."""
    # Note: /taoviec is now handled by task_wizard.py
    return [
        CommandHandler("vieccanhan", vieccanhan_command),
    ]
</file>

<file path="handlers/task_delete.py">
"""
Task Delete Handler
Commands for deleting tasks with undo support
"""

import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CommandHandler, CallbackQueryHandler, ConversationHandler

from database import get_db
from services import (
    get_or_create_user,
    get_task_by_public_id,
    soft_delete_task,
    restore_task,
    get_tasks_created_by_user,
    get_tasks_assigned_to_others,
    bulk_delete_tasks,
    bulk_soft_delete_with_undo,
    bulk_restore_tasks,
)
from utils import (
    MSG_TASK_DELETED,
    MSG_TASK_RESTORED,
    ERR_TASK_NOT_FOUND,
    ERR_NO_PERMISSION,
    ERR_DATABASE,
    undo_keyboard,
    bulk_undo_keyboard,
    confirm_keyboard,
    bulk_delete_confirm_keyboard,
    format_datetime,
    format_status,
)

logger = logging.getLogger(__name__)


# =============================================================================
# Delete Menu Keyboards
# =============================================================================

def delete_menu_keyboard() -> InlineKeyboardMarkup:
    """Main delete menu - choose category."""
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("📤 Việc đã giao cho người khác", callback_data="delete_menu:assigned")],
        [InlineKeyboardButton("📋 Việc tự tạo cho bản thân", callback_data="delete_menu:personal")],
        [InlineKeyboardButton("❌ Đóng", callback_data="delete_menu:close")],
    ])


def delete_task_list_keyboard(tasks: list, category: str) -> InlineKeyboardMarkup:
    """Task list for deletion - each task on separate row."""
    buttons = []

    for task in tasks[:10]:  # Max 10 tasks
        content = task["content"][:25] + "..." if len(task["content"]) > 25 else task["content"]
        public_id = task["public_id"]
        buttons.append([
            InlineKeyboardButton(
                f"🗑️ {public_id}: {content}",
                callback_data=f"delete_task:{public_id}"
            )
        ])

    if len(tasks) > 10:
        buttons.append([
            InlineKeyboardButton(f"... còn {len(tasks) - 10} việc khác", callback_data="noop")
        ])

    # Add bulk delete and back buttons
    if tasks:
        buttons.append([
            InlineKeyboardButton(f"🗑️ XÓA TẤT CẢ ({len(tasks)} việc)", callback_data=f"delete_all:{category}")
        ])

    buttons.append([InlineKeyboardButton("« Quay lại", callback_data="delete_menu:back")])

    return InlineKeyboardMarkup(buttons)


def delete_confirm_keyboard(task_id: str) -> InlineKeyboardMarkup:
    """Confirm deletion of single task."""
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("✅ Xác nhận xóa", callback_data=f"delete_confirm:{task_id}")],
        [InlineKeyboardButton("❌ Hủy", callback_data="delete_menu:back_to_list")],
    ])


def delete_all_confirm_keyboard(category: str, count: int) -> InlineKeyboardMarkup:
    """Confirm bulk deletion."""
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(f"✅ Xác nhận xóa {count} việc", callback_data=f"delete_all_confirm:{category}")],
        [InlineKeyboardButton("❌ Hủy", callback_data=f"delete_menu:{category}")],
    ])


# =============================================================================
# Command Handlers
# =============================================================================

async def xoa_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /xoa or /xoaviec command.
    Without args: show delete menu
    With task_id: delete specific task
    """
    user = update.effective_user
    if not user:
        return

    # If task ID provided, delete directly
    if context.args:
        task_id = context.args[0].upper()
        await delete_specific_task(update, context, task_id)
        return

    # Show delete menu
    await update.message.reply_text(
        "🗑️ <b>XÓA VIỆC</b>\n\n"
        "Chọn loại việc muốn xóa:",
        reply_markup=delete_menu_keyboard(),
        parse_mode="HTML",
    )


async def delete_specific_task(update: Update, context: ContextTypes.DEFAULT_TYPE, task_id: str) -> None:
    """Delete a specific task by ID."""
    user = update.effective_user

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)
        task = await get_task_by_public_id(db, task_id)

        if not task:
            await update.message.reply_text(ERR_TASK_NOT_FOUND.format(task_id=task_id))
            return

        # Only creator can delete
        if task["creator_id"] != db_user["id"]:
            await update.message.reply_text(ERR_NO_PERMISSION)
            return

        # Show task details for review
        status = format_status(task["status"])
        deadline_str = format_datetime(task.get("deadline"), relative=True) if task.get("deadline") else "Không có"
        assignee_name = task.get("assignee_name", "Chưa giao")

        await update.message.reply_text(
            f"⚠️ <b>XÁC NHẬN XÓA VIỆC?</b>\n\n"
            f"📋 <b>{task_id}</b>: {task['content']}\n"
            f"📊 <b>Trạng thái:</b> {status}\n"
            f"👤 <b>Người nhận:</b> {assignee_name}\n"
            f"📅 <b>Deadline:</b> {deadline_str}",
            reply_markup=delete_confirm_keyboard(task_id),
            parse_mode="HTML",
        )

    except Exception as e:
        logger.error(f"Error in delete_specific_task: {e}")
        await update.message.reply_text(ERR_DATABASE)


# =============================================================================
# Callback Handlers
# =============================================================================

async def delete_menu_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle delete menu callbacks."""
    query = update.callback_query
    await query.answer()

    user = update.effective_user
    data = query.data
    action = data.split(":")[1] if ":" in data else ""

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        if action == "close":
            await query.edit_message_text("Đã đóng menu xóa việc.")
            return

        if action == "back":
            await query.edit_message_text(
                "🗑️ <b>XÓA VIỆC</b>\n\n"
                "Chọn loại việc muốn xóa:",
                reply_markup=delete_menu_keyboard(),
                parse_mode="HTML",
            )
            return

        if action == "assigned":
            # Show tasks assigned to others
            tasks = await get_tasks_assigned_to_others(db, db_user["id"])
            context.user_data["delete_category"] = "assigned"
            context.user_data["delete_tasks"] = tasks

            if not tasks:
                await query.edit_message_text(
                    "📤 <b>Việc đã giao cho người khác</b>\n\n"
                    "Bạn chưa giao việc cho ai.",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("« Quay lại", callback_data="delete_menu:back")]
                    ]),
                    parse_mode="HTML",
                )
                return

            await query.edit_message_text(
                f"📤 <b>Việc đã giao cho người khác</b>\n\n"
                f"Bạn có {len(tasks)} việc đã giao.\n"
                f"Chọn việc để xóa:",
                reply_markup=delete_task_list_keyboard(tasks, "assigned"),
                parse_mode="HTML",
            )
            return

        if action == "personal":
            # Show personal tasks (created for self)
            all_tasks = await get_tasks_created_by_user(db, db_user["id"], include_assigned_to_others=False)
            # Filter only tasks where creator == assignee
            tasks = [t for t in all_tasks if t.get("assignee_id") == db_user["id"]]
            context.user_data["delete_category"] = "personal"
            context.user_data["delete_tasks"] = tasks

            if not tasks:
                await query.edit_message_text(
                    "📋 <b>Việc tự tạo cho bản thân</b>\n\n"
                    "Bạn chưa có việc cá nhân nào.",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("« Quay lại", callback_data="delete_menu:back")]
                    ]),
                    parse_mode="HTML",
                )
                return

            await query.edit_message_text(
                f"📋 <b>Việc tự tạo cho bản thân</b>\n\n"
                f"Bạn có {len(tasks)} việc cá nhân.\n"
                f"Chọn việc để xóa:",
                reply_markup=delete_task_list_keyboard(tasks, "personal"),
                parse_mode="HTML",
            )
            return

        if action == "back_to_list":
            # Return to task list
            category = context.user_data.get("delete_category", "personal")
            tasks = context.user_data.get("delete_tasks", [])

            category_name = "Việc đã giao cho người khác" if category == "assigned" else "Việc tự tạo cho bản thân"
            icon = "📤" if category == "assigned" else "📋"

            await query.edit_message_text(
                f"{icon} <b>{category_name}</b>\n\n"
                f"Bạn có {len(tasks)} việc.\n"
                f"Chọn việc để xóa:",
                reply_markup=delete_task_list_keyboard(tasks, category),
                parse_mode="HTML",
            )
            return

    except Exception as e:
        logger.error(f"Error in delete_menu_callback: {e}")
        await query.edit_message_text(ERR_DATABASE)


async def delete_task_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle individual task deletion callback."""
    query = update.callback_query
    await query.answer()

    user = update.effective_user
    task_id = query.data.split(":")[1] if ":" in query.data else ""

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)
        task = await get_task_by_public_id(db, task_id)

        if not task:
            await query.edit_message_text(ERR_TASK_NOT_FOUND.format(task_id=task_id))
            return

        # Store for later
        context.user_data["delete_task_id"] = task_id

        # Show confirmation
        status = format_status(task["status"])
        deadline_str = format_datetime(task.get("deadline"), relative=True) if task.get("deadline") else "Không có"
        assignee_name = task.get("assignee_name", "Chưa giao")

        await query.edit_message_text(
            f"⚠️ <b>XÁC NHẬN XÓA VIỆC?</b>\n\n"
            f"📋 <b>{task_id}</b>: {task['content']}\n"
            f"📊 <b>Trạng thái:</b> {status}\n"
            f"👤 <b>Người nhận:</b> {assignee_name}\n"
            f"📅 <b>Deadline:</b> {deadline_str}",
            reply_markup=delete_confirm_keyboard(task_id),
            parse_mode="HTML",
        )

    except Exception as e:
        logger.error(f"Error in delete_task_callback: {e}")
        await query.edit_message_text(ERR_DATABASE)


async def delete_confirm_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle deletion confirmation with 10s countdown."""
    query = update.callback_query
    await query.answer()

    user = update.effective_user
    task_id = query.data.split(":")[1] if ":" in query.data else ""

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        success, result = await process_delete(db, task_id, db_user["id"], context.bot)

        if success:
            undo_id = result
            await query.edit_message_text(
                f"✅ Đã xóa việc {task_id}.\n\n"
                f"Bấm nút bên dưới để hoàn tác:",
                reply_markup=undo_keyboard(undo_id, 10),
            )

            # Schedule countdown updates
            chat_id = query.message.chat_id
            message_id = query.message.message_id

            # Get job_queue from application
            job_queue = context.application.job_queue

            if job_queue:

                # Schedule countdown updates every second (9s -> 1s)
                for seconds in range(9, 0, -1):
                    job_queue.run_once(
                        _countdown_update_job,
                        when=10 - seconds,
                        data={
                            "chat_id": chat_id,
                            "message_id": message_id,
                            "task_id": task_id,
                            "undo_id": undo_id,
                            "seconds": seconds,
                        },
                        name=f"undo_countdown_{undo_id}_{seconds}",
                    )

                # Schedule final expiry at 10 seconds
                job_queue.run_once(
                    _countdown_expired_job,
                    when=10,
                    data={
                        "chat_id": chat_id,
                        "message_id": message_id,
                        "task_id": task_id,
                        "undo_id": undo_id,
                    },
                    name=f"undo_expired_{undo_id}",
                )
        else:
            await query.edit_message_text(f"❌ {result}")

    except Exception as e:
        logger.error(f"Error in delete_confirm_callback: {e}")
        await query.edit_message_text(ERR_DATABASE)


async def _countdown_update_job(context) -> None:
    """Job to update undo button countdown."""
    job_data = context.job.data
    chat_id = job_data["chat_id"]
    message_id = job_data["message_id"]
    task_id = job_data["task_id"]
    undo_id = job_data["undo_id"]
    seconds = job_data["seconds"]

    try:
        # Check if undo was already performed
        db = get_db()
        undo_record = await db.fetch_one(
            "SELECT is_restored FROM deleted_tasks_undo WHERE id = $1",
            undo_id
        )
        if not undo_record or undo_record["is_restored"]:
            return  # Undo already performed, skip update

        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=message_id,
            text=f"✅ Đã xóa việc {task_id}.\n\n"
                 f"Bấm nút bên dưới để hoàn tác:",
            reply_markup=undo_keyboard(undo_id, seconds),
        )
    except Exception as e:
        logger.debug(f"Could not update countdown: {e}")


async def _countdown_expired_job(context) -> None:
    """Job to handle undo expiry."""
    job_data = context.job.data
    chat_id = job_data["chat_id"]
    message_id = job_data["message_id"]
    task_id = job_data["task_id"]
    undo_id = job_data["undo_id"]

    try:
        # Check if undo was already performed
        db = get_db()
        undo_record = await db.fetch_one(
            "SELECT is_restored FROM deleted_tasks_undo WHERE id = $1",
            undo_id
        )
        if not undo_record or undo_record["is_restored"]:
            return  # Undo already performed, skip expiry message

        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=message_id,
            text=f"🗑️ Đã xóa việc {task_id}!\n\n"
                 f"⏰ Đã hết thời gian hoàn tác.",
        )
    except Exception as e:
        logger.debug(f"Could not update expired message: {e}")


async def _bulk_countdown_update_job(context) -> None:
    """Job to update bulk undo button countdown."""
    job_data = context.job.data
    chat_id = job_data["chat_id"]
    message_id = job_data["message_id"]
    count = job_data["count"]
    undo_id = job_data["undo_id"]
    seconds = job_data["seconds"]

    try:
        # Check if undo was already performed
        db = get_db()
        undo_record = await db.fetch_one(
            "SELECT is_restored FROM deleted_tasks_undo WHERE id = $1",
            undo_id
        )
        if not undo_record or undo_record["is_restored"]:
            return  # Undo already performed, skip update

        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=message_id,
            text=f"✅ Đã xóa <b>{count}</b> việc.\n\n"
                 f"Bấm nút bên dưới để hoàn tác:",
            reply_markup=bulk_undo_keyboard(undo_id, count, seconds),
            parse_mode="HTML",
        )
    except Exception as e:
        logger.debug(f"Could not update bulk countdown: {e}")


async def _bulk_countdown_expired_job(context) -> None:
    """Job to handle bulk undo expiry."""
    job_data = context.job.data
    chat_id = job_data["chat_id"]
    message_id = job_data["message_id"]
    count = job_data["count"]
    undo_id = job_data["undo_id"]

    try:
        # Check if undo was already performed
        db = get_db()
        undo_record = await db.fetch_one(
            "SELECT is_restored FROM deleted_tasks_undo WHERE id = $1",
            undo_id
        )
        if not undo_record or undo_record["is_restored"]:
            return  # Undo already performed, skip expiry message

        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=message_id,
            text=f"🗑️ Đã xóa <b>{count}</b> việc!\n\n"
                 f"⏰ Đã hết thời gian hoàn tác.",
            parse_mode="HTML",
        )
    except Exception as e:
        logger.debug(f"Could not update bulk expired message: {e}")


async def bulk_undo_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle bulk undo button click."""
    query = update.callback_query
    await query.answer()

    undo_id_str = query.data.split(":")[1] if ":" in query.data else ""

    try:
        undo_id = int(undo_id_str)
    except ValueError:
        await query.edit_message_text("❌ Lỗi: ID không hợp lệ.")
        return

    try:
        db = get_db()
        restored_count = await bulk_restore_tasks(db, undo_id)

        if restored_count > 0:
            # Cancel any scheduled jobs for this undo
            job_queue = context.application.job_queue
            if job_queue:
                current_jobs = job_queue.jobs()
                for job in current_jobs:
                    if job.name and f"bulk_undo_{undo_id}" in job.name:
                        job.schedule_removal()

            await query.edit_message_text(
                f"↩️ Đã hoàn tác xóa <b>{restored_count}</b> việc!",
                parse_mode="HTML",
            )
        else:
            await query.edit_message_text(
                "❌ Không thể hoàn tác. Đã hết thời gian (10 giây).",
            )

    except Exception as e:
        logger.error(f"Error in bulk_undo_callback: {e}")
        await query.edit_message_text("❌ Lỗi khi hoàn tác. Vui lòng thử lại.")


async def delete_all_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle bulk delete request."""
    query = update.callback_query
    await query.answer()

    category = query.data.split(":")[1] if ":" in query.data else ""
    tasks = context.user_data.get("delete_tasks", [])

    if not tasks:
        await query.edit_message_text("Không có việc nào để xóa.")
        return

    # Build preview
    preview_lines = []
    for t in tasks[:5]:
        content_short = t["content"][:25] + "..." if len(t["content"]) > 25 else t["content"]
        preview_lines.append(f"• {t['public_id']}: {content_short}")

    if len(tasks) > 5:
        preview_lines.append(f"... và {len(tasks) - 5} việc khác")

    preview = "\n".join(preview_lines)

    category_name = "việc đã giao" if category == "assigned" else "việc cá nhân"

    await query.edit_message_text(
        f"⚠️ <b>XÁC NHẬN XÓA TẤT CẢ?</b>\n\n"
        f"Bạn sắp xóa <b>{len(tasks)}</b> {category_name}:\n\n"
        f"{preview}\n\n"
        f"⚠️ <b>Hành động này không thể hoàn tác!</b>",
        reply_markup=delete_all_confirm_keyboard(category, len(tasks)),
        parse_mode="HTML",
    )


async def delete_all_confirm_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle bulk delete confirmation with 10s countdown."""
    query = update.callback_query
    await query.answer()

    user = update.effective_user
    tasks = context.user_data.get("delete_tasks", [])

    if not tasks:
        await query.edit_message_text("Không có việc nào để xóa.")
        return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        task_ids = [t["id"] for t in tasks]
        count = len(task_ids)

        # Use bulk delete with undo support
        undo_id = await bulk_soft_delete_with_undo(db, task_ids, db_user["id"])

        if not undo_id:
            await query.edit_message_text("Không thể xóa việc. Vui lòng thử lại.")
            return

        # Clear stored data
        context.user_data.pop("delete_tasks", None)
        context.user_data.pop("delete_category", None)

        await query.edit_message_text(
            f"✅ Đã xóa <b>{count}</b> việc.\n\n"
            f"Bấm nút bên dưới để hoàn tác:",
            reply_markup=bulk_undo_keyboard(undo_id, count, 10),
            parse_mode="HTML",
        )

        # Schedule countdown updates
        chat_id = query.message.chat_id
        message_id = query.message.message_id

        job_queue = context.application.job_queue

        if job_queue:
            # Schedule countdown updates every second (9s -> 1s)
            for seconds in range(9, 0, -1):
                job_queue.run_once(
                    _bulk_countdown_update_job,
                    when=10 - seconds,
                    data={
                        "chat_id": chat_id,
                        "message_id": message_id,
                        "count": count,
                        "undo_id": undo_id,
                        "seconds": seconds,
                    },
                    name=f"bulk_undo_countdown_{undo_id}_{seconds}",
                )

            # Schedule final expiry at 10 seconds
            job_queue.run_once(
                _bulk_countdown_expired_job,
                when=10,
                data={
                    "chat_id": chat_id,
                    "message_id": message_id,
                    "count": count,
                    "undo_id": undo_id,
                },
                name=f"bulk_undo_expired_{undo_id}",
            )

    except Exception as e:
        logger.error(f"Error in delete_all_confirm_callback: {e}")
        await query.edit_message_text(ERR_DATABASE)


# =============================================================================
# Legacy Functions (kept for compatibility)
# =============================================================================

async def process_delete(
    db,
    task_id: str,
    user_id: int,
    bot,
) -> tuple:
    """
    Process task deletion.
    Returns (success, undo_id or error_message).
    """
    task = await get_task_by_public_id(db, task_id)

    if not task:
        return False, ERR_TASK_NOT_FOUND.format(task_id=task_id)

    # Soft delete
    undo = await soft_delete_task(db, task["id"], user_id)

    if not undo:
        return False, "Lỗi khi xóa việc."

    # Notify assignee if different from creator
    if task["assignee_id"] != task["creator_id"]:
        try:
            assignee = await db.fetch_one(
                "SELECT telegram_id FROM users WHERE id = $1",
                task["assignee_id"]
            )
            if assignee:
                await bot.send_message(
                    chat_id=assignee["telegram_id"],
                    text=f"Việc {task_id} đã bị xóa bởi người tạo.\n\n"
                         f"Nội dung: {task['content'][:50]}...",
                )
        except Exception as e:
            logger.warning(f"Could not notify assignee: {e}")

    return True, undo["id"]


async def process_restore(db, undo_id: int) -> tuple:
    """
    Process task restoration.
    Returns (success, task or error_message).
    """
    task = await restore_task(db, undo_id)

    if not task:
        return False, "Không thể hoàn tác. Đã hết thời gian (10 giây)."

    return True, task


# Legacy bulk delete commands (kept for backwards compatibility)
async def xoahet_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle /xoahet - redirects to delete menu."""
    await xoa_command(update, context)


async def xoaviecdagiao_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle /xoaviecdagiao - redirects to delete menu."""
    await xoa_command(update, context)


def get_handlers() -> list:
    """Return list of handlers for this module."""
    return [
        CommandHandler(["xoa", "xoaviec"], xoa_command),
        CommandHandler("xoahet", xoahet_command),
        CommandHandler("xoaviecdagiao", xoaviecdagiao_command),
        CallbackQueryHandler(delete_menu_callback, pattern=r"^delete_menu:"),
        CallbackQueryHandler(delete_task_callback, pattern=r"^delete_task:"),
        CallbackQueryHandler(delete_confirm_callback, pattern=r"^delete_confirm:"),
        CallbackQueryHandler(delete_all_callback, pattern=r"^delete_all:(?!confirm)"),
        CallbackQueryHandler(delete_all_confirm_callback, pattern=r"^delete_all_confirm:"),
        CallbackQueryHandler(bulk_undo_callback, pattern=r"^bulk_undo:"),
    ]
</file>

<file path="handlers/task_update.py">
"""
Task Update Handler
Commands for updating task status and progress
Supports G-ID/P-ID group task auto-completion
"""

import logging
from telegram import Update
from telegram.ext import ContextTypes, CommandHandler

from database import get_db
from services import (
    get_or_create_user,
    get_task_by_public_id,
    get_task_by_id,
    update_task_status,
    update_task_progress,
    check_and_complete_group_task,
    get_group_task_progress,
)
from utils import (
    MSG_TASK_COMPLETED,
    ERR_TASK_NOT_FOUND,
    ERR_NO_PERMISSION,
    ERR_ALREADY_COMPLETED,
    ERR_DATABASE,
    format_datetime,
    progress_keyboard,
    mention_user,
)

logger = logging.getLogger(__name__)


async def xong_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /xong [task_id] or /hoanthanh [task_id] command.
    Mark task as completed.
    Auto-completes parent G-ID when all P-ID children are done.
    """
    user = update.effective_user
    if not user:
        return

    if not context.args:
        await update.message.reply_text(
            "Vui lòng nhập mã việc.\n\nVí dụ: /xong P-0001"
        )
        return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        # Support multiple task IDs: /xong P-0001, P-0002
        task_ids = [t.strip().upper() for t in " ".join(context.args).split(",")]
        results = []
        group_completions = []

        for task_id in task_ids:
            task = await get_task_by_public_id(db, task_id)

            if not task:
                results.append(f"{task_id}: Không tồn tại")
                continue

            # Check permission (assignee or creator can mark complete)
            if task["assignee_id"] != db_user["id"] and task["creator_id"] != db_user["id"]:
                results.append(f"{task_id}: Không có quyền")
                continue

            if task["status"] == "completed":
                results.append(f"{task_id}: Đã hoàn thành rồi")
                continue

            # Update status
            updated = await update_task_status(
                db, task["id"], "completed", db_user["id"]
            )

            results.append(f"{task_id}: Hoàn thành!")

            # Notify creator/assigner if this is NOT a group task child
            # (Group task children are handled separately below)
            if not task.get("parent_task_id"):
                from services.notification import send_task_completed_to_assigner
                await send_task_completed_to_assigner(
                    context.bot, db, updated or task, db_user
                )

            # Check if this is a P-ID and handle group progress
            if task_id.startswith("P-") and task.get("group_task_id"):
                group_task_id = task["group_task_id"]

                # Check for auto-complete
                group_result = await check_and_complete_group_task(
                    db, task["id"], db_user["id"]
                )

                if group_result:
                    # Group completed - all members done
                    group_completions.append(group_result)
                    try:
                        if group_result["creator_id"] != db_user["id"]:
                            creator = await db.fetch_one(
                                "SELECT telegram_id FROM users WHERE id = $1",
                                group_result["creator_id"]
                            )
                            if creator:
                                progress_info = await get_group_task_progress(db, group_task_id)
                                user_mention = mention_user(db_user)
                                await context.bot.send_message(
                                    chat_id=creator["telegram_id"],
                                    text=f"🎉 *VIỆC NHÓM ĐÃ HOÀN THÀNH\\!*\n\n"
                                         f"📋 *{group_result['public_id']}*: {group_result['content']}\n\n"
                                         f"✅ Tất cả {progress_info['total']}/{progress_info['total']} thành viên đã hoàn thành\\!\n"
                                         f"👤 Người hoàn thành cuối: {user_mention}",
                                    parse_mode="Markdown",
                                )
                    except Exception as e:
                        logger.warning(f"Could not notify group completion: {e}")
                else:
                    # Group not yet complete - notify progress
                    try:
                        progress_info = await get_group_task_progress(db, group_task_id)
                        parent_task = await get_task_by_public_id(db, group_task_id)

                        if parent_task and parent_task["creator_id"] != db_user["id"]:
                            creator = await db.fetch_one(
                                "SELECT telegram_id FROM users WHERE id = $1",
                                parent_task["creator_id"]
                            )
                            if creator:
                                user_mention = mention_user(db_user)
                                await context.bot.send_message(
                                    chat_id=creator["telegram_id"],
                                    text=f"📊 *CẬP NHẬT TIẾN ĐỘ VIỆC NHÓM*\n\n"
                                         f"📋 *{group_task_id}*: {parent_task['content']}\n\n"
                                         f"✅ {progress_info['completed']}/{progress_info['total']} người đã hoàn thành\\!\n"
                                         f"👤 Vừa hoàn thành: {user_mention}",
                                    parse_mode="Markdown",
                                )
                    except Exception as e:
                        logger.warning(f"Could not notify group progress: {e}")

        # Response
        if len(task_ids) == 1 and results[0].endswith("Hoàn thành!"):
            msg = MSG_TASK_COMPLETED.format(
                task_id=task_ids[0],
                content=task["content"],
                completed_at=format_datetime(updated.get("completed_at")),
            )

            # Add group completion info
            if group_completions:
                g = group_completions[0]
                msg += f"\n\nViệc nhóm {g['public_id']} đã hoàn thành!"

            await update.message.reply_text(msg)
        else:
            response = "\n".join(results)
            if group_completions:
                response += "\n\nViệc nhóm hoàn thành:\n"
                for g in group_completions:
                    response += f"  {g['public_id']}: {g['content'][:30]}..."
            await update.message.reply_text(response)

    except Exception as e:
        logger.error(f"Error in xong_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


async def danglam_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /danglam [task_id] command.
    Mark task as in progress.
    """
    user = update.effective_user
    if not user:
        return

    if not context.args:
        await update.message.reply_text(
            "Vui lòng nhập mã việc.\n\nVí dụ: /danglam P-0001"
        )
        return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        task_ids = [t.strip().upper() for t in " ".join(context.args).split(",")]
        updated_count = 0

        for task_id in task_ids:
            task = await get_task_by_public_id(db, task_id)

            if not task:
                continue

            # Only assignee can update status
            if task["assignee_id"] != db_user["id"]:
                continue

            await update_task_status(db, task["id"], "in_progress", db_user["id"])
            updated_count += 1

        if updated_count > 0:
            await update.message.reply_text(
                f"Đã cập nhật {updated_count} việc sang 'Đang làm'"
            )
        else:
            await update.message.reply_text("Không cập nhật được việc nào.")

    except Exception as e:
        logger.error(f"Error in danglam_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


async def tiendo_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /tiendo [task_id] [%] command.
    Update task progress percentage.
    """
    user = update.effective_user
    if not user:
        return

    if len(context.args) < 1:
        await update.message.reply_text(
            "Cú pháp: /tiendo [mã việc] [%]\n\n"
            "Ví dụ:\n"
            "  /tiendo P-0001 50\n"
            "  /tiendo P-0001 75%"
        )
        return

    task_id = context.args[0].upper()

    # Parse progress if provided
    progress = None
    if len(context.args) >= 2:
        try:
            progress = int(context.args[1].replace("%", ""))
            progress = max(0, min(100, progress))
        except ValueError:
            await update.message.reply_text("Phần trăm phải là số (0-100)")
            return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        task = await get_task_by_public_id(db, task_id)

        if not task:
            await update.message.reply_text(ERR_TASK_NOT_FOUND.format(task_id=task_id))
            return

        # Only assignee can update progress
        if task["assignee_id"] != db_user["id"]:
            await update.message.reply_text(ERR_NO_PERMISSION)
            return

        if progress is not None:
            # Update progress
            updated = await update_task_progress(
                db, task["id"], progress, db_user["id"]
            )

            # Format response with progress bar
            bar = progress_bar(progress)
            status_text = "Hoàn thành!" if progress == 100 else "Đang làm"

            msg = f"Cập nhật tiến độ {task_id}!\n\n{bar} {progress}%\nTrạng thái: {status_text}"

            # Check for group task auto-completion
            group_completed = None
            if progress == 100 and task_id.startswith("P-"):
                group_completed = await check_and_complete_group_task(
                    db, task["id"], db_user["id"]
                )
                if group_completed:
                    msg += f"\n\nViệc nhóm {group_completed['public_id']} đã hoàn thành!"

            await update.message.reply_text(msg)

            # Notify group completion
            if group_completed and group_completed["creator_id"] != db_user["id"]:
                try:
                    creator = await db.fetch_one(
                        "SELECT telegram_id FROM users WHERE id = $1",
                        group_completed["creator_id"]
                    )
                    if creator:
                        await context.bot.send_message(
                            chat_id=creator["telegram_id"],
                            text=f"VIỆC NHÓM ĐÃ HOÀN THÀNH!\n\n"
                                 f"{group_completed['public_id']}: {group_completed['content']}",
                        )
                except Exception as e:
                    logger.warning(f"Could not notify group completion: {e}")
        else:
            # Show progress selection keyboard
            current = task.get("progress", 0)
            await update.message.reply_text(
                f"Chọn tiến độ mới cho {task_id}:\n\n"
                f"Hiện tại: {progress_bar(current)} {current}%",
                reply_markup=progress_keyboard(task_id),
            )

    except Exception as e:
        logger.error(f"Error in tiendo_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


async def tiendogrouptask_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /tiendoviecnhom [G-ID] command.
    View aggregated progress for a group task.
    """
    user = update.effective_user
    if not user:
        return

    if not context.args:
        await update.message.reply_text(
            "Vui lòng nhập mã việc nhóm.\n\nVí dụ: /tiendoviecnhom G-0001"
        )
        return

    task_id = context.args[0].upper()

    if not task_id.startswith("G-"):
        await update.message.reply_text("Mã việc nhóm phải bắt đầu bằng G-")
        return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        task = await get_task_by_public_id(db, task_id)
        if not task:
            await update.message.reply_text(ERR_TASK_NOT_FOUND.format(task_id=task_id))
            return

        # Get aggregated progress
        progress_info = await get_group_task_progress(db, task_id)

        pct = progress_info.get("progress", 0)
        bar = progress_bar(pct)

        # Build member list
        member_lines = []
        for member in progress_info.get("members", []):
            icon = "✅" if member["status"] == "completed" else "⏳"
            member_lines.append(f"  {icon} {member['name']}: {member['progress']}%")

        members_text = "\n".join(member_lines) if member_lines else "  Không có thành viên"

        msg = f"""
TIẾN ĐỘ VIỆC NHÓM: {task_id}

📋 {task['content']}

📊 TỔNG QUAN:
{bar} {pct}%
Hoàn thành: {progress_info['completed']}/{progress_info['total']}

👥 CHI TIẾT:
{members_text}
""".strip()

        await update.message.reply_text(msg)

    except Exception as e:
        logger.error(f"Error in tiendogrouptask_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


def progress_bar(percent: int, width: int = 10) -> str:
    """Generate visual progress bar."""
    filled = int(width * percent / 100)
    empty = width - filled
    return "█" * filled + "░" * empty


def get_handlers() -> list:
    """Return list of handlers for this module."""
    return [
        CommandHandler(["xong", "hoanthanh", "done"], xong_command),
        CommandHandler("danglam", danglam_command),
        CommandHandler("tiendo", tiendo_command),
        CommandHandler("tiendoviecnhom", tiendogrouptask_command),
    ]
</file>

<file path="handlers/task_view.py">
"""
Task View Handler
Commands for viewing and searching tasks
Supports G-ID group task viewing with aggregated progress
"""

import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes, CommandHandler

from database import get_db
from services import (
    get_or_create_user,
    get_task_by_public_id,
    get_user_tasks,
    get_group_tasks,
    get_tasks_with_deadline,
    is_group_task,
    get_group_task_progress,
    get_child_tasks,
    get_user_received_tasks,
    get_all_user_related_tasks,
)
from utils import (
    ERR_TASK_NOT_FOUND,
    ERR_GROUP_ONLY,
    ERR_DATABASE,
    format_task_detail,
    format_task_list,
    task_detail_keyboard,
    task_category_keyboard,
    task_list_with_pagination,
    format_datetime,
    format_status,
    get_status_icon,
    mention_user,
)

logger = logging.getLogger(__name__)


def format_group_task_detail(task: dict, progress_info: dict, child_tasks: list) -> str:
    """Format group task (G-ID) detail with aggregated progress (Markdown format)."""
    status_icon = get_status_icon(task)  # Pass full dict, not just status string

    # Build member progress list with mention tags
    member_lines = []
    for child in child_tasks:
        child_icon = get_status_icon(child)  # Pass full dict
        # Create mention link for assignee
        assignee_mention = mention_user({
            "display_name": child.get("assignee_name", "N/A"),
            "telegram_id": child.get("telegram_id"),
        })
        member_lines.append(f"  {child_icon} {child['public_id']}: {assignee_mention}")

    members_text = "\n".join(member_lines) if member_lines else "  Không có thành viên"

    # Progress bar
    pct = progress_info.get("progress", 0)
    filled = int(pct / 10)
    bar = "█" * filled + "░" * (10 - filled)

    deadline_str = format_datetime(task.get("deadline"), relative=True) if task.get("deadline") else "Không có"
    created_str = format_datetime(task.get("created_at"), relative=True) if task.get("created_at") else "N/A"

    return f"""
{status_icon} VIỆC NHÓM: {task['public_id']}

📋 {task['content']}

📊 TIẾN ĐỘ NHÓM:
[{bar}] {pct}%
Hoàn thành: {progress_info['completed']}/{progress_info['total']}

👥 THÀNH VIÊN:
{members_text}

📅 Deadline: {deadline_str}
🕐 Tạo: {created_str}

Xem chi tiết từng việc: /xemviec [P-ID]
""".strip()


def group_task_keyboard(task_id: str, can_edit: bool = False) -> InlineKeyboardMarkup:
    """Keyboard for group task detail."""
    buttons = []

    if can_edit:
        buttons.append([
            InlineKeyboardButton("✏️ Sửa", callback_data=f"task_edit:{task_id}"),
            InlineKeyboardButton("🗑️ Xóa", callback_data=f"task_delete:{task_id}"),
        ])

    buttons.append([
        InlineKeyboardButton("🔄 Làm mới", callback_data=f"task_detail:{task_id}"),
        InlineKeyboardButton("« Quay lại", callback_data="task_category:menu"),
    ])

    return InlineKeyboardMarkup(buttons)


async def xemviec_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /xemviec or /vic [task_id] command.
    View task detail by ID or list all tasks.
    Supports G-ID group tasks with aggregated progress.
    """
    user = update.effective_user
    if not user:
        return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        # Check if task ID provided
        if context.args:
            task_id = context.args[0].upper()
            task = await get_task_by_public_id(db, task_id)

            if not task:
                await update.message.reply_text(ERR_TASK_NOT_FOUND.format(task_id=task_id))
                return

            # Check if this is a group task (G-ID)
            if await is_group_task(db, task_id):
                # Get aggregated progress
                progress_info = await get_group_task_progress(db, task_id)
                child_tasks = await get_child_tasks(db, task_id)

                can_edit = task["creator_id"] == db_user["id"]

                msg = format_group_task_detail(task, progress_info, child_tasks)
                keyboard = group_task_keyboard(task_id, can_edit=can_edit)

                await update.message.reply_text(msg, reply_markup=keyboard, parse_mode="Markdown")
            else:
                # Regular task (T-ID or P-ID)
                can_edit = task["creator_id"] == db_user["id"]
                can_complete = task["assignee_id"] == db_user["id"]

                msg = format_task_detail(task)

                # Add parent task reference for P-ID tasks
                if task_id.startswith("P-") and task.get("parent_task_id"):
                    parent = await db.fetch_one(
                        "SELECT public_id FROM tasks WHERE id = $1",
                        task["parent_task_id"]
                    )
                    if parent:
                        msg += f"\n\n👥 Thuộc việc nhóm: {parent['public_id']}"

                keyboard = task_detail_keyboard(
                    task_id,
                    can_edit=can_edit,
                    can_complete=can_complete and task["status"] != "completed",
                )

                await update.message.reply_text(msg, reply_markup=keyboard, parse_mode="HTML")
        else:
            # Show task category menu
            await update.message.reply_text(
                "📋 CHỌN DANH MỤC VIỆC\n\n"
                "📋 Việc cá nhân - Việc bạn tự tạo cho mình\n"
                "📤 Việc đã giao - Việc bạn giao cho người khác\n"
                "📥 Việc đã nhận - Việc người khác giao cho bạn\n"
                "📊 Tất cả việc - Toàn bộ việc liên quan",
                reply_markup=task_category_keyboard(),
            )

    except Exception as e:
        logger.error(f"Error in xemviec_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


async def viecnhom_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /viecnhom command.
    View all tasks in current group.
    """
    user = update.effective_user
    chat = update.effective_chat

    if not user or not chat:
        return

    # Check if in group
    if chat.type == "private":
        await update.message.reply_text(ERR_GROUP_ONLY)
        return

    try:
        db = get_db()

        # Get group
        group = await db.fetch_one(
            "SELECT id FROM groups WHERE telegram_id = $1",
            chat.id
        )

        if not group:
            await update.message.reply_text("Nhóm chưa có việc nào.")
            return

        tasks = await get_group_tasks(db, group["id"], limit=20)

        if not tasks:
            await update.message.reply_text(
                f"Nhóm {chat.title} chưa có việc nào.\n\nGiao việc: /giaoviec @username [nội dung]"
            )
            return

        total = len(tasks)
        total_pages = (total + 9) // 10

        msg = format_task_list(
            tasks=tasks,
            title=f"VIỆC TRONG NHÓM {chat.title}",
            page=1,
            total=total,
        )

        await update.message.reply_text(
            msg,
            reply_markup=task_list_with_pagination(tasks, 1, total_pages, "group"),
        )

    except Exception as e:
        logger.error(f"Error in viecnhom_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


async def timviec_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /timviec [keyword] command.
    Search tasks by keyword.
    """
    user = update.effective_user
    if not user:
        return

    query = " ".join(context.args) if context.args else ""

    if not query:
        await update.message.reply_text("Nhập từ khoá: /timviec [từ khoá]")
        return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        # Search in user's tasks
        tasks = await db.fetch_all(
            """
            SELECT t.*, u.display_name as assignee_name, c.display_name as creator_name
            FROM tasks t
            LEFT JOIN users u ON t.assignee_id = u.id
            LEFT JOIN users c ON t.creator_id = c.id
            WHERE (t.assignee_id = $1 OR t.creator_id = $1)
            AND t.is_deleted = false
            AND (
                LOWER(t.content) LIKE LOWER($2)
                OR LOWER(t.description) LIKE LOWER($2)
                OR t.public_id ILIKE $2
            )
            ORDER BY t.created_at DESC
            LIMIT 20
            """,
            db_user["id"],
            f"%{query}%",
        )

        if not tasks:
            await update.message.reply_text(f"Không tìm thấy việc với từ khoá: {query}")
            return

        tasks = [dict(t) for t in tasks]
        msg = format_task_list(
            tasks=tasks,
            title=f"KẾT QUẢ TÌM KIẾM: {query}",
            page=1,
            total=len(tasks),
        )

        await update.message.reply_text(msg)

    except Exception as e:
        logger.error(f"Error in timviec_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


async def viecdanhan_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /viecdanhan or /viectoinhan command.
    List tasks assigned TO the user BY others.
    """
    user = update.effective_user
    if not user:
        return

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)
        user_id = db_user["id"]

        # Get tasks assigned to user by others
        tasks = await get_user_received_tasks(db, user_id, limit=20)

        if not tasks:
            await update.message.reply_text(
                "Bạn chưa được giao việc nào.\n\nXem tất cả việc: /xemviec"
            )
            return

        total = len(tasks)
        total_pages = (total + 9) // 10

        msg = format_task_list(
            tasks=tasks,
            title="VIỆC ĐƯỢC GIAO CHO BẠN",
            page=1,
            total=total,
        )

        await update.message.reply_text(
            msg,
            reply_markup=task_list_with_pagination(tasks, 1, total_pages, "received"),
        )

    except Exception as e:
        logger.error(f"Error in viecdanhan_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


async def deadline_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """
    Handle /deadline [hours] command.
    Show tasks with deadline within specified hours.
    """
    user = update.effective_user
    if not user:
        return

    # Parse hours (default 24)
    hours = 24
    if context.args:
        try:
            arg = context.args[0].lower().replace("h", "")
            hours = int(arg)
        except ValueError:
            pass

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)

        tasks = await get_tasks_with_deadline(db, hours, db_user["id"])

        if not tasks:
            await update.message.reply_text(f"Không có việc nào trong {hours} giờ tới.")
            return

        msg = format_task_list(
            tasks=tasks,
            title=f"VIỆC TRONG {hours} GIỜ TỚI",
            page=1,
            total=len(tasks),
        )

        await update.message.reply_text(msg)

    except Exception as e:
        logger.error(f"Error in deadline_command: {e}")
        await update.message.reply_text(ERR_DATABASE)


def get_handlers() -> list:
    """Return list of handlers for this module."""
    return [
        # /xemviec - View ALL related tasks (created, received, assigned)
        CommandHandler(["xemviec", "vic"], xemviec_command),
        # /viecdanhan, /viectoinhan - Tasks assigned TO you BY others
        CommandHandler(["viecdanhan", "viectoinhan"], viecdanhan_command),
        CommandHandler(["viecnhom", "viecduan"], viecnhom_command),
        CommandHandler("timviec", timviec_command),
        CommandHandler("deadline", deadline_command),
    ]
</file>

<file path="handlers/task_wizard.py">
"""
Task Wizard Handler
Step-by-step task creation with ConversationHandler
"""

import warnings
warnings.filterwarnings("ignore", message=".*per_message.*", category=UserWarning)

import logging
from datetime import datetime, timedelta
import pytz
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ContextTypes,
    CommandHandler,
    CallbackQueryHandler,
    ConversationHandler,
    MessageHandler,
    filters,
)

from database import get_db
from services import (
    get_or_create_user,
    get_user_by_id,
    get_user_by_username,
    create_task,
    create_group_task,
    parse_vietnamese_time,
)
from handlers.calendar import sync_task_to_calendar
from utils import (
    ERR_DATABASE,
    MSG_TASK_CREATED,
    validate_task_content,
    extract_mentions,
    format_datetime,
    format_priority,
    mention_user,
    task_actions_keyboard,
    wizard_deadline_keyboard,
    wizard_assignee_keyboard,
    wizard_priority_keyboard,
    wizard_confirm_keyboard,
    wizard_cancel_keyboard,
)

logger = logging.getLogger(__name__)

# Conversation states
CONTENT, DEADLINE, DEADLINE_CUSTOM, ASSIGNEE, ASSIGNEE_INPUT, PRIORITY, CONFIRM = range(7)

# Priority mapping
PRIORITY_MAP = {
    "urgent": "urgent",
    "high": "high",
    "normal": "normal",
    "low": "low",
}

PRIORITY_LABELS = {
    "urgent": "Khẩn cấp",
    "high": "Cao",
    "normal": "Bình thường",
    "low": "Thấp",
}


def get_wizard_data(context: ContextTypes.DEFAULT_TYPE) -> dict:
    """Get wizard data from user_data."""
    if "wizard" not in context.user_data:
        context.user_data["wizard"] = {}
    return context.user_data["wizard"]


def clear_wizard_data(context: ContextTypes.DEFAULT_TYPE) -> None:
    """Clear wizard data from user_data."""
    if "wizard" in context.user_data:
        del context.user_data["wizard"]


async def send_private_notification(
    context: ContextTypes.DEFAULT_TYPE,
    telegram_id: int,
    message: str,
    parse_mode: str = "Markdown",
    reply_markup=None,
) -> bool:
    """
    Send private DM notification to a user.

    Args:
        context: Telegram context
        telegram_id: User's Telegram ID
        message: Message text
        parse_mode: Message parse mode
        reply_markup: Optional inline keyboard

    Returns:
        True if sent successfully, False otherwise
    """
    try:
        await context.bot.send_message(
            chat_id=telegram_id,
            text=message,
            parse_mode=parse_mode,
            reply_markup=reply_markup,
        )
        return True
    except Exception as e:
        logger.warning(f"Could not send private notification to {telegram_id}: {e}")
        return False


def format_wizard_summary(data: dict) -> str:
    """Format wizard data summary for confirmation."""
    content = data.get("content", "N/A")
    deadline = data.get("deadline")
    deadline_str = format_datetime(deadline, relative=True) if deadline else "Không có"
    assignee_name = data.get("assignee_name", "Bản thân")
    priority = data.get("priority", "normal")
    priority_str = format_priority(priority)

    return f"""
<b>TẠO VIỆC MỚI</b>

<b>Nội dung:</b> {content}

<b>Deadline:</b> {deadline_str}
<b>Người nhận:</b> {assignee_name}
<b>Độ ưu tiên:</b> {priority_str}

Xác nhận tạo việc?
""".strip()


# =============================================================================
# Entry Point
# =============================================================================


async def wizard_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Start task creation wizard or direct creation if args provided."""
    user = update.effective_user
    if not user:
        return ConversationHandler.END

    # Check if args provided -> direct creation (legacy mode)
    if context.args:
        await direct_task_creation(update, context)
        return ConversationHandler.END

    # Initialize wizard data
    clear_wizard_data(context)
    data = get_wizard_data(context)
    data["creator_id"] = None  # Will be set when accessing DB

    # Check if group chat - need REPLY instruction
    chat = update.effective_chat
    is_group = chat and chat.type in ["group", "supergroup"]

    reply_hint = "\n\n⚠️ REPLY tin nhắn này khi nhập (vuốt phải)" if is_group else ""

    await update.message.reply_text(
        f"TẠO VIỆC TỪNG BƯỚC\n\n"
        f"Bước 1/5: Nhập nội dung việc\n\n"
        f"Nhập nội dung việc cần làm:{reply_hint}",
        reply_markup=wizard_cancel_keyboard(),
    )

    return CONTENT


async def direct_task_creation(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle direct task creation with args (legacy /taoviec flow)."""
    user = update.effective_user
    text = " ".join(context.args)

    try:
        db = get_db()
        db_user = await get_or_create_user(db, user)
        user_id = db_user["id"]

        # Parse time from content
        deadline, remaining = parse_vietnamese_time(text)
        content = remaining.strip() if remaining else text

        # Validate content
        is_valid, result = validate_task_content(content)
        if not is_valid:
            await update.message.reply_text(result)
            return

        content = result

        # Create task
        task = await create_task(
            db=db,
            content=content,
            creator_id=user_id,
            assignee_id=user_id,
            deadline=deadline,
            priority="normal",
            is_personal=True,
        )

        deadline_str = format_datetime(deadline, relative=True) if deadline else "Không có"
        priority_str = format_priority("normal")

        await update.message.reply_text(
            MSG_TASK_CREATED.format(
                task_id=task["public_id"],
                content=content,
                deadline=deadline_str,
                priority=priority_str,
            ),
            reply_markup=task_actions_keyboard(task["public_id"], show_complete=False),
        )

        logger.info(f"Direct: User {user.id} created task {task['public_id']}")

    except Exception as e:
        logger.error(f"Error in direct_task_creation: {e}")
        await update.message.reply_text(ERR_DATABASE)


# =============================================================================
# Step 1: Content
# =============================================================================


async def receive_content(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Receive task content."""
    text = update.message.text.strip()

    if text.lower() in ["/huy", "/cancel"]:
        clear_wizard_data(context)
        await update.message.reply_text("Đã hủy tạo việc.")
        return ConversationHandler.END

    # Validate content
    is_valid, result = validate_task_content(text)
    if not is_valid:
        await update.message.reply_text(
            f"{result}\n\nVui lòng nhập lại nội dung:",
            reply_markup=wizard_cancel_keyboard(),
        )
        return CONTENT

    # Save content
    data = get_wizard_data(context)
    data["content"] = result

    await update.message.reply_text(
        "Bước 2/5: Chọn deadline\n\n"
        "Chọn thời hạn hoàn thành hoặc nhập thời gian:",
        reply_markup=wizard_deadline_keyboard(),
    )

    return DEADLINE


# =============================================================================
# Step 2: Deadline
# =============================================================================


async def deadline_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle deadline button selection."""
    query = update.callback_query
    await query.answer()

    data = get_wizard_data(context)
    action = query.data.split(":")[1] if ":" in query.data else ""

    # Use timezone-aware datetime
    tz = pytz.timezone("Asia/Ho_Chi_Minh")
    now = datetime.now(tz)

    if action == "today":
        # End of today (23:59)
        data["deadline"] = now.replace(hour=23, minute=59, second=0, microsecond=0)
    elif action == "tomorrow":
        # End of tomorrow (23:59)
        data["deadline"] = (now + timedelta(days=1)).replace(hour=23, minute=59, second=0, microsecond=0)
    elif action == "nextweek":
        # 7 days from now
        data["deadline"] = (now + timedelta(days=7)).replace(hour=23, minute=59, second=0, microsecond=0)
    elif action == "nextmonth":
        # 30 days from now
        data["deadline"] = (now + timedelta(days=30)).replace(hour=23, minute=59, second=0, microsecond=0)
    elif action == "skip":
        data["deadline"] = None
    elif action == "custom":
        # Check if group chat
        chat = update.effective_chat
        is_group = chat and chat.type in ["group", "supergroup"]
        reply_hint = "\n\n⚠️ REPLY tin nhắn này khi nhập" if is_group else ""

        await query.edit_message_text(
            f"Nhập thời gian deadline:\n\n"
            f"Ví dụ:\n"
            f"• `14h30` - hôm nay 14:30\n"
            f"• `ngày mai 10h` - ngày mai 10:00\n"
            f"• `thứ 6 15h` - thứ 6 tuần này 15:00\n"
            f"• `20/12 9h` - ngày 20/12{reply_hint}\n\n"
            f"Hoặc /huy để hủy",
            parse_mode="Markdown",
        )
        return DEADLINE_CUSTOM

    # Move to assignee step
    deadline_str = format_datetime(data.get("deadline"), relative=True) if data.get("deadline") else "Không có"

    # Get recent users for suggestions
    try:
        db = get_db()
        user = update.effective_user
        db_user = await get_or_create_user(db, user)
        data["creator_id"] = db_user["id"]

        # Get recent task assignees
        recent = await db.fetch_all(
            """
            SELECT DISTINCT u.id, u.display_name, u.username
            FROM users u
            JOIN tasks t ON t.assignee_id = u.id
            WHERE t.creator_id = $1 AND u.id != $1
            ORDER BY t.created_at DESC
            LIMIT 3
            """,
            db_user["id"],
        )
        recent_users = [dict(r) for r in recent] if recent else None
    except Exception:
        recent_users = None

    # Check if private chat
    is_private = update.effective_chat.type == "private"

    await query.edit_message_text(
        f"Deadline: {deadline_str}\n\n"
        "Bước 3/5: Chọn người nhận\n\n"
        "Giao việc cho ai?",
        reply_markup=wizard_assignee_keyboard(recent_users, is_private_chat=is_private),
    )

    return ASSIGNEE


async def receive_deadline_custom(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Receive custom deadline input."""
    text = update.message.text.strip()

    if text.lower() in ["/huy", "/cancel"]:
        clear_wizard_data(context)
        await update.message.reply_text("Đã hủy tạo việc.")
        return ConversationHandler.END

    data = get_wizard_data(context)

    # Parse time
    deadline, _ = parse_vietnamese_time(text)

    if not deadline:
        await update.message.reply_text(
            "Không nhận dạng được thời gian.\n\n"
            "Ví dụ: `14h30`, `ngày mai 10h`, `20/12 9h`\n\n"
            "Nhập lại hoặc /huy để hủy:",
            parse_mode="Markdown",
        )
        return DEADLINE_CUSTOM

    data["deadline"] = deadline

    # Get recent users
    try:
        db = get_db()
        user = update.effective_user
        db_user = await get_or_create_user(db, user)
        data["creator_id"] = db_user["id"]

        recent = await db.fetch_all(
            """
            SELECT DISTINCT u.id, u.display_name, u.username
            FROM users u
            JOIN tasks t ON t.assignee_id = u.id
            WHERE t.creator_id = $1 AND u.id != $1
            ORDER BY t.created_at DESC
            LIMIT 3
            """,
            db_user["id"],
        )
        recent_users = [dict(r) for r in recent] if recent else None
    except Exception:
        recent_users = None

    deadline_str = format_datetime(deadline, relative=True)

    # Check if private chat
    is_private = update.effective_chat.type == "private"

    await update.message.reply_text(
        f"Deadline: {deadline_str}\n\n"
        "Bước 3/5: Chọn người nhận\n\n"
        "Giao việc cho ai?",
        reply_markup=wizard_assignee_keyboard(recent_users, is_private_chat=is_private),
    )

    return ASSIGNEE


# =============================================================================
# Step 3: Assignee
# =============================================================================


async def assignee_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle assignee button selection."""
    query = update.callback_query
    await query.answer()

    data = get_wizard_data(context)
    parts = query.data.split(":")
    action = parts[1] if len(parts) > 1 else ""

    if action == "self":
        # Assign to self
        try:
            db = get_db()
            user = update.effective_user
            db_user = await get_or_create_user(db, user)
            data["assignee_ids"] = [db_user["id"]]
            data["assignee_name"] = "Bản thân"
            data["creator_id"] = db_user["id"]
        except Exception as e:
            logger.error(f"Error getting user: {e}")
            await query.edit_message_text(ERR_DATABASE)
            return ConversationHandler.END

    elif action == "others":
        # Check if group chat
        chat = update.effective_chat
        is_group = chat and chat.type in ["group", "supergroup"]
        reply_hint = "\n\n⚠️ REPLY tin nhắn này khi nhập" if is_group else ""

        # Ask for @mention input
        await query.edit_message_text(
            f"Nhập @username hoặc tag người nhận:\n\n"
            f"Ví dụ:\n"
            f"• `@username` - một người\n"
            f"• `@user1 @user2` - nhiều người (tạo việc nhóm){reply_hint}\n\n"
            f"Hoặc /huy để hủy",
            parse_mode="Markdown",
        )
        return ASSIGNEE_INPUT

    elif action.startswith("user:"):
        # Select recent user
        user_id = int(parts[2]) if len(parts) > 2 else None
        if user_id:
            try:
                db = get_db()
                assignee = await get_user_by_id(db, user_id)
                if assignee:
                    data["assignee_ids"] = [user_id]
                    data["assignee_name"] = assignee.get("display_name", "?")
            except Exception as e:
                logger.error(f"Error getting assignee: {e}")

    # Move to priority step
    assignee_name = data.get("assignee_name", "?")

    await query.edit_message_text(
        f"Người nhận: {assignee_name}\n\n"
        "Bước 4/5: Chọn độ ưu tiên",
        reply_markup=wizard_priority_keyboard(),
    )

    return PRIORITY


async def receive_assignee_input(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Receive assignee mention input (supports both @username and text_mention)."""
    text = update.message.text.strip()
    message = update.message

    if text.lower() in ["/huy", "/cancel"]:
        clear_wizard_data(context)
        await update.message.reply_text("Đã hủy tạo việc.")
        return ConversationHandler.END

    data = get_wizard_data(context)

    try:
        db = get_db()
        users = []

        # Method 1: Check message entities for text_mention (users without username)
        if message.entities:
            for entity in message.entities:
                if entity.type == "text_mention" and entity.user:
                    # User without username - register/get from entity.user
                    mentioned_user = await get_or_create_user(db, entity.user)
                    if not any(u["id"] == mentioned_user["id"] for u in users):
                        users.append(mentioned_user)
                        logger.info(f"Found text_mention: {entity.user.first_name} (id={entity.user.id})")

                elif entity.type == "mention":
                    # @username mention - extract from text
                    full_text = message.text or ""
                    username_with_at = full_text[entity.offset:entity.offset + entity.length]
                    username = username_with_at.lstrip("@")
                    found_user = await get_user_by_username(db, username)
                    if found_user and not any(u["id"] == found_user["id"] for u in users):
                        users.append(found_user)
                        logger.info(f"Found @mention: @{username} (id={found_user['id']})")

        # Method 2: Fallback to extract_mentions for @username in plain text
        if not users:
            usernames, _ = extract_mentions(text)
            not_found = []
            for username in usernames:
                user = await get_user_by_username(db, username)
                if user and not any(u["id"] == user["id"] for u in users):
                    users.append(user)
                else:
                    not_found.append(username)

            if not users and not_found:
                await update.message.reply_text(
                    f"Không tìm thấy: @{', @'.join(not_found)}\n\n"
                    "Người nhận cần /start bot trước.\n"
                    "Vui lòng tag tên hoặc nhập @username:",
                )
                return ASSIGNEE_INPUT

        if not users:
            await update.message.reply_text(
                "Vui lòng tag tên người nhận hoặc nhập @username.\n\n"
                "💡 Tip: Tag tên (vuốt phải reply) hoặc gõ @username\n"
                "Hoặc /huy để hủy:",
            )
            return ASSIGNEE_INPUT

        data["assignee_ids"] = [u["id"] for u in users]

        if len(users) == 1:
            data["assignee_name"] = users[0].get("display_name", users[0].get("username", "?"))
        else:
            names = [u.get("display_name", u.get("username", "?"))[:10] for u in users[:3]]
            data["assignee_name"] = ", ".join(names)
            if len(users) > 3:
                data["assignee_name"] += f" +{len(users) - 3}"

    except Exception as e:
        logger.error(f"Error finding users: {e}")
        await update.message.reply_text(ERR_DATABASE)
        return ConversationHandler.END

    assignee_name = data.get("assignee_name", "?")

    await update.message.reply_text(
        f"Người nhận: {assignee_name}\n\n"
        "Bước 4/5: Chọn độ ưu tiên",
        reply_markup=wizard_priority_keyboard(),
    )

    return PRIORITY


# =============================================================================
# Step 4: Priority
# =============================================================================


async def priority_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle priority button selection."""
    query = update.callback_query
    await query.answer()

    data = get_wizard_data(context)
    parts = query.data.split(":")
    action = parts[1] if len(parts) > 1 else "normal"

    data["priority"] = PRIORITY_MAP.get(action, "normal")

    # Show confirmation
    summary = format_wizard_summary(data)

    await query.edit_message_text(
        f"<b>Bước 5/5:</b> Xác nhận\n\n{summary}",
        reply_markup=wizard_confirm_keyboard(),
        parse_mode="HTML",
    )

    return CONFIRM


# =============================================================================
# Step 5: Confirm
# =============================================================================


async def confirm_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle confirmation buttons."""
    query = update.callback_query
    await query.answer()

    data = get_wizard_data(context)
    parts = query.data.split(":")
    action = parts[1] if len(parts) > 1 else ""

    if action == "cancel":
        clear_wizard_data(context)
        await query.edit_message_text("Đã hủy tạo việc.")
        return ConversationHandler.END

    if action == "create":
        # Create the task
        try:
            db = get_db()
            user = update.effective_user
            chat = update.effective_chat
            db_user = await get_or_create_user(db, user)
            is_group_chat = chat.type in ["group", "supergroup"]

            assignee_ids = data.get("assignee_ids", [db_user["id"]])
            content = data.get("content", "")
            deadline = data.get("deadline")
            priority = data.get("priority", "normal")

            if len(assignee_ids) == 1:
                # Single assignee - create regular task
                is_personal = (assignee_ids[0] == db_user["id"])
                task = await create_task(
                    db=db,
                    content=content,
                    creator_id=db_user["id"],
                    assignee_id=assignee_ids[0],
                    deadline=deadline,
                    priority=priority,
                    is_personal=is_personal,
                )

                deadline_str = format_datetime(deadline, relative=True) if deadline else "Không có"
                priority_str = format_priority(priority)

                if is_personal:
                    # Personal task - no mention needed
                    await query.edit_message_text(
                        MSG_TASK_CREATED.format(
                            task_id=task["public_id"],
                            content=content,
                            deadline=deadline_str,
                            priority=priority_str,
                        ),
                        reply_markup=task_actions_keyboard(task["public_id"], show_complete=False),
                    )

                    # Sync to Google Calendar if connected
                    calendar_synced = False
                    if deadline:
                        calendar_synced = await sync_task_to_calendar(db, task, db_user["id"])

                    # Send private notification if created in group
                    if is_group_chat:
                        calendar_note = "\n📅 *Đã thêm vào Google Calendar*" if calendar_synced else ""
                        await send_private_notification(
                            context,
                            user.id,
                            f"📋 *Việc cá nhân đã tạo*\n\n"
                            f"*{task['public_id']}*: {content}\n"
                            f"📅 Deadline: {deadline_str}\n"
                            f"⚡ Ưu tiên: {priority_str}{calendar_note}\n\n"
                            f"Xem chi tiết: /xemviec {task['public_id']}",
                            reply_markup=task_actions_keyboard(task["public_id"], show_complete=False),
                        )
                else:
                    # Task assigned to someone else - show mention
                    assignee = await get_user_by_id(db, assignee_ids[0])
                    assignee_mention = mention_user(assignee) if assignee else data.get("assignee_name", "?")
                    await query.edit_message_text(
                        f"✅ ĐÃ TẠO VIỆC\n\n"
                        f"📋 *{task['public_id']}*: {content}\n"
                        f"👤 Người nhận: {assignee_mention}\n"
                        f"📅 Deadline: {deadline_str}\n"
                        f"⚡ Ưu tiên: {priority_str}\n\n"
                        f"Xem chi tiết: /xemviec {task['public_id']}",
                        parse_mode="Markdown",
                        reply_markup=task_actions_keyboard(task["public_id"], show_complete=False),
                    )

                    # Send private notification to creator if in group
                    if is_group_chat:
                        await send_private_notification(
                            context,
                            user.id,
                            f"✅ *Đã giao việc*\n\n"
                            f"📋 *{task['public_id']}*: {content}\n"
                            f"👤 Giao cho: {assignee_mention}\n"
                            f"📅 Deadline: {deadline_str}\n\n"
                            f"Xem chi tiết: /xemviec {task['public_id']}",
                            reply_markup=task_actions_keyboard(task["public_id"], show_complete=False),
                        )

                    # Send private notification to assignee and sync calendar
                    if assignee and assignee.get("telegram_id") != user.id:
                        creator_mention = mention_user(db_user)

                        # Sync to assignee's Google Calendar if connected
                        calendar_synced = False
                        if deadline:
                            calendar_synced = await sync_task_to_calendar(db, task, assignee_ids[0])
                        calendar_note = "\n📅 *Đã thêm vào Google Calendar*" if calendar_synced else ""

                        await send_private_notification(
                            context,
                            assignee["telegram_id"],
                            f"📬 *Bạn có việc mới!*\n\n"
                            f"📋 *{task['public_id']}*: {content}\n"
                            f"👤 Từ: {creator_mention}\n"
                            f"📅 Deadline: {deadline_str}{calendar_note}\n\n"
                            f"Trả lời /xong {task['public_id']} khi hoàn thành.",
                            reply_markup=task_actions_keyboard(task["public_id"], show_complete=False),
                        )

                logger.info(f"Wizard: User {user.id} created task {task['public_id']}")

            else:
                # Multiple assignees - fetch user objects and create group task
                assignees = []
                for aid in assignee_ids:
                    assignee = await get_user_by_id(db, aid)
                    if assignee:
                        assignees.append(assignee)

                if not assignees:
                    await query.edit_message_text("Không tìm thấy người nhận.")
                    clear_wizard_data(context)
                    return ConversationHandler.END

                group_task, child_tasks = await create_group_task(
                    db=db,
                    content=content,
                    creator_id=db_user["id"],
                    assignees=assignees,
                    deadline=deadline,
                    priority=priority,
                )

                deadline_str = format_datetime(deadline, relative=True) if deadline else "Không có"
                priority_str = format_priority(priority)

                # Create mention tags for assignees
                assignee_mentions = ", ".join(mention_user(a) for a in assignees)

                await query.edit_message_text(
                    f"✅ VIỆC NHÓM ĐÃ TẠO\n\n"
                    f"📋 *{group_task['public_id']}*: {content}\n"
                    f"👥 Người nhận: {assignee_mentions}\n"
                    f"📅 Deadline: {deadline_str}\n"
                    f"⚡ Ưu tiên: {priority_str}\n\n"
                    f"Xem chi tiết: /xemviec {group_task['public_id']}",
                    parse_mode="Markdown",
                )

                # Send private notification to creator if in group
                if is_group_chat:
                    await send_private_notification(
                        context,
                        user.id,
                        f"✅ *Đã tạo việc nhóm*\n\n"
                        f"📋 *{group_task['public_id']}*: {content}\n"
                        f"👥 Người nhận: {assignee_mentions}\n"
                        f"📅 Deadline: {deadline_str}\n\n"
                        f"Xem chi tiết: /xemviec {group_task['public_id']}",
                    )

                # Send private notification to each assignee with their P-ID
                creator_mention = mention_user(db_user)
                for child_task, assignee in child_tasks:
                    if assignee.get("telegram_id") != user.id:
                        await send_private_notification(
                            context,
                            assignee["telegram_id"],
                            f"📬 *Bạn có việc nhóm mới!*\n\n"
                            f"📋 *{group_task['public_id']}*: {content}\n"
                            f"👤 Từ: {creator_mention}\n"
                            f"📅 Deadline: {deadline_str}\n"
                            f"👥 Thành viên: {len(assignees)} người\n\n"
                            f"🔖 Việc của bạn: *{child_task['public_id']}*\n"
                            f"Trả lời /xong {child_task['public_id']} khi hoàn thành.",
                            reply_markup=task_actions_keyboard(child_task['public_id'], show_complete=False),
                        )

                logger.info(f"Wizard: User {user.id} created group task {group_task['public_id']}")

            clear_wizard_data(context)
            return ConversationHandler.END

        except Exception as e:
            logger.error(f"Error creating task in wizard: {e}")
            await query.edit_message_text(ERR_DATABASE)
            clear_wizard_data(context)
            return ConversationHandler.END

    return CONFIRM


async def edit_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle edit buttons in confirmation step."""
    query = update.callback_query
    await query.answer()

    parts = query.data.split(":")
    field = parts[1] if len(parts) > 1 else ""

    # Show edit menu
    if field == "menu":
        from utils.keyboards import wizard_edit_menu_keyboard
        await query.edit_message_text(
            "✏️ <b>Sửa thông tin việc</b>\n\n"
            "Chọn mục cần sửa:",
            reply_markup=wizard_edit_menu_keyboard(),
            parse_mode="HTML",
        )
        return CONFIRM

    # Back to confirm screen
    if field == "back":
        data = get_wizard_data(context)
        summary = format_wizard_summary(data)
        from utils.keyboards import wizard_confirm_keyboard
        await query.edit_message_text(
            f"<b>Bước 5/5:</b> Xác nhận\n\n{summary}",
            reply_markup=wizard_confirm_keyboard(),
            parse_mode="HTML",
        )
        return CONFIRM

    if field == "content":
        await query.edit_message_text(
            "Sửa nội dung việc:\n\n"
            "Nhập nội dung mới:",
            reply_markup=wizard_cancel_keyboard(),
        )
        return CONTENT

    elif field == "deadline":
        await query.edit_message_text(
            "Sửa deadline:\n\n"
            "Chọn thời hạn mới:",
            reply_markup=wizard_deadline_keyboard(),
        )
        return DEADLINE

    elif field == "assignee":
        # Get recent users
        try:
            db = get_db()
            user = update.effective_user
            db_user = await get_or_create_user(db, user)

            recent = await db.fetch_all(
                """
                SELECT DISTINCT u.id, u.display_name, u.username
                FROM users u
                JOIN tasks t ON t.assignee_id = u.id
                WHERE t.creator_id = $1 AND u.id != $1
                ORDER BY t.created_at DESC
                LIMIT 3
                """,
                db_user["id"],
            )
            recent_users = [dict(r) for r in recent] if recent else None
        except Exception:
            recent_users = None

        is_private = update.effective_chat.type == "private"
        await query.edit_message_text(
            "Sửa người nhận:\n\n"
            "Chọn người nhận mới:",
            reply_markup=wizard_assignee_keyboard(recent_users, is_private_chat=is_private),
        )
        return ASSIGNEE

    elif field == "priority":
        await query.edit_message_text(
            "Sửa độ ưu tiên:\n\n"
            "Chọn độ ưu tiên mới:",
            reply_markup=wizard_priority_keyboard(),
        )
        return PRIORITY

    return CONFIRM


# =============================================================================
# Back & Cancel Handlers
# =============================================================================


async def back_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle back button."""
    query = update.callback_query
    await query.answer()

    parts = query.data.split(":")
    target = parts[1] if len(parts) > 1 else ""

    data = get_wizard_data(context)

    if target == "content":
        await query.edit_message_text(
            "Bước 1/5: Nhập nội dung việc\n\n"
            f"Nội dung hiện tại: {data.get('content', 'Chưa có')}\n\n"
            "Nhập nội dung mới hoặc /huy để hủy:",
            reply_markup=wizard_cancel_keyboard(),
        )
        return CONTENT

    elif target == "deadline":
        await query.edit_message_text(
            "Bước 2/5: Chọn deadline\n\n"
            "Chọn thời hạn hoàn thành:",
            reply_markup=wizard_deadline_keyboard(),
        )
        return DEADLINE

    elif target == "assignee":
        # Get recent users
        try:
            db = get_db()
            user = update.effective_user
            db_user = await get_or_create_user(db, user)

            recent = await db.fetch_all(
                """
                SELECT DISTINCT u.id, u.display_name, u.username
                FROM users u
                JOIN tasks t ON t.assignee_id = u.id
                WHERE t.creator_id = $1 AND u.id != $1
                ORDER BY t.created_at DESC
                LIMIT 3
                """,
                db_user["id"],
            )
            recent_users = [dict(r) for r in recent] if recent else None
        except Exception:
            recent_users = None

        is_private = update.effective_chat.type == "private"
        await query.edit_message_text(
            "Bước 3/5: Chọn người nhận\n\n"
            "Giao việc cho ai?",
            reply_markup=wizard_assignee_keyboard(recent_users, is_private_chat=is_private),
        )
        return ASSIGNEE

    return CONTENT


async def cancel_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle cancel button."""
    query = update.callback_query
    await query.answer()

    clear_wizard_data(context)
    await query.edit_message_text("Đã hủy tạo việc.")
    return ConversationHandler.END


async def cancel_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle /huy command."""
    clear_wizard_data(context)
    await update.message.reply_text("Đã hủy tạo việc.")
    return ConversationHandler.END


# =============================================================================
# Handler Registration
# =============================================================================


def get_wizard_conversation_handler() -> ConversationHandler:
    """Get the wizard ConversationHandler for /taoviec."""
    return ConversationHandler(
        entry_points=[
            CommandHandler("taoviec", wizard_start),
        ],
        states={
            CONTENT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, receive_content),
                CommandHandler("huy", cancel_command),
            ],
            DEADLINE: [
                CallbackQueryHandler(deadline_callback, pattern=r"^wizard_deadline:"),
                CallbackQueryHandler(back_callback, pattern=r"^wizard_back:"),
                CallbackQueryHandler(cancel_callback, pattern=r"^wizard_cancel$"),
            ],
            DEADLINE_CUSTOM: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, receive_deadline_custom),
                CommandHandler("huy", cancel_command),
            ],
            ASSIGNEE: [
                CallbackQueryHandler(assignee_callback, pattern=r"^wizard_assignee:"),
                CallbackQueryHandler(back_callback, pattern=r"^wizard_back:"),
                CallbackQueryHandler(cancel_callback, pattern=r"^wizard_cancel$"),
            ],
            ASSIGNEE_INPUT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, receive_assignee_input),
                CommandHandler("huy", cancel_command),
            ],
            PRIORITY: [
                CallbackQueryHandler(priority_callback, pattern=r"^wizard_priority:"),
                CallbackQueryHandler(back_callback, pattern=r"^wizard_back:"),
                CallbackQueryHandler(cancel_callback, pattern=r"^wizard_cancel$"),
            ],
            CONFIRM: [
                CallbackQueryHandler(confirm_callback, pattern=r"^wizard_confirm:"),
                CallbackQueryHandler(edit_callback, pattern=r"^wizard_edit:"),
                CallbackQueryHandler(cancel_callback, pattern=r"^wizard_cancel$"),
            ],
        },
        fallbacks=[
            CommandHandler("huy", cancel_command),
            CommandHandler("cancel", cancel_command),
            CallbackQueryHandler(cancel_callback, pattern=r"^wizard_cancel$"),
        ],
        per_user=True,
        per_chat=True,
        per_message=False,
    )


# =============================================================================
# Assignment Wizard States (for /giaoviec)
# =============================================================================

ASSIGN_CONTENT, ASSIGN_RECIPIENT, ASSIGN_DEADLINE, ASSIGN_DEADLINE_CUSTOM, ASSIGN_PRIORITY, ASSIGN_CONFIRM = range(100, 106)


def format_assign_summary(data: dict) -> str:
    """Format assignment wizard data summary."""
    content = data.get("content", "N/A")
    deadline = data.get("deadline")
    deadline_str = format_datetime(deadline, relative=True) if deadline else "Không có"
    assignee_name = data.get("assignee_name", "Chưa chọn")
    priority = data.get("priority", "normal")
    priority_str = format_priority(priority)

    return f"""
<b>GIAO VIỆC MỚI</b>

<b>Nội dung:</b> {content}

<b>Người nhận:</b> {assignee_name}
<b>Deadline:</b> {deadline_str}
<b>Độ ưu tiên:</b> {priority_str}

Xác nhận giao việc?
""".strip()


async def assign_wizard_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Start assignment wizard or direct creation if args provided."""
    user = update.effective_user
    if not user:
        return ConversationHandler.END

    # Check if args provided -> use direct creation
    if context.args:
        # Import and call original giaoviec logic
        from handlers.task_assign import giaoviec_command
        await giaoviec_command(update, context)
        return ConversationHandler.END

    # Initialize wizard data
    clear_wizard_data(context)
    data = get_wizard_data(context)
    data["wizard_type"] = "assign"

    # Check if group chat - need REPLY instruction
    chat = update.effective_chat
    is_group = chat and chat.type in ["group", "supergroup"]
    reply_hint = "\n\n⚠️ REPLY tin nhắn này khi nhập (vuốt phải)" if is_group else ""

    await update.message.reply_text(
        f"GIAO VIỆC TỪNG BƯỚC\n\n"
        f"Bước 1/5: Nhập nội dung việc\n\n"
        f"Nhập nội dung việc cần giao:{reply_hint}",
        reply_markup=wizard_cancel_keyboard(),
    )

    return ASSIGN_CONTENT


async def assign_receive_content(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Receive task content for assignment."""
    text = update.message.text.strip()

    if text.lower() in ["/huy", "/cancel"]:
        clear_wizard_data(context)
        await update.message.reply_text("Đã hủy giao việc.")
        return ConversationHandler.END

    # Validate content
    is_valid, result = validate_task_content(text)
    if not is_valid:
        await update.message.reply_text(
            f"{result}\n\nVui lòng nhập lại nội dung:",
            reply_markup=wizard_cancel_keyboard(),
        )
        return ASSIGN_CONTENT

    data = get_wizard_data(context)
    data["content"] = result

    # Get recent assignees for suggestions
    try:
        db = get_db()
        user = update.effective_user
        db_user = await get_or_create_user(db, user)
        data["creator_id"] = db_user["id"]

        recent = await db.fetch_all(
            """
            SELECT DISTINCT u.id, u.display_name, u.username
            FROM users u
            JOIN tasks t ON t.assignee_id = u.id
            WHERE t.creator_id = $1 AND u.id != $1
            ORDER BY t.created_at DESC
            LIMIT 3
            """,
            db_user["id"],
        )
        recent_users = [dict(r) for r in recent] if recent else None
    except Exception:
        recent_users = None

    # Custom keyboard for assignment (no "self" option)
    buttons = []
    if recent_users:
        recent_row = []
        for user_rec in recent_users[:3]:
            name = user_rec.get("display_name", "?")[:10]
            user_id = user_rec.get("id")
            recent_row.append(
                InlineKeyboardButton(f"@{name}", callback_data=f"assign_user:{user_id}")
            )
        buttons.append(recent_row)

    buttons.extend([
        [InlineKeyboardButton("📝 Nhập @username", callback_data="assign_input")],
        [
            InlineKeyboardButton("« Quay lại", callback_data="assign_back:content"),
            InlineKeyboardButton("❌ Hủy", callback_data="assign_cancel"),
        ],
    ])

    await update.message.reply_text(
        "Bước 2/5: Chọn người nhận\n\n"
        "Chọn người nhận hoặc nhập @username:\n"
        "(Có thể nhập nhiều người: @user1 @user2)",
        reply_markup=InlineKeyboardMarkup(buttons),
    )

    return ASSIGN_RECIPIENT


async def assign_recipient_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle recipient selection callback."""
    query = update.callback_query
    await query.answer()

    data = get_wizard_data(context)
    action = query.data

    if action == "assign_input":
        # Check if group chat
        chat = update.effective_chat
        is_group = chat and chat.type in ["group", "supergroup"]
        reply_hint = "\n\n⚠️ REPLY tin nhắn này khi nhập" if is_group else ""

        await query.edit_message_text(
            f"Nhập @username người nhận:\n\n"
            f"Ví dụ:\n"
            f"• `@username` - một người\n"
            f"• `@user1 @user2` - nhiều người (tạo việc nhóm){reply_hint}\n\n"
            f"Hoặc /huy để hủy",
            parse_mode="Markdown",
        )
        return ASSIGN_RECIPIENT  # Stay in same state but wait for text

    elif action.startswith("assign_user:"):
        user_id = int(action.split(":")[1])
        try:
            db = get_db()
            assignee = await get_user_by_id(db, user_id)
            if assignee:
                data["assignee_ids"] = [user_id]
                data["assignee_name"] = assignee.get("display_name", "?")
        except Exception as e:
            logger.error(f"Error getting assignee: {e}")

    elif action == "assign_cancel":
        clear_wizard_data(context)
        await query.edit_message_text("Đã hủy giao việc.")
        return ConversationHandler.END

    elif action == "assign_back:content":
        await query.edit_message_text(
            "Bước 1/5: Nhập nội dung việc\n\n"
            f"Nội dung hiện tại: {data.get('content', 'Chưa có')}\n\n"
            "Nhập nội dung mới hoặc /huy để hủy:",
            reply_markup=wizard_cancel_keyboard(),
        )
        return ASSIGN_CONTENT

    # Move to deadline step
    await query.edit_message_text(
        f"Người nhận: {data.get('assignee_name', '?')}\n\n"
        "Bước 3/5: Chọn deadline",
        reply_markup=assign_deadline_keyboard(),
    )

    return ASSIGN_DEADLINE


async def assign_receive_recipient(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Receive recipient mention input (supports both @username and text_mention)."""
    text = update.message.text.strip()
    message = update.message

    if text.lower() in ["/huy", "/cancel"]:
        clear_wizard_data(context)
        await update.message.reply_text("Đã hủy giao việc.")
        return ConversationHandler.END

    data = get_wizard_data(context)

    try:
        db = get_db()
        users = []

        # Method 1: Check message entities for text_mention (users without username)
        if message.entities:
            for entity in message.entities:
                if entity.type == "text_mention" and entity.user:
                    # User without username - register/get from entity.user
                    mentioned_user = await get_or_create_user(db, entity.user)
                    if not any(u["id"] == mentioned_user["id"] for u in users):
                        users.append(mentioned_user)
                        logger.info(f"Found text_mention: {entity.user.first_name} (id={entity.user.id})")

                elif entity.type == "mention":
                    # @username mention - extract from text
                    full_text = message.text or ""
                    username_with_at = full_text[entity.offset:entity.offset + entity.length]
                    username = username_with_at.lstrip("@")
                    found_user = await get_user_by_username(db, username)
                    if found_user and not any(u["id"] == found_user["id"] for u in users):
                        users.append(found_user)
                        logger.info(f"Found @mention: @{username} (id={found_user['id']})")

        # Method 2: Fallback to extract_mentions for @username in plain text
        if not users:
            usernames, _ = extract_mentions(text)
            not_found = []
            for username in usernames:
                user = await get_user_by_username(db, username)
                if user and not any(u["id"] == user["id"] for u in users):
                    users.append(user)
                else:
                    not_found.append(username)

            if not users and not_found:
                await update.message.reply_text(
                    f"Không tìm thấy: @{', @'.join(not_found)}\n\n"
                    "Người nhận cần /start bot trước.\n"
                    "Vui lòng tag tên hoặc nhập @username:",
                )
                return ASSIGN_RECIPIENT

        if not users:
            await update.message.reply_text(
                "Vui lòng tag tên người nhận hoặc nhập @username.\n\n"
                "💡 Tip: Tag tên (vuốt phải reply) hoặc gõ @username\n"
                "Hoặc /huy để hủy:",
            )
            return ASSIGN_RECIPIENT

        data["assignee_ids"] = [u["id"] for u in users]

        if len(users) == 1:
            data["assignee_name"] = users[0].get("display_name", users[0].get("username", "?"))
        else:
            names = [u.get("display_name", u.get("username", "?"))[:10] for u in users[:3]]
            data["assignee_name"] = ", ".join(names)
            if len(users) > 3:
                data["assignee_name"] += f" +{len(users) - 3}"

    except Exception as e:
        logger.error(f"Error finding users: {e}")
        await update.message.reply_text(ERR_DATABASE)
        return ConversationHandler.END

    await update.message.reply_text(
        f"Người nhận: {data.get('assignee_name', '?')}\n\n"
        "Bước 3/5: Chọn deadline",
        reply_markup=assign_deadline_keyboard(),
    )

    return ASSIGN_DEADLINE


def assign_deadline_keyboard() -> InlineKeyboardMarkup:
    """Deadline keyboard for assignment wizard."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("📅 Hôm nay", callback_data="assign_deadline:today"),
            InlineKeyboardButton("📅 Ngày mai", callback_data="assign_deadline:tomorrow"),
        ],
        [
            InlineKeyboardButton("📅 Tuần sau", callback_data="assign_deadline:nextweek"),
            InlineKeyboardButton("⏰ Nhập khác", callback_data="assign_deadline:custom"),
        ],
        [
            InlineKeyboardButton("⏭️ Bỏ qua", callback_data="assign_deadline:skip"),
        ],
        [
            InlineKeyboardButton("« Quay lại", callback_data="assign_back:recipient"),
            InlineKeyboardButton("❌ Hủy", callback_data="assign_cancel"),
        ],
    ])


async def assign_deadline_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle deadline selection for assignment."""
    query = update.callback_query
    await query.answer()

    data = get_wizard_data(context)
    action = query.data.split(":")[1] if ":" in query.data else ""

    # Use timezone-aware datetime
    tz = pytz.timezone("Asia/Ho_Chi_Minh")
    now = datetime.now(tz)

    if action == "today":
        data["deadline"] = now.replace(hour=23, minute=59, second=0, microsecond=0)
    elif action == "tomorrow":
        data["deadline"] = (now + timedelta(days=1)).replace(hour=23, minute=59, second=0, microsecond=0)
    elif action == "nextweek":
        data["deadline"] = (now + timedelta(days=7)).replace(hour=23, minute=59, second=0, microsecond=0)
    elif action == "skip":
        data["deadline"] = None
    elif action == "custom":
        # Check if group chat
        chat = update.effective_chat
        is_group = chat and chat.type in ["group", "supergroup"]
        reply_hint = "\n\n⚠️ REPLY tin nhắn này khi nhập" if is_group else ""

        await query.edit_message_text(
            f"Nhập thời gian deadline:\n\n"
            f"Ví dụ: `14h30`, `ngày mai 10h`, `20/12 9h`{reply_hint}\n\n"
            f"Hoặc /huy để hủy",
            parse_mode="Markdown",
        )
        return ASSIGN_DEADLINE_CUSTOM

    # Move to priority
    await query.edit_message_text(
        "Bước 4/5: Chọn độ ưu tiên",
        reply_markup=assign_priority_keyboard(),
    )

    return ASSIGN_PRIORITY


async def assign_receive_deadline_custom(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Receive custom deadline for assignment."""
    text = update.message.text.strip()

    if text.lower() in ["/huy", "/cancel"]:
        clear_wizard_data(context)
        await update.message.reply_text("Đã hủy giao việc.")
        return ConversationHandler.END

    data = get_wizard_data(context)
    deadline, _ = parse_vietnamese_time(text)

    if not deadline:
        await update.message.reply_text(
            "Không nhận dạng được thời gian.\n\n"
            "Ví dụ: `14h30`, `ngày mai 10h`, `20/12 9h`\n\n"
            "Nhập lại hoặc /huy để hủy:",
            parse_mode="Markdown",
        )
        return ASSIGN_DEADLINE_CUSTOM

    data["deadline"] = deadline

    await update.message.reply_text(
        "Bước 4/5: Chọn độ ưu tiên",
        reply_markup=assign_priority_keyboard(),
    )

    return ASSIGN_PRIORITY


def assign_priority_keyboard() -> InlineKeyboardMarkup:
    """Priority keyboard for assignment wizard."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("🔴 Khẩn cấp", callback_data="assign_priority:urgent"),
            InlineKeyboardButton("🟠 Cao", callback_data="assign_priority:high"),
        ],
        [
            InlineKeyboardButton("🟡 Bình thường", callback_data="assign_priority:normal"),
            InlineKeyboardButton("🟢 Thấp", callback_data="assign_priority:low"),
        ],
        [
            InlineKeyboardButton("« Quay lại", callback_data="assign_back:deadline"),
            InlineKeyboardButton("❌ Hủy", callback_data="assign_cancel"),
        ],
    ])


async def assign_priority_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle priority selection for assignment."""
    query = update.callback_query
    await query.answer()

    data = get_wizard_data(context)
    action = query.data.split(":")[1] if ":" in query.data else "normal"

    data["priority"] = PRIORITY_MAP.get(action, "normal")

    summary = format_assign_summary(data)

    await query.edit_message_text(
        f"<b>Bước 5/5:</b> Xác nhận\n\n{summary}",
        reply_markup=assign_confirm_keyboard(),
        parse_mode="HTML",
    )

    return ASSIGN_CONFIRM


def assign_confirm_keyboard() -> InlineKeyboardMarkup:
    """Confirmation keyboard for assignment wizard - each on separate row."""
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("✏️ SỬA THÔNG TIN", callback_data="assign_edit:menu")],
        [InlineKeyboardButton("❌ Hủy giao việc", callback_data="assign_confirm:cancel")],
        [InlineKeyboardButton("✅ XÁC NHẬN GIAO VIỆC", callback_data="assign_confirm:create")],
    ])


def assign_edit_menu_keyboard() -> InlineKeyboardMarkup:
    """Edit submenu for task assignment wizard."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("✏️ Sửa nội dung", callback_data="assign_edit:content"),
        ],
        [
            InlineKeyboardButton("👤 Sửa người nhận", callback_data="assign_edit:recipient"),
        ],
        [
            InlineKeyboardButton("📅 Sửa deadline", callback_data="assign_edit:deadline"),
        ],
        [
            InlineKeyboardButton("🔔 Sửa độ ưu tiên", callback_data="assign_edit:priority"),
        ],
        [
            InlineKeyboardButton("« Quay lại", callback_data="assign_edit:back"),
        ],
    ])


async def assign_confirm_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle confirmation for assignment wizard."""
    query = update.callback_query
    await query.answer()

    data = get_wizard_data(context)
    action = query.data.split(":")[1] if ":" in query.data else ""

    if action == "cancel":
        clear_wizard_data(context)
        await query.edit_message_text("Đã hủy giao việc.")
        return ConversationHandler.END

    if action == "create":
        try:
            db = get_db()
            user = update.effective_user
            chat = update.effective_chat
            db_user = await get_or_create_user(db, user)
            is_group_chat = chat.type in ["group", "supergroup"]

            assignee_ids = data.get("assignee_ids", [])
            content = data.get("content", "")
            deadline = data.get("deadline")
            priority = data.get("priority", "normal")

            if not assignee_ids:
                await query.edit_message_text("Lỗi: Chưa chọn người nhận.")
                clear_wizard_data(context)
                return ConversationHandler.END

            deadline_str = format_datetime(deadline, relative=True) if deadline else "Không có"

            if len(assignee_ids) == 1:
                # Single assignee
                task = await create_task(
                    db=db,
                    content=content,
                    creator_id=db_user["id"],
                    assignee_id=assignee_ids[0],
                    deadline=deadline,
                    priority=priority,
                    is_personal=False,
                )

                # Get assignee for mention
                assignee = await get_user_by_id(db, assignee_ids[0])
                assignee_mention = mention_user(assignee) if assignee else data.get("assignee_name", "?")

                await query.edit_message_text(
                    f"✅ ĐÃ GIAO VIỆC\n\n"
                    f"📋 *{task['public_id']}*: {content}\n"
                    f"👤 Người nhận: {assignee_mention}\n"
                    f"📅 Deadline: {deadline_str}\n\n"
                    f"Xem chi tiết: /xemviec {task['public_id']}",
                    parse_mode="Markdown",
                )

                # Send private notification to creator if in group
                if is_group_chat:
                    await send_private_notification(
                        context,
                        user.id,
                        f"✅ *Đã giao việc*\n\n"
                        f"📋 *{task['public_id']}*: {content}\n"
                        f"👤 Giao cho: {assignee_mention}\n"
                        f"📅 Deadline: {deadline_str}\n\n"
                        f"Xem chi tiết: /xemviec {task['public_id']}",
                        reply_markup=task_actions_keyboard(task['public_id'], show_complete=False),
                    )

                # Send private notification to assignee and sync calendar
                if assignee and assignee.get("telegram_id") != user.id:
                    creator_mention = mention_user(db_user)

                    # Sync to assignee's Google Calendar if connected
                    calendar_synced = False
                    if deadline:
                        calendar_synced = await sync_task_to_calendar(db, task, assignee_ids[0])
                    calendar_note = "\n📅 *Đã thêm vào Google Calendar*" if calendar_synced else ""

                    await send_private_notification(
                        context,
                        assignee["telegram_id"],
                        f"📬 *Bạn có việc mới!*\n\n"
                        f"📋 *{task['public_id']}*: {content}\n"
                        f"👤 Từ: {creator_mention}\n"
                        f"📅 Deadline: {deadline_str}{calendar_note}\n\n"
                        f"Trả lời /xong {task['public_id']} khi hoàn thành.",
                        reply_markup=task_actions_keyboard(task['public_id'], show_complete=False),
                    )

                logger.info(f"Assign wizard: User {user.id} assigned task {task['public_id']}")

            else:
                # Multiple assignees - fetch user objects and create group task
                assignees = []
                for aid in assignee_ids:
                    assignee = await get_user_by_id(db, aid)
                    if assignee:
                        assignees.append(assignee)

                if not assignees:
                    await query.edit_message_text("Không tìm thấy người nhận.")
                    clear_wizard_data(context)
                    return ConversationHandler.END

                group_task, child_tasks = await create_group_task(
                    db=db,
                    content=content,
                    creator_id=db_user["id"],
                    assignees=assignees,
                    deadline=deadline,
                    priority=priority,
                )

                # Create mention tags for assignees
                assignee_mentions = ", ".join(mention_user(a) for a in assignees)

                await query.edit_message_text(
                    f"✅ ĐÃ TẠO VIỆC NHÓM\n\n"
                    f"📋 *{group_task['public_id']}*: {content}\n"
                    f"👥 Người nhận: {assignee_mentions}\n"
                    f"📅 Deadline: {deadline_str}\n\n"
                    f"Xem chi tiết: /xemviec {group_task['public_id']}",
                    parse_mode="Markdown",
                )

                # Send private notification to creator if in group
                if is_group_chat:
                    await send_private_notification(
                        context,
                        user.id,
                        f"✅ *Đã tạo việc nhóm*\n\n"
                        f"📋 *{group_task['public_id']}*: {content}\n"
                        f"👥 Người nhận: {assignee_mentions}\n"
                        f"📅 Deadline: {deadline_str}\n\n"
                        f"Xem chi tiết: /xemviec {group_task['public_id']}",
                    )

                # Send private notification to each assignee with their P-ID and sync calendar
                creator_mention = mention_user(db_user)
                for child_task, assignee in child_tasks:
                    if assignee.get("telegram_id") != user.id:
                        # Sync to assignee's Google Calendar if connected
                        calendar_synced = False
                        if deadline:
                            calendar_synced = await sync_task_to_calendar(db, child_task, assignee["id"])
                        calendar_note = "\n📅 *Đã thêm vào Google Calendar*" if calendar_synced else ""

                        await send_private_notification(
                            context,
                            assignee["telegram_id"],
                            f"📬 *Bạn có việc nhóm mới!*\n\n"
                            f"📋 *{group_task['public_id']}*: {content}\n"
                            f"👤 Từ: {creator_mention}\n"
                            f"📅 Deadline: {deadline_str}\n"
                            f"👥 Thành viên: {len(assignees)} người{calendar_note}\n\n"
                            f"🔖 Việc của bạn: *{child_task['public_id']}*\n"
                            f"Trả lời /xong {child_task['public_id']} khi hoàn thành.",
                            reply_markup=task_actions_keyboard(child_task['public_id'], show_complete=False),
                        )

                logger.info(f"Assign wizard: User {user.id} created group task {group_task['public_id']}")

            clear_wizard_data(context)
            return ConversationHandler.END

        except Exception as e:
            logger.error(f"Error in assign wizard confirm: {e}")
            await query.edit_message_text(ERR_DATABASE)
            clear_wizard_data(context)
            return ConversationHandler.END

    return ASSIGN_CONFIRM


async def assign_edit_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle edit buttons in assignment confirmation."""
    query = update.callback_query
    await query.answer()

    field = query.data.split(":")[1] if ":" in query.data else ""
    data = get_wizard_data(context)

    # Show edit menu
    if field == "menu":
        await query.edit_message_text(
            "✏️ <b>Sửa thông tin giao việc</b>\n\n"
            "Chọn mục cần sửa:",
            reply_markup=assign_edit_menu_keyboard(),
            parse_mode="HTML",
        )
        return ASSIGN_CONFIRM

    # Back to confirm screen
    if field == "back":
        summary = format_assign_summary(data)
        await query.edit_message_text(
            f"<b>Bước 5/5:</b> Xác nhận\n\n{summary}",
            reply_markup=assign_confirm_keyboard(),
            parse_mode="HTML",
        )
        return ASSIGN_CONFIRM

    if field == "content":
        await query.edit_message_text(
            "Sửa nội dung việc:\n\n"
            f"Nội dung hiện tại: {data.get('content', 'N/A')}\n\n"
            "Nhập nội dung mới:",
            reply_markup=wizard_cancel_keyboard(),
        )
        return ASSIGN_CONTENT

    elif field == "recipient":
        # Get recent users
        try:
            db = get_db()
            user = update.effective_user
            db_user = await get_or_create_user(db, user)

            recent = await db.fetch_all(
                """
                SELECT DISTINCT u.id, u.display_name, u.username
                FROM users u
                JOIN tasks t ON t.assignee_id = u.id
                WHERE t.creator_id = $1 AND u.id != $1
                ORDER BY t.created_at DESC
                LIMIT 3
                """,
                db_user["id"],
            )
            recent_users = [dict(r) for r in recent] if recent else None
        except Exception:
            recent_users = None

        buttons = []
        if recent_users:
            recent_row = []
            for user_rec in recent_users[:3]:
                name = user_rec.get("display_name", "?")[:10]
                user_id = user_rec.get("id")
                recent_row.append(
                    InlineKeyboardButton(f"@{name}", callback_data=f"assign_user:{user_id}")
                )
            buttons.append(recent_row)

        buttons.extend([
            [InlineKeyboardButton("📝 Nhập @username", callback_data="assign_input")],
            [
                InlineKeyboardButton("« Quay lại", callback_data="assign_back:content"),
                InlineKeyboardButton("❌ Hủy", callback_data="assign_cancel"),
            ],
        ])

        await query.edit_message_text(
            "Sửa người nhận:\n\n"
            "Chọn người nhận hoặc nhập @username:",
            reply_markup=InlineKeyboardMarkup(buttons),
        )
        return ASSIGN_RECIPIENT

    return ASSIGN_CONFIRM


async def assign_back_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle back button in assignment wizard."""
    query = update.callback_query
    await query.answer()

    target = query.data.split(":")[1] if ":" in query.data else ""
    data = get_wizard_data(context)

    if target == "content":
        await query.edit_message_text(
            "Bước 1/5: Nhập nội dung việc\n\n"
            f"Nội dung hiện tại: {data.get('content', 'Chưa có')}\n\n"
            "Nhập nội dung mới hoặc /huy để hủy:",
            reply_markup=wizard_cancel_keyboard(),
        )
        return ASSIGN_CONTENT

    elif target == "recipient":
        # Get recent users
        try:
            db = get_db()
            user = update.effective_user
            db_user = await get_or_create_user(db, user)

            recent = await db.fetch_all(
                """
                SELECT DISTINCT u.id, u.display_name, u.username
                FROM users u
                JOIN tasks t ON t.assignee_id = u.id
                WHERE t.creator_id = $1 AND u.id != $1
                ORDER BY t.created_at DESC
                LIMIT 3
                """,
                db_user["id"],
            )
            recent_users = [dict(r) for r in recent] if recent else None
        except Exception:
            recent_users = None

        buttons = []
        if recent_users:
            recent_row = []
            for user_rec in recent_users[:3]:
                name = user_rec.get("display_name", "?")[:10]
                user_id = user_rec.get("id")
                recent_row.append(
                    InlineKeyboardButton(f"@{name}", callback_data=f"assign_user:{user_id}")
                )
            buttons.append(recent_row)

        buttons.extend([
            [InlineKeyboardButton("📝 Nhập @username", callback_data="assign_input")],
            [
                InlineKeyboardButton("« Quay lại", callback_data="assign_back:content"),
                InlineKeyboardButton("❌ Hủy", callback_data="assign_cancel"),
            ],
        ])

        await query.edit_message_text(
            "Bước 2/5: Chọn người nhận\n\n"
            "Chọn người nhận hoặc nhập @username:",
            reply_markup=InlineKeyboardMarkup(buttons),
        )
        return ASSIGN_RECIPIENT

    elif target == "deadline":
        await query.edit_message_text(
            "Bước 3/5: Chọn deadline",
            reply_markup=assign_deadline_keyboard(),
        )
        return ASSIGN_DEADLINE

    return ASSIGN_CONTENT


async def assign_cancel_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle cancel in assignment wizard."""
    query = update.callback_query
    await query.answer()

    clear_wizard_data(context)
    await query.edit_message_text("Đã hủy giao việc.")
    return ConversationHandler.END


def get_assign_wizard_conversation_handler() -> ConversationHandler:
    """Get the assignment wizard ConversationHandler for /giaoviec."""
    return ConversationHandler(
        entry_points=[
            CommandHandler("giaoviec", assign_wizard_start),
        ],
        states={
            ASSIGN_CONTENT: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, assign_receive_content),
                CommandHandler("huy", cancel_command),
            ],
            ASSIGN_RECIPIENT: [
                CallbackQueryHandler(assign_recipient_callback, pattern=r"^assign_"),
                MessageHandler(filters.TEXT & ~filters.COMMAND, assign_receive_recipient),
                CommandHandler("huy", cancel_command),
            ],
            ASSIGN_DEADLINE: [
                CallbackQueryHandler(assign_deadline_callback, pattern=r"^assign_deadline:"),
                CallbackQueryHandler(assign_back_callback, pattern=r"^assign_back:"),
                CallbackQueryHandler(assign_cancel_callback, pattern=r"^assign_cancel$"),
            ],
            ASSIGN_DEADLINE_CUSTOM: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, assign_receive_deadline_custom),
                CommandHandler("huy", cancel_command),
            ],
            ASSIGN_PRIORITY: [
                CallbackQueryHandler(assign_priority_callback, pattern=r"^assign_priority:"),
                CallbackQueryHandler(assign_back_callback, pattern=r"^assign_back:"),
                CallbackQueryHandler(assign_cancel_callback, pattern=r"^assign_cancel$"),
            ],
            ASSIGN_CONFIRM: [
                CallbackQueryHandler(assign_confirm_callback, pattern=r"^assign_confirm:"),
                CallbackQueryHandler(assign_edit_callback, pattern=r"^assign_edit:"),
                CallbackQueryHandler(assign_cancel_callback, pattern=r"^assign_cancel$"),
            ],
        },
        fallbacks=[
            CommandHandler("huy", cancel_command),
            CommandHandler("cancel", cancel_command),
            CallbackQueryHandler(assign_cancel_callback, pattern=r"^assign_cancel$"),
        ],
        per_user=True,
        per_chat=True,
        per_message=False,
    )


def get_handlers() -> list:
    """Return list of handlers for this module."""
    return [
        get_wizard_conversation_handler(),
        get_assign_wizard_conversation_handler(),
    ]
</file>

<file path="monitoring/__init__.py">
"""
Monitoring Package
Health checks, metrics, alerts, and resource monitoring
"""

from monitoring.health_check import HealthCheckServer
from monitoring.alert import AlertService
from monitoring.resource_monitor import ResourceMonitor
from monitoring.metrics import (
    record_task_created,
    record_task_completed,
    record_message_received,
    record_message_sent,
    record_error,
    update_system_metrics,
    get_metrics_text,
)

__all__ = [
    "HealthCheckServer",
    "AlertService",
    "ResourceMonitor",
    "record_task_created",
    "record_task_completed",
    "record_message_received",
    "record_message_sent",
    "record_error",
    "update_system_metrics",
    "get_metrics_text",
]
</file>

<file path="monitoring/alert.py">
"""
Alert Service
Send Telegram notifications to admins for critical events
"""

import os
import logging
import traceback
from datetime import datetime
from typing import List

logger = logging.getLogger(__name__)


class AlertService:
    """Send alerts to admin Telegram accounts."""

    def __init__(self, bot, admin_ids: List[int]):
        self.bot = bot
        self.admin_ids = admin_ids
        self.alert_cooldown = {}  # Prevent spam
        self.bot_name = os.getenv('BOT_NAME', 'TeleTask')

    async def send_alert(
        self,
        level: str,
        title: str,
        message: str,
        cooldown_key: str = None,
        cooldown_seconds: int = 300
    ):
        """Send alert to all admins."""
        # Check cooldown
        if cooldown_key:
            last_sent = self.alert_cooldown.get(cooldown_key)
            if last_sent and (datetime.now() - last_sent).seconds < cooldown_seconds:
                return

        # Format alert
        level_icons = {
            'critical': '🚨',
            'warning': '⚠️',
            'info': 'ℹ️',
            'success': '✅'
        }
        icon = level_icons.get(level, '📢')

        text = f"""{icon} {level.upper()} - {title}

🤖 Bot: {self.bot_name}
📅 Thời gian: {datetime.now().strftime('%H:%M:%S %d/%m/%Y')}

{message}"""

        # Send to all admins
        sent_count = 0
        for admin_id in self.admin_ids:
            try:
                await self.bot.send_message(chat_id=admin_id, text=text)
                sent_count += 1
            except Exception as e:
                logger.warning(f"Failed to send alert to admin {admin_id}: {e}")

        if sent_count > 0:
            logger.info(f"Alert sent to {sent_count} admins: {title}")

        # Update cooldown
        if cooldown_key:
            self.alert_cooldown[cooldown_key] = datetime.now()

    async def alert_bot_start(self):
        """Alert on bot startup."""
        await self.send_alert(
            'success',
            'BOT STARTED',
            "🚀 Bot đã khởi động thành công!",
            cooldown_key='bot_start',
            cooldown_seconds=60
        )

    async def alert_bot_crash(self, error: Exception):
        """Alert on bot crash/critical error."""
        error_tb = traceback.format_exc()[:800]
        await self.send_alert(
            'critical',
            'BOT ERROR',
            f"""❌ Lỗi: {str(error)[:300]}

📝 Chi tiết:
```
{error_tb}
```""",
            cooldown_key='bot_crash',
            cooldown_seconds=60
        )

    async def alert_db_error(self, error: Exception):
        """Alert on database error."""
        await self.send_alert(
            'critical',
            'DATABASE ERROR',
            f"""🐘 Database không kết nối được

❌ Lỗi: {str(error)[:300]}

🔄 Đang thử kết nối lại...""",
            cooldown_key='db_error',
            cooldown_seconds=120
        )

    async def alert_high_memory(self, current_mb: float, threshold_mb: float):
        """Alert on high memory usage."""
        percent = (current_mb / threshold_mb) * 100 if threshold_mb > 0 else 0
        await self.send_alert(
            'warning',
            'HIGH MEMORY',
            f"""💾 Memory: {current_mb:.0f}MB ({percent:.0f}%)

💡 Khuyến nghị:
• Kiểm tra memory leak
• Restart bot nếu cần""",
            cooldown_key='high_memory',
            cooldown_seconds=600
        )

    async def alert_high_cpu(self, current_percent: float):
        """Alert on high CPU usage."""
        await self.send_alert(
            'warning',
            'HIGH CPU',
            f"""🖥️ CPU: {current_percent:.0f}%

💡 Khuyến nghị:
• Kiểm tra process đang chạy
• Kiểm tra scheduled jobs""",
            cooldown_key='high_cpu',
            cooldown_seconds=600
        )

    async def alert_disk_low(self, free_gb: float, total_gb: float):
        """Alert on low disk space."""
        percent = (free_gb / total_gb) * 100 if total_gb > 0 else 0
        await self.send_alert(
            'critical',
            'LOW DISK SPACE',
            f"""💿 Disk: {free_gb:.1f}GB free / {total_gb:.1f}GB total ({percent:.0f}% free)

💡 Khuyến nghị:
• Xóa log cũ
• Xóa backup cũ""",
            cooldown_key='disk_low',
            cooldown_seconds=3600
        )

    async def alert_backup_status(self, success: bool, message: str = ""):
        """Alert on backup status."""
        if success:
            await self.send_alert(
                'success',
                'BACKUP SUCCESS',
                f"💾 Backup hoàn tất!\n\n{message}",
                cooldown_key='backup_success',
                cooldown_seconds=86400  # Once per day
            )
        else:
            await self.send_alert(
                'warning',
                'BACKUP FAILED',
                f"""💾 Backup thất bại!

❌ Lỗi: {message}""",
                cooldown_key='backup_failed',
                cooldown_seconds=3600
            )

    async def alert_overdue_tasks(self, count: int):
        """Alert on overdue tasks for current month (daily summary)."""
        if count > 0:
            await self.send_alert(
                'info',
                'OVERDUE TASKS',
                f"""📋 Có {count} việc quá hạn trong tháng này

Xem chi tiết: /viectrehan""",
                cooldown_key='overdue_tasks',
                cooldown_seconds=86400  # Once per day
            )

    async def send_admin_summary_report(self, stats: dict):
        """Send daily/weekly summary report to admins."""
        total_tasks = stats.get('total_tasks', 0)
        total_users = stats.get('total_users', 0)
        today_tasks = stats.get('today_tasks', 0)
        today_completed = stats.get('today_completed', 0)
        pending_tasks = stats.get('pending_tasks', 0)
        overdue_tasks = stats.get('overdue_tasks', 0)
        completion_rate = stats.get('completion_rate', 0)

        message = f"""📈 BÁO CÁO TỔNG HỢP

👥 Tổng người dùng: {total_users}
📋 Tổng số việc: {total_tasks}

📅 Hôm nay:
• Việc mới: {today_tasks}
• Đã hoàn thành: {today_completed}

📊 Trạng thái:
• Đang chờ: {pending_tasks}
• Quá hạn: {overdue_tasks}
• Tỷ lệ hoàn thành: {completion_rate:.1f}%"""

        await self.send_alert(
            'info',
            'ADMIN SUMMARY',
            message,
            cooldown_key='admin_summary',
            cooldown_seconds=86400  # Once per day
        )
</file>

<file path="monitoring/health_check.py">
"""
Health Check Server
HTTP endpoint for monitoring bot health status and report downloads
"""

import os
import logging
from datetime import datetime
from pathlib import Path
from aiohttp import web
import psutil
import pytz

logger = logging.getLogger(__name__)

TZ = pytz.timezone("Asia/Ho_Chi_Minh")


class HealthCheckServer:
    """HTTP server for health check and metrics endpoints."""

    def __init__(self, app, db, port: int = 8080):
        self.telegram_app = app
        self.db = db
        self.port = port
        self.start_time = datetime.now()
        self.runner = None

    async def start(self):
        """Start health check HTTP server."""
        web_app = web.Application()
        web_app.router.add_get('/health', self.health_handler)
        web_app.router.add_get('/metrics', self.metrics_handler)
        web_app.router.add_get('/report/{report_id}', self.report_page_handler)
        web_app.router.add_post('/report/{report_id}', self.report_download_handler)

        self.runner = web.AppRunner(web_app)
        await self.runner.setup()
        site = web.TCPSite(self.runner, '0.0.0.0', self.port)
        await site.start()
        logger.info(f"Health check server started on port {self.port}")

    async def stop(self):
        """Stop server."""
        if self.runner:
            await self.runner.cleanup()
            logger.info("Health check server stopped")

    async def health_handler(self, request):
        """Handle /health requests."""
        # Check database
        db_status = 'connected'
        try:
            await self.db.fetch_one("SELECT 1")
        except Exception as e:
            db_status = 'disconnected'
            logger.warning(f"Database health check failed: {e}")

        # Calculate uptime
        uptime = datetime.now() - self.start_time
        uptime_str = f"{uptime.days}d {uptime.seconds // 3600}h {(uptime.seconds % 3600) // 60}m"

        # Get process memory and CPU
        process = psutil.Process(os.getpid())
        memory_mb = process.memory_info().rss / 1024 / 1024
        cpu_percent = process.cpu_percent()

        # Get today's stats
        today_stats = await self._get_today_stats()

        return web.json_response({
            'status': 'healthy' if db_status == 'connected' else 'degraded',
            'bot_name': os.getenv('BOT_NAME', 'TeleTask'),
            'uptime': uptime_str,
            'uptime_seconds': int(uptime.total_seconds()),
            'memory_mb': round(memory_mb, 2),
            'cpu_percent': round(cpu_percent, 2),
            'database': db_status,
            'last_activity': datetime.now().isoformat(),
            'tasks_today': today_stats.get('tasks_created', 0),
            'completed_today': today_stats.get('completed', 0),
        })

    async def metrics_handler(self, request):
        """Handle /metrics requests (Prometheus format)."""
        try:
            from monitoring.metrics import get_metrics_text
            return web.Response(text=get_metrics_text(), content_type='text/plain')
        except ImportError:
            return web.Response(text="# Metrics not available", content_type='text/plain')

    async def _get_today_stats(self):
        """Get today's statistics."""
        try:
            result = await self.db.fetch_one("""
                SELECT
                    COUNT(*) FILTER (WHERE DATE(created_at AT TIME ZONE 'Asia/Ho_Chi_Minh') = CURRENT_DATE) as tasks_created,
                    COUNT(*) FILTER (WHERE status = 'completed' AND DATE(updated_at AT TIME ZONE 'Asia/Ho_Chi_Minh') = CURRENT_DATE) as completed
                FROM tasks WHERE is_deleted = false
            """)
            return dict(result) if result else {'tasks_created': 0, 'completed': 0}
        except Exception as e:
            logger.warning(f"Failed to get today stats: {e}")
            return {'tasks_created': 0, 'completed': 0}

    async def report_page_handler(self, request):
        """Serve password entry page for report download."""
        report_id = request.match_info.get('report_id', '')

        # Check if report exists and not expired
        try:
            from services.report_service import get_report_by_id
            report = await get_report_by_id(self.db, report_id)

            if not report:
                return web.Response(
                    text=self._error_page("Báo cáo không tồn tại", "Report not found"),
                    content_type='text/html',
                    status=404
                )

            now = datetime.now(TZ)
            if report['expires_at'].replace(tzinfo=TZ) < now:
                return web.Response(
                    text=self._error_page("Báo cáo đã hết hạn", "Report expired"),
                    content_type='text/html',
                    status=410
                )

            # Return password entry page
            return web.Response(
                text=self._password_page(report_id, report['file_format']),
                content_type='text/html'
            )

        except Exception as e:
            logger.error(f"Error in report_page_handler: {e}")
            return web.Response(
                text=self._error_page("Lỗi hệ thống", str(e)),
                content_type='text/html',
                status=500
            )

    async def report_download_handler(self, request):
        """Handle password verification and file download."""
        report_id = request.match_info.get('report_id', '')

        try:
            data = await request.post()
            password = data.get('password', '')

            from services.report_service import get_report_by_id, verify_password, increment_download_count
            report = await get_report_by_id(self.db, report_id)

            if not report:
                return web.Response(
                    text=self._error_page("Báo cáo không tồn tại", "Report not found"),
                    content_type='text/html',
                    status=404
                )

            now = datetime.now(TZ)
            if report['expires_at'].replace(tzinfo=TZ) < now:
                return web.Response(
                    text=self._error_page("Báo cáo đã hết hạn", "Report expired"),
                    content_type='text/html',
                    status=410
                )

            # Verify password
            if not verify_password(password, report['password_hash']):
                return web.Response(
                    text=self._password_page(report_id, report['file_format'], error="Mật khẩu không đúng"),
                    content_type='text/html',
                    status=401
                )

            # Serve the file
            file_path = Path(report['file_path'])
            if not file_path.exists():
                return web.Response(
                    text=self._error_page("File không tồn tại", "File not found"),
                    content_type='text/html',
                    status=404
                )

            # Increment download count
            await increment_download_count(self.db, report_id)

            # Determine content type
            content_types = {
                'csv': 'text/csv',
                'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                'pdf': 'application/pdf',
            }
            content_type = content_types.get(report['file_format'], 'application/octet-stream')

            # Create filename
            timestamp = datetime.now(TZ).strftime('%Y%m%d_%H%M')
            filename = f"teletask_report_{timestamp}.{report['file_format']}"

            # Read and return file
            with open(file_path, 'rb') as f:
                file_content = f.read()

            return web.Response(
                body=file_content,
                content_type=content_type,
                headers={
                    'Content-Disposition': f'attachment; filename="{filename}"'
                }
            )

        except Exception as e:
            logger.error(f"Error in report_download_handler: {e}")
            return web.Response(
                text=self._error_page("Lỗi tải file", str(e)),
                content_type='text/html',
                status=500
            )

    def _password_page(self, report_id: str, file_format: str, error: str = None) -> str:
        """Generate MacOS-style password entry HTML page."""
        error_html = f'<div class="error-banner"><span class="error-icon">⚠️</span>{error}</div>' if error else ''
        format_icons = {'csv': '📄', 'xlsx': '📊', 'pdf': '📑'}
        format_names = {'csv': 'CSV', 'xlsx': 'Excel', 'pdf': 'PDF'}

        return f'''<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TeleTask - Tải báo cáo</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', sans-serif;
            background: linear-gradient(180deg, #f5f5f7 0%, #e8e8ed 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            -webkit-font-smoothing: antialiased;
        }}
        .macos-window {{
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 12px;
            max-width: 380px;
            width: 100%;
            box-shadow: 0 22px 70px 4px rgba(0,0,0,0.15), 0 0 0 1px rgba(0,0,0,0.05);
            overflow: hidden;
        }}
        .window-header {{
            background: linear-gradient(180deg, #e8e8e8 0%, #d6d6d6 100%);
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }}
        .traffic-lights {{
            display: flex;
            gap: 8px;
        }}
        .traffic-light {{
            width: 12px;
            height: 12px;
            border-radius: 50%;
            box-shadow: inset 0 0 0 1px rgba(0,0,0,0.1);
        }}
        .light-close {{ background: #ff5f57; }}
        .light-minimize {{ background: #febc2e; }}
        .light-maximize {{ background: #28c840; }}
        .window-title {{
            flex: 1;
            text-align: center;
            font-size: 13px;
            font-weight: 500;
            color: #4d4d4d;
            margin-right: 52px;
        }}
        .window-content {{
            padding: 30px;
        }}
        .app-icon {{
            text-align: center;
            margin-bottom: 16px;
        }}
        .app-icon-img {{
            width: 64px;
            height: 64px;
            background: linear-gradient(180deg, #007aff 0%, #0055d4 100%);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            margin: 0 auto;
            box-shadow: 0 4px 12px rgba(0,122,255,0.3);
        }}
        .app-title {{
            text-align: center;
            margin-bottom: 24px;
        }}
        .app-title h1 {{
            font-size: 18px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 4px;
        }}
        .app-title p {{
            font-size: 13px;
            color: #86868b;
        }}
        .file-badge {{
            background: #f5f5f7;
            border-radius: 8px;
            padding: 14px;
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            border: 1px solid rgba(0,0,0,0.04);
        }}
        .file-badge-icon {{
            font-size: 28px;
        }}
        .file-badge-info {{
            flex: 1;
        }}
        .file-badge-type {{
            font-size: 13px;
            font-weight: 600;
            color: #1d1d1f;
        }}
        .file-badge-desc {{
            font-size: 11px;
            color: #86868b;
        }}
        .error-banner {{
            background: #fff2f2;
            border: 1px solid #ffcdd2;
            border-radius: 8px;
            padding: 10px 12px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #c62828;
        }}
        .error-icon {{
            font-size: 14px;
        }}
        .form-group {{
            margin-bottom: 16px;
        }}
        .form-label {{
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: #1d1d1f;
            margin-bottom: 6px;
        }}
        .form-input {{
            width: 100%;
            padding: 10px 12px;
            font-size: 15px;
            border: 1px solid #d2d2d7;
            border-radius: 8px;
            background: #fff;
            transition: all 0.2s;
            font-family: inherit;
        }}
        .form-input:focus {{
            outline: none;
            border-color: #007aff;
            box-shadow: 0 0 0 3px rgba(0,122,255,0.2);
        }}
        .btn-primary {{
            width: 100%;
            padding: 10px 20px;
            font-size: 15px;
            font-weight: 500;
            color: #fff;
            background: linear-gradient(180deg, #007aff 0%, #0055d4 100%);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }}
        .btn-primary:hover {{
            background: linear-gradient(180deg, #0077ed 0%, #004fc4 100%);
            transform: scale(1.01);
        }}
        .btn-primary:active {{
            transform: scale(0.99);
        }}
        .footer-note {{
            text-align: center;
            margin-top: 16px;
            font-size: 11px;
            color: #86868b;
        }}
    </style>
</head>
<body>
    <div class="macos-window">
        <div class="window-header">
            <div class="traffic-lights">
                <div class="traffic-light light-close"></div>
                <div class="traffic-light light-minimize"></div>
                <div class="traffic-light light-maximize"></div>
            </div>
            <div class="window-title">TeleTask Report</div>
        </div>
        <div class="window-content">
            <div class="app-icon">
                <div class="app-icon-img">📋</div>
            </div>
            <div class="app-title">
                <h1>Tải báo cáo</h1>
                <p>Nhập mật khẩu để tải xuống file</p>
            </div>
            <div class="file-badge">
                <div class="file-badge-icon">{format_icons.get(file_format, '📄')}</div>
                <div class="file-badge-info">
                    <div class="file-badge-type">Báo cáo {format_names.get(file_format, file_format.upper())}</div>
                    <div class="file-badge-desc">Thống kê công việc TeleTask</div>
                </div>
            </div>
            {error_html}
            <form method="post">
                <div class="form-group">
                    <label class="form-label" for="password">Mật khẩu</label>
                    <input type="password" id="password" name="password" class="form-input" placeholder="Nhập mật khẩu..." required autofocus>
                </div>
                <button type="submit" class="btn-primary">Tải xuống</button>
            </form>
            <p class="footer-note">Link hết hạn sau 72 giờ</p>
        </div>
    </div>
</body>
</html>'''

    def _error_page(self, title: str, message: str) -> str:
        """Generate MacOS-style error HTML page."""
        return f'''<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TeleTask - Lỗi</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', sans-serif;
            background: linear-gradient(180deg, #f5f5f7 0%, #e8e8ed 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            -webkit-font-smoothing: antialiased;
        }}
        .macos-window {{
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 12px;
            max-width: 340px;
            width: 100%;
            box-shadow: 0 22px 70px 4px rgba(0,0,0,0.15), 0 0 0 1px rgba(0,0,0,0.05);
            overflow: hidden;
        }}
        .window-header {{
            background: linear-gradient(180deg, #e8e8e8 0%, #d6d6d6 100%);
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }}
        .traffic-lights {{
            display: flex;
            gap: 8px;
        }}
        .traffic-light {{
            width: 12px;
            height: 12px;
            border-radius: 50%;
            box-shadow: inset 0 0 0 1px rgba(0,0,0,0.1);
        }}
        .light-close {{ background: #ff5f57; }}
        .light-minimize {{ background: #febc2e; }}
        .light-maximize {{ background: #28c840; }}
        .window-title {{
            flex: 1;
            text-align: center;
            font-size: 13px;
            font-weight: 500;
            color: #4d4d4d;
            margin-right: 52px;
        }}
        .window-content {{
            padding: 30px;
            text-align: center;
        }}
        .error-icon {{
            width: 64px;
            height: 64px;
            background: linear-gradient(180deg, #ff3b30 0%, #d32f2f 100%);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            margin: 0 auto 16px;
            box-shadow: 0 4px 12px rgba(255,59,48,0.3);
        }}
        h1 {{
            font-size: 18px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 8px;
        }}
        .message {{
            font-size: 13px;
            color: #86868b;
            line-height: 1.5;
        }}
    </style>
</head>
<body>
    <div class="macos-window">
        <div class="window-header">
            <div class="traffic-lights">
                <div class="traffic-light light-close"></div>
                <div class="traffic-light light-minimize"></div>
                <div class="traffic-light light-maximize"></div>
            </div>
            <div class="window-title">TeleTask</div>
        </div>
        <div class="window-content">
            <div class="error-icon">❌</div>
            <h1>{title}</h1>
            <p class="message">{message}</p>
        </div>
    </div>
</body>
</html>'''
</file>

<file path="monitoring/metrics.py">
"""
Prometheus Metrics
Export metrics in Prometheus format for monitoring
"""

import os
import time
import logging
from datetime import datetime

logger = logging.getLogger(__name__)

# Try to import prometheus_client, make it optional
try:
    from prometheus_client import Counter, Gauge, CollectorRegistry, generate_latest
    PROMETHEUS_AVAILABLE = True
except ImportError:
    PROMETHEUS_AVAILABLE = False
    logger.warning("prometheus_client not installed, metrics will be basic text")

# Metrics storage (fallback when prometheus_client not available)
_metrics = {
    'tasks_created': 0,
    'tasks_completed': 0,
    'messages_received': 0,
    'messages_sent': 0,
    'errors': {},
    'uptime_start': time.time(),
    'memory_bytes': 0,
    'cpu_percent': 0,
}

if PROMETHEUS_AVAILABLE:
    # Create custom registry
    REGISTRY = CollectorRegistry()

    # Bot metrics
    BOT_UPTIME = Gauge(
        'bot_uptime_seconds',
        'Bot uptime in seconds',
        ['bot_name'],
        registry=REGISTRY
    )

    BOT_MEMORY = Gauge(
        'bot_memory_bytes',
        'Bot memory usage in bytes',
        ['bot_name'],
        registry=REGISTRY
    )

    BOT_CPU = Gauge(
        'bot_cpu_percent',
        'Bot CPU usage percentage',
        ['bot_name'],
        registry=REGISTRY
    )

    # Task metrics
    TASKS_CREATED = Counter(
        'tasks_created_total',
        'Total tasks created',
        ['bot_name'],
        registry=REGISTRY
    )

    TASKS_COMPLETED = Counter(
        'tasks_completed_total',
        'Total tasks completed',
        ['bot_name'],
        registry=REGISTRY
    )

    TASKS_OVERDUE = Gauge(
        'tasks_overdue_current',
        'Current overdue tasks',
        ['bot_name'],
        registry=REGISTRY
    )

    # Message metrics
    MESSAGES_RECEIVED = Counter(
        'messages_received_total',
        'Total messages received',
        ['bot_name'],
        registry=REGISTRY
    )

    MESSAGES_SENT = Counter(
        'messages_sent_total',
        'Total messages sent',
        ['bot_name'],
        registry=REGISTRY
    )

    # Error metrics
    ERRORS_TOTAL = Counter(
        'errors_total',
        'Total errors',
        ['bot_name', 'error_type'],
        registry=REGISTRY
    )


def get_bot_name() -> str:
    """Get bot name from environment."""
    return os.getenv('BOT_NAME', 'TeleTask')


def get_metrics_text() -> str:
    """Generate metrics text in Prometheus format."""
    if PROMETHEUS_AVAILABLE:
        return generate_latest(REGISTRY).decode('utf-8')
    else:
        # Fallback: basic text format
        bot_name = get_bot_name()
        uptime = time.time() - _metrics['uptime_start']
        lines = [
            f"# HELP bot_uptime_seconds Bot uptime in seconds",
            f"# TYPE bot_uptime_seconds gauge",
            f'bot_uptime_seconds{{bot_name="{bot_name}"}} {uptime:.2f}',
            f"# HELP tasks_created_total Total tasks created",
            f"# TYPE tasks_created_total counter",
            f'tasks_created_total{{bot_name="{bot_name}"}} {_metrics["tasks_created"]}',
            f"# HELP tasks_completed_total Total tasks completed",
            f"# TYPE tasks_completed_total counter",
            f'tasks_completed_total{{bot_name="{bot_name}"}} {_metrics["tasks_completed"]}',
            f"# HELP messages_received_total Total messages received",
            f"# TYPE messages_received_total counter",
            f'messages_received_total{{bot_name="{bot_name}"}} {_metrics["messages_received"]}',
            f"# HELP bot_memory_bytes Bot memory usage",
            f"# TYPE bot_memory_bytes gauge",
            f'bot_memory_bytes{{bot_name="{bot_name}"}} {_metrics["memory_bytes"]}',
        ]
        return '\n'.join(lines)


def record_task_created():
    """Record task creation."""
    bot_name = get_bot_name()
    if PROMETHEUS_AVAILABLE:
        TASKS_CREATED.labels(bot_name=bot_name).inc()
    else:
        _metrics['tasks_created'] += 1


def record_task_completed():
    """Record task completion."""
    bot_name = get_bot_name()
    if PROMETHEUS_AVAILABLE:
        TASKS_COMPLETED.labels(bot_name=bot_name).inc()
    else:
        _metrics['tasks_completed'] += 1


def record_message_received():
    """Record message received."""
    bot_name = get_bot_name()
    if PROMETHEUS_AVAILABLE:
        MESSAGES_RECEIVED.labels(bot_name=bot_name).inc()
    else:
        _metrics['messages_received'] += 1


def record_message_sent():
    """Record message sent."""
    bot_name = get_bot_name()
    if PROMETHEUS_AVAILABLE:
        MESSAGES_SENT.labels(bot_name=bot_name).inc()
    else:
        _metrics['messages_sent'] += 1


def record_error(error_type: str):
    """Record error occurrence."""
    bot_name = get_bot_name()
    if PROMETHEUS_AVAILABLE:
        ERRORS_TOTAL.labels(bot_name=bot_name, error_type=error_type).inc()
    else:
        _metrics['errors'][error_type] = _metrics['errors'].get(error_type, 0) + 1


def update_system_metrics(uptime: float, memory: float, cpu: float):
    """Update system resource metrics."""
    bot_name = get_bot_name()
    if PROMETHEUS_AVAILABLE:
        BOT_UPTIME.labels(bot_name=bot_name).set(uptime)
        BOT_MEMORY.labels(bot_name=bot_name).set(memory)
        BOT_CPU.labels(bot_name=bot_name).set(cpu)
    else:
        _metrics['memory_bytes'] = memory
        _metrics['cpu_percent'] = cpu


def update_overdue_tasks(count: int):
    """Update overdue tasks count."""
    bot_name = get_bot_name()
    if PROMETHEUS_AVAILABLE:
        TASKS_OVERDUE.labels(bot_name=bot_name).set(count)
</file>

<file path="monitoring/resource_monitor.py">
"""
Resource Monitor
Monitor system resources and trigger alerts
"""

import os
import asyncio
import logging
from datetime import datetime

import psutil

logger = logging.getLogger(__name__)


class ResourceMonitor:
    """Monitor system resources and send alerts."""

    def __init__(self, db, alert_service, start_time: datetime):
        self.db = db
        self.alert_service = alert_service
        self.start_time = start_time
        self.running = False
        self.task = None

        # Thresholds (configurable via env)
        self.memory_threshold_mb = float(os.getenv('MEMORY_THRESHOLD_MB', 500))
        self.cpu_threshold = float(os.getenv('CPU_THRESHOLD', 90))
        self.disk_threshold_percent = float(os.getenv('DISK_THRESHOLD_PERCENT', 10))
        self.check_interval = int(os.getenv('MONITOR_INTERVAL', 60))

    async def start(self):
        """Start monitoring loop."""
        self.running = True
        self.task = asyncio.create_task(self._monitor_loop())
        logger.info("Resource monitor started")

    async def stop(self):
        """Stop monitoring."""
        self.running = False
        if self.task:
            self.task.cancel()
            try:
                await self.task
            except asyncio.CancelledError:
                pass
        logger.info("Resource monitor stopped")

    async def _monitor_loop(self):
        """Main monitoring loop."""
        while self.running:
            try:
                await self.check_resources()
                await asyncio.sleep(self.check_interval)
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in monitor loop: {e}")
                await asyncio.sleep(self.check_interval)

    async def check_resources(self):
        """Check system resources and alert if needed."""
        try:
            # Get current process
            process = psutil.Process(os.getpid())

            # Memory check
            memory_mb = process.memory_info().rss / 1024 / 1024
            if memory_mb > self.memory_threshold_mb:
                await self.alert_service.alert_high_memory(memory_mb, self.memory_threshold_mb)

            # CPU check (system-wide)
            cpu_percent = psutil.cpu_percent(interval=1)
            if cpu_percent > self.cpu_threshold:
                await self.alert_service.alert_high_cpu(cpu_percent)

            # Disk check
            disk = psutil.disk_usage('/')
            free_percent = (disk.free / disk.total) * 100
            if free_percent < self.disk_threshold_percent:
                await self.alert_service.alert_disk_low(
                    disk.free / 1024 / 1024 / 1024,
                    disk.total / 1024 / 1024 / 1024
                )

            # Update Prometheus metrics
            from monitoring.metrics import update_system_metrics
            uptime = (datetime.now() - self.start_time).total_seconds()
            update_system_metrics(
                uptime,
                process.memory_info().rss,
                process.cpu_percent()
            )

            # Overdue task check disabled - use /viectrehan command instead
            # await self._check_overdue_tasks()

        except Exception as e:
            logger.error(f"Error checking resources: {e}")

    async def _check_overdue_tasks(self):
        """Check and alert for overdue tasks (current month only)."""
        try:
            # Only count overdue tasks from current month
            result = await self.db.fetch_one("""
                SELECT COUNT(*) as count
                FROM tasks
                WHERE is_deleted = false
                AND status != 'completed'
                AND deadline < NOW()
                AND deadline >= DATE_TRUNC('month', NOW())
            """)
            overdue_count = result['count'] if result else 0

            # Update metric
            from monitoring.metrics import update_overdue_tasks
            update_overdue_tasks(overdue_count)

            # Alert if there are overdue tasks (once per day)
            if overdue_count > 0:
                await self.alert_service.alert_overdue_tasks(overdue_count)

        except Exception as e:
            logger.warning(f"Error checking overdue tasks: {e}")

    def get_status(self) -> dict:
        """Get current resource status."""
        process = psutil.Process(os.getpid())
        disk = psutil.disk_usage('/')

        return {
            'memory_mb': round(process.memory_info().rss / 1024 / 1024, 2),
            'cpu_percent': round(process.cpu_percent(), 2),
            'disk_free_gb': round(disk.free / 1024 / 1024 / 1024, 2),
            'disk_total_gb': round(disk.total / 1024 / 1024 / 1024, 2),
            'uptime_seconds': (datetime.now() - self.start_time).total_seconds(),
        }
</file>

<file path="scheduler/__init__.py">
"""
Scheduler Module
APScheduler-based task scheduling

Schedulers:
- reminder_scheduler: Handles task reminder notifications
- report_scheduler: Handles weekly/monthly report generation
"""

from .reminder_scheduler import (
    ReminderScheduler,
    reminder_scheduler,
    init_scheduler,
    stop_scheduler,
)

from .report_scheduler import (
    ReportScheduler,
    report_scheduler,
    init_report_scheduler,
)

__all__ = [
    "ReminderScheduler",
    "reminder_scheduler",
    "init_scheduler",
    "stop_scheduler",
    "ReportScheduler",
    "report_scheduler",
    "init_report_scheduler",
]
</file>

<file path="scheduler/reminder_scheduler.py">
"""
Reminder Scheduler
APScheduler-based reminder system for task deadlines
"""

import logging
from datetime import datetime
from typing import Optional

from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from apscheduler.triggers.date import DateTrigger
import pytz

logger = logging.getLogger(__name__)

TZ = pytz.timezone("Asia/Ho_Chi_Minh")


class ReminderScheduler:
    """Manages scheduled reminders for tasks."""

    def __init__(self):
        self.scheduler: Optional[AsyncIOScheduler] = None
        self.bot = None
        self.db = None

    def start(self, bot, db) -> None:
        """
        Initialize and start the scheduler.

        Args:
            bot: Telegram bot instance
            db: Database connection
        """
        self.bot = bot
        self.db = db

        self.scheduler = AsyncIOScheduler(timezone=TZ)

        # Process pending reminders every minute
        self.scheduler.add_job(
            self._process_pending_reminders,
            CronTrigger(minute="*"),
            id="process_reminders",
            replace_existing=True,
        )

        # Cleanup expired undo records every 5 minutes
        self.scheduler.add_job(
            self._cleanup_expired_undo,
            CronTrigger(minute="*/5"),
            id="cleanup_undo",
            replace_existing=True,
        )

        # Process recurring task templates every 5 minutes
        self.scheduler.add_job(
            self._process_recurring_templates,
            CronTrigger(minute="*/5"),
            id="process_recurring",
            replace_existing=True,
        )

        self.scheduler.start()
        logger.info("Reminder scheduler started")

    def stop(self) -> None:
        """Stop the scheduler."""
        if self.scheduler:
            self.scheduler.shutdown(wait=False)
            logger.info("Reminder scheduler stopped")

    async def _process_pending_reminders(self) -> None:
        """Process all pending reminders due now."""
        from services.reminder_service import get_pending_reminders, mark_reminder_sent
        from services.notification import send_reminder_notification

        try:
            reminders = await get_pending_reminders(self.db)

            for reminder in reminders:
                try:
                    await send_reminder_notification(self.bot, reminder)
                    await mark_reminder_sent(self.db, reminder["id"])
                    logger.info(f"Sent reminder {reminder['id']} for task {reminder.get('public_id')}")
                except Exception as e:
                    logger.error(f"Failed to send reminder {reminder['id']}: {e}")
                    await mark_reminder_sent(self.db, reminder["id"], error=str(e))

        except Exception as e:
            logger.error(f"Error processing reminders: {e}")

    async def _cleanup_expired_undo(self) -> None:
        """Clean up expired undo records."""
        try:
            await self.db.execute(
                """
                DELETE FROM deleted_tasks_undo
                WHERE expires_at < CURRENT_TIMESTAMP AND is_restored = false
                """
            )
        except Exception as e:
            logger.error(f"Error cleaning up undo records: {e}")

    async def _process_recurring_templates(self) -> None:
        """Process recurring templates and generate tasks."""
        from services.recurring_service import get_due_templates, generate_task_from_template

        try:
            templates = await get_due_templates(self.db)

            for template in templates:
                try:
                    task = await generate_task_from_template(self.db, template)
                    if task:
                        # Notify creator about new task
                        try:
                            await self.bot.send_message(
                                chat_id=template["creator_telegram_id"],
                                text=(
                                    f"🔄 *VIỆC LẶP LẠI TỰ ĐỘNG*\n\n"
                                    f"Đã tạo việc mới từ mẫu `{template['public_id']}`:\n\n"
                                    f"🆔 `{task['public_id']}`\n"
                                    f"📝 {task['content'][:100]}\n"
                                    f"⏰ Deadline: {task['deadline'].strftime('%H:%M %d/%m') if task.get('deadline') else 'N/A'}"
                                ),
                                parse_mode="Markdown",
                            )
                        except Exception as notify_err:
                            logger.warning(f"Failed to notify recurring task creation: {notify_err}")

                        logger.info(f"Generated task {task['public_id']} from template {template['public_id']}")
                except Exception as e:
                    logger.error(f"Failed to generate task from template {template.get('public_id')}: {e}")

        except Exception as e:
            logger.error(f"Error processing recurring templates: {e}")

    def add_custom_reminder(
        self,
        task_id: int,
        user_id: int,
        remind_at: datetime,
    ) -> str:
        """
        Add a custom reminder job.

        Args:
            task_id: Task internal ID
            user_id: User internal ID
            remind_at: When to send reminder

        Returns:
            Job ID
        """
        job_id = f"custom_{task_id}_{user_id}_{int(remind_at.timestamp())}"

        self.scheduler.add_job(
            self._send_single_reminder,
            DateTrigger(run_date=remind_at, timezone=TZ),
            args=[task_id, user_id],
            id=job_id,
            replace_existing=True,
        )

        logger.info(f"Scheduled custom reminder {job_id} at {remind_at}")
        return job_id

    async def _send_single_reminder(self, task_id: int, user_id: int) -> None:
        """Send a single custom reminder."""
        from services.notification import send_reminder_by_task

        try:
            await send_reminder_by_task(self.bot, self.db, task_id, user_id)
        except Exception as e:
            logger.error(f"Failed to send custom reminder for task {task_id}: {e}")

    def cancel_reminder(self, job_id: str) -> bool:
        """
        Cancel a scheduled reminder.

        Args:
            job_id: The job ID to cancel

        Returns:
            True if cancelled, False if not found
        """
        try:
            self.scheduler.remove_job(job_id)
            logger.info(f"Cancelled reminder job {job_id}")
            return True
        except Exception:
            return False


# Global scheduler instance
reminder_scheduler = ReminderScheduler()


def init_scheduler(bot, db) -> None:
    """Initialize the global reminder scheduler."""
    reminder_scheduler.start(bot, db)


def stop_scheduler() -> None:
    """Stop the global reminder scheduler."""
    reminder_scheduler.stop()
</file>

<file path="scheduler/report_scheduler.py">
"""
Report Scheduler
Weekly and monthly report jobs
"""

import os
import logging
from datetime import datetime, timedelta

from apscheduler.triggers.cron import CronTrigger
import pytz

from services.statistics_service import (
    calculate_user_stats,
    store_user_stats,
    get_week_range,
    get_previous_week_range,
    get_month_range,
    get_previous_month_range,
    get_group_rankings,
    get_active_users_for_report,
    get_user_groups,
)
from utils.formatters import format_weekly_report, format_monthly_report

logger = logging.getLogger(__name__)

TZ = pytz.timezone("Asia/Ho_Chi_Minh")


class ReportScheduler:
    """Report scheduler for weekly and monthly reports."""

    def __init__(self):
        self.scheduler = None
        self.bot = None
        self.db = None
        self.admin_ids = []

    def start(self, scheduler, bot, db) -> None:
        """Register report jobs with the scheduler."""
        self.scheduler = scheduler
        self.bot = bot
        self.db = db

        # Parse admin IDs (support both personal and group IDs)
        admin_ids_str = os.getenv('ADMIN_IDS', '')
        for x in admin_ids_str.split(','):
            x = x.strip()
            if x.lstrip('-').isdigit() and x:
                self.admin_ids.append(int(x))

        # Weekly report: Saturday 17:00
        self.scheduler.add_job(
            self._send_weekly_reports,
            CronTrigger(day_of_week="sat", hour=17, minute=0, timezone=TZ),
            id="weekly_reports",
            replace_existing=True,
        )

        # Monthly report: Last day of month 17:00
        self.scheduler.add_job(
            self._send_monthly_reports,
            CronTrigger(day="last", hour=17, minute=0, timezone=TZ),
            id="monthly_reports",
            replace_existing=True,
        )

        # Admin daily summary: Every day at 08:00
        if self.admin_ids:
            self.scheduler.add_job(
                self._send_admin_summary,
                CronTrigger(hour=8, minute=0, timezone=TZ),
                id="admin_daily_summary",
                replace_existing=True,
            )
            logger.info(f"Admin summary scheduled for {len(self.admin_ids)} recipients")

        logger.info("Report scheduler jobs registered")

    async def _send_weekly_reports(self) -> None:
        """Send weekly reports to all active users."""
        logger.info("Starting weekly report generation")

        week_start, week_end = get_week_range()
        prev_start, prev_end = get_previous_week_range()

        users = await get_active_users_for_report(self.db, "weekly")
        logger.info(f"Sending weekly reports to {len(users)} users")

        success_count = 0
        for user in users:
            try:
                # Calculate stats
                stats = await calculate_user_stats(
                    self.db, user["id"], "weekly", week_start, week_end
                )

                # Previous week for comparison
                prev_stats = await calculate_user_stats(
                    self.db, user["id"], "weekly", prev_start, prev_end
                )

                # Get groups user belongs to
                groups = await get_user_groups(self.db, user["id"])

                # Get ranking in each group
                group_rankings = {}
                for group in groups:
                    rankings = await get_group_rankings(
                        self.db, group["id"], "weekly", week_start
                    )
                    for i, r in enumerate(rankings):
                        if r["user_id"] == user["id"]:
                            group_rankings[group["title"]] = (i + 1, len(rankings))
                            break

                # Format and send report
                text = format_weekly_report(
                    user["display_name"] or user["username"] or "Ban",
                    stats,
                    week_start,
                    week_end,
                    group_rankings=group_rankings,
                    prev_stats=prev_stats,
                )

                await self.bot.send_message(chat_id=user["telegram_id"], text=text)

                # Store stats
                await store_user_stats(
                    self.db, user["id"], None, "weekly", stats, week_start, week_end
                )

                success_count += 1

            except Exception as e:
                logger.error(f"Error sending weekly report to user {user['id']}: {e}")

        logger.info(f"Weekly reports sent: {success_count}/{len(users)}")

    async def _send_monthly_reports(self) -> None:
        """Send monthly reports to all active users."""
        logger.info("Starting monthly report generation")

        month_start, month_end = get_month_range()
        prev_start, prev_end = get_previous_month_range()

        users = await get_active_users_for_report(self.db, "monthly")
        logger.info(f"Sending monthly reports to {len(users)} users")

        success_count = 0
        for user in users:
            try:
                stats = await calculate_user_stats(
                    self.db, user["id"], "monthly", month_start, month_end
                )

                prev_stats = await calculate_user_stats(
                    self.db, user["id"], "monthly", prev_start, prev_end
                )

                text = format_monthly_report(
                    user["display_name"] or user["username"] or "Ban",
                    stats,
                    prev_stats,
                    month_start,
                    month_end,
                )

                await self.bot.send_message(chat_id=user["telegram_id"], text=text)

                await store_user_stats(
                    self.db, user["id"], None, "monthly", stats, month_start, month_end
                )

                success_count += 1

            except Exception as e:
                logger.error(f"Error sending monthly report to user {user['id']}: {e}")

        logger.info(f"Monthly reports sent: {success_count}/{len(users)}")

    async def _send_admin_summary(self) -> None:
        """Send daily summary report to admins (personal or group)."""
        if not self.admin_ids:
            return

        logger.info("Starting admin daily summary generation")

        try:
            now = datetime.now(TZ)
            today_start = now.replace(hour=0, minute=0, second=0, microsecond=0)

            # Get overall statistics
            total_stats = await self.db.fetch_one("""
                SELECT
                    COUNT(*) as total_tasks,
                    COUNT(*) FILTER (WHERE status = 'pending') as pending_tasks,
                    COUNT(*) FILTER (WHERE status = 'completed') as completed_tasks,
                    COUNT(*) FILTER (WHERE status != 'completed' AND deadline < NOW()) as overdue_tasks,
                    COUNT(*) FILTER (WHERE created_at >= $1) as today_tasks,
                    COUNT(*) FILTER (WHERE completed_at >= $1) as today_completed
                FROM tasks
                WHERE is_deleted = false
            """, today_start)

            total_users = await self.db.fetch_one(
                "SELECT COUNT(*) as count FROM users"
            )

            # Calculate completion rate
            total = total_stats['total_tasks'] or 0
            completed = total_stats['completed_tasks'] or 0
            completion_rate = (completed / total * 100) if total > 0 else 0

            # Format message
            bot_name = os.getenv('BOT_NAME', 'TeleTask')
            message = f"""📊 BÁO CÁO TỔNG HỢP - {bot_name}
📅 Ngày: {now.strftime('%d/%m/%Y')}

👥 Tổng người dùng: {total_users['count']}
📋 Tổng số việc: {total}

📅 Hôm nay:
• Việc mới: {total_stats['today_tasks'] or 0}
• Đã hoàn thành: {total_stats['today_completed'] or 0}

📊 Trạng thái tổng:
• Đang chờ: {total_stats['pending_tasks'] or 0}
• Đã hoàn thành: {completed}
• Quá hạn: {total_stats['overdue_tasks'] or 0}
• Tỷ lệ hoàn thành: {completion_rate:.1f}%"""

            # Send to all admin IDs (personal or group)
            sent_count = 0
            for admin_id in self.admin_ids:
                try:
                    await self.bot.send_message(chat_id=admin_id, text=message)
                    sent_count += 1
                except Exception as e:
                    logger.warning(f"Failed to send admin summary to {admin_id}: {e}")

            logger.info(f"Admin summary sent to {sent_count}/{len(self.admin_ids)} recipients")

        except Exception as e:
            logger.error(f"Error generating admin summary: {e}")


# Global instance
report_scheduler = ReportScheduler()


def init_report_scheduler(scheduler, bot, db) -> None:
    """Initialize report scheduler."""
    report_scheduler.start(scheduler, bot, db)
</file>

<file path="services/__init__.py">
"""
Bot Services Module
Business logic and data access services

Services:
- user_service: User CRUD operations
- task_service: Task CRUD operations
- time_parser: Vietnamese time parsing
- reminder_service: Reminder management
- notification: Send notifications
"""

from .time_parser import (
    VietnameseTimeParser,
    parse_vietnamese_time,
)

from .user_service import (
    get_or_create_user,
    get_user_by_telegram_id,
    get_user_by_id,
    get_user_by_username,
    find_users_by_mention,
    update_user_settings,
    get_or_create_group,
    add_group_member,
)

from .task_service import (
    generate_task_id,
    create_task,
    get_task_by_public_id,
    get_task_by_id,
    get_user_tasks,
    get_user_created_tasks,
    get_user_received_tasks,
    get_user_personal_tasks,
    get_all_user_related_tasks,
    get_group_tasks,
    update_task_status,
    update_task_progress,
    update_task_content,
    update_task_deadline,
    update_task_priority,
    update_task_assignee,
    soft_delete_task,
    restore_task,
    add_task_history,
    create_default_reminders,
    get_tasks_with_deadline,
    # Group task functions (G-ID/P-ID system)
    create_group_task,
    get_group_task_progress,
    get_child_tasks,
    check_and_complete_group_task,
    is_group_task,
    convert_individual_to_group,
    update_group_assignees,
    # Bulk delete functions
    get_tasks_created_by_user,
    get_tasks_assigned_to_others,
    bulk_delete_tasks,
    bulk_soft_delete_with_undo,
    bulk_restore_tasks,
)

from .recurring_service import (
    create_recurring_template,
    get_recurring_template,
    get_user_recurring_templates,
    get_due_templates,
    generate_task_from_template,
    toggle_recurring_template,
    delete_recurring_template,
    parse_recurrence_pattern,
    format_recurrence_description,
)

from .report_service import (
    create_export_report,
    get_report_by_id,
    increment_download_count,
    cleanup_expired_reports,
    verify_password as verify_report_password,
    REPORT_TTL_HOURS,
)

# Reminder and notification services are imported directly where needed
# to avoid circular imports with scheduler

__all__ = [
    # Time parser
    "VietnameseTimeParser",
    "parse_vietnamese_time",
    # User service
    "get_or_create_user",
    "get_user_by_telegram_id",
    "get_user_by_id",
    "get_user_by_username",
    "find_users_by_mention",
    "update_user_settings",
    "get_or_create_group",
    "add_group_member",
    # Task service
    "generate_task_id",
    "create_task",
    "get_task_by_public_id",
    "get_task_by_id",
    "get_user_tasks",
    "get_user_created_tasks",
    "get_user_received_tasks",
    "get_user_personal_tasks",
    "get_all_user_related_tasks",
    "get_group_tasks",
    "update_task_status",
    "update_task_progress",
    "update_task_content",
    "update_task_deadline",
    "update_task_priority",
    "update_task_assignee",
    "soft_delete_task",
    "restore_task",
    "add_task_history",
    "create_default_reminders",
    "get_tasks_with_deadline",
    # Group task functions
    "create_group_task",
    "get_group_task_progress",
    "get_child_tasks",
    "check_and_complete_group_task",
    "is_group_task",
    "convert_individual_to_group",
    "update_group_assignees",
    # Bulk delete functions
    "get_tasks_created_by_user",
    "get_tasks_assigned_to_others",
    "bulk_delete_tasks",
    "bulk_soft_delete_with_undo",
    "bulk_restore_tasks",
    # Recurring service
    "create_recurring_template",
    "get_recurring_template",
    "get_user_recurring_templates",
    "get_due_templates",
    "generate_task_from_template",
    "toggle_recurring_template",
    "delete_recurring_template",
    "parse_recurrence_pattern",
    "format_recurrence_description",
    # Report service
    "create_export_report",
    "get_report_by_id",
    "increment_download_count",
    "cleanup_expired_reports",
    "verify_report_password",
    "REPORT_TTL_HOURS",
]
</file>

<file path="services/calendar_service.py">
"""
Google Calendar Service
Per-user calendar integration for task sync
"""

import base64
import hashlib
import hmac
import json
import logging
import os
import secrets
import time
from datetime import datetime, timedelta
from typing import Any, Dict, Optional, Tuple

from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import Flow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

logger = logging.getLogger(__name__)

# OAuth 2.0 scopes
SCOPES = ["https://www.googleapis.com/auth/calendar.events"]

# Environment variables for OAuth
GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID", "")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET", "")
GOOGLE_REDIRECT_URI = os.getenv("GOOGLE_REDIRECT_URI", "")

# Secret for signing OAuth state (must be set in .env for security)
OAUTH_STATE_SECRET = os.getenv("OAUTH_STATE_SECRET", "")

# State expiration time in seconds (5 minutes)
OAUTH_STATE_EXPIRY = 300

# In-memory store for used states (prevents replay attacks)
# Format: {state_token: expiry_timestamp}
_used_states: Dict[str, float] = {}


def is_calendar_enabled() -> bool:
    """Check if Google Calendar integration is enabled."""
    enabled = os.getenv("GOOGLE_CALENDAR_ENABLED", "false").lower() == "true"
    has_credentials = bool(GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET)
    return enabled and has_credentials


def _cleanup_expired_states() -> None:
    """Remove expired states from memory."""
    current_time = time.time()
    expired = [token for token, expiry in _used_states.items() if current_time > expiry]
    for token in expired:
        del _used_states[token]


def generate_oauth_state(user_id: int) -> str:
    """
    Generate a cryptographically signed OAuth state parameter.

    The state contains:
    - user_id: Telegram user ID
    - timestamp: Creation time for expiration check
    - nonce: Random token for uniqueness

    Format: base64(user_id.timestamp.nonce.signature)

    Args:
        user_id: Telegram user ID

    Returns:
        Signed state string
    """
    if not OAUTH_STATE_SECRET:
        logger.warning("OAUTH_STATE_SECRET not set, using fallback (insecure)")
        # Fallback to old behavior if secret not configured
        return str(user_id)

    # Create state payload
    timestamp = int(time.time())
    nonce = secrets.token_hex(16)
    payload = f"{user_id}.{timestamp}.{nonce}"

    # Sign with HMAC-SHA256
    signature = hmac.new(
        OAUTH_STATE_SECRET.encode(),
        payload.encode(),
        hashlib.sha256
    ).hexdigest()

    # Combine payload and signature
    state_data = f"{payload}.{signature}"

    # Base64 encode for URL safety
    return base64.urlsafe_b64encode(state_data.encode()).decode()


def verify_oauth_state(state: str) -> Tuple[bool, Optional[int], str]:
    """
    Verify and decode an OAuth state parameter.

    Checks:
    - Signature validity (HMAC)
    - Expiration (5 minutes)
    - One-time use (prevents replay)

    Args:
        state: The state parameter from OAuth callback

    Returns:
        Tuple of (is_valid, user_id, error_message)
    """
    if not OAUTH_STATE_SECRET:
        # Fallback: treat state as plain user_id (legacy behavior)
        try:
            return True, int(state), ""
        except (ValueError, TypeError):
            return False, None, "Invalid state format"

    try:
        # Decode base64
        state_data = base64.urlsafe_b64decode(state.encode()).decode()
        parts = state_data.split(".")

        if len(parts) != 4:
            return False, None, "Invalid state format"

        user_id_str, timestamp_str, nonce, signature = parts

        # Verify signature
        payload = f"{user_id_str}.{timestamp_str}.{nonce}"
        expected_sig = hmac.new(
            OAUTH_STATE_SECRET.encode(),
            payload.encode(),
            hashlib.sha256
        ).hexdigest()

        if not hmac.compare_digest(signature, expected_sig):
            logger.warning(f"OAuth state signature mismatch for user {user_id_str}")
            return False, None, "Invalid signature"

        # Check expiration
        timestamp = int(timestamp_str)
        if time.time() - timestamp > OAUTH_STATE_EXPIRY:
            return False, None, "State expired"

        # Check one-time use
        state_key = f"{user_id_str}.{nonce}"
        if state_key in _used_states:
            logger.warning(f"OAuth state replay attempt for user {user_id_str}")
            return False, None, "State already used"

        # Mark as used (with expiry for cleanup)
        _used_states[state_key] = time.time() + OAUTH_STATE_EXPIRY

        # Cleanup old states periodically
        _cleanup_expired_states()

        return True, int(user_id_str), ""

    except Exception as e:
        logger.error(f"Error verifying OAuth state: {e}")
        return False, None, "Verification failed"


def get_oauth_url(user_id: int) -> Optional[str]:
    """
    Generate OAuth authorization URL for user.

    Args:
        user_id: Telegram user ID to include in state

    Returns:
        Authorization URL or None if not configured
    """
    if not is_calendar_enabled():
        return None

    try:
        client_config = {
            "web": {
                "client_id": GOOGLE_CLIENT_ID,
                "client_secret": GOOGLE_CLIENT_SECRET,
                "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                "token_uri": "https://oauth2.googleapis.com/token",
                "redirect_uris": [GOOGLE_REDIRECT_URI],
            }
        }

        flow = Flow.from_client_config(
            client_config,
            scopes=SCOPES,
            redirect_uri=GOOGLE_REDIRECT_URI
        )

        # Generate cryptographically signed state with user_id
        secure_state = generate_oauth_state(user_id)

        auth_url, _ = flow.authorization_url(
            access_type="offline",
            include_granted_scopes="true",
            prompt="consent",
            state=secure_state
        )

        return auth_url

    except Exception as e:
        logger.error(f"Error generating OAuth URL: {e}")
        return None


async def exchange_code_for_tokens(code: str) -> Optional[Dict[str, str]]:
    """
    Exchange authorization code for access/refresh tokens.

    Args:
        code: Authorization code from OAuth callback

    Returns:
        Dict with access_token and refresh_token
    """
    if not is_calendar_enabled():
        return None

    try:
        import requests

        # Direct token exchange via HTTP (more flexible with scopes)
        token_url = "https://oauth2.googleapis.com/token"
        data = {
            "code": code,
            "client_id": GOOGLE_CLIENT_ID,
            "client_secret": GOOGLE_CLIENT_SECRET,
            "redirect_uri": GOOGLE_REDIRECT_URI,
            "grant_type": "authorization_code",
        }

        response = requests.post(token_url, data=data)

        if response.status_code != 200:
            logger.error(f"Token exchange failed: {response.text}")
            return None

        tokens = response.json()

        return {
            "access_token": tokens.get("access_token"),
            "refresh_token": tokens.get("refresh_token"),
            "token_uri": token_url,
            "client_id": GOOGLE_CLIENT_ID,
            "client_secret": GOOGLE_CLIENT_SECRET,
        }

    except Exception as e:
        logger.error(f"Error exchanging code for tokens: {e}")
        return None


def get_calendar_service(token_data: Dict[str, str]):
    """
    Build Google Calendar API service with user credentials.

    Args:
        token_data: Dict with access_token, refresh_token, etc.

    Returns:
        Google Calendar API service
    """
    try:
        credentials = Credentials(
            token=token_data.get("access_token"),
            refresh_token=token_data.get("refresh_token"),
            token_uri="https://oauth2.googleapis.com/token",
            client_id=GOOGLE_CLIENT_ID,
            client_secret=GOOGLE_CLIENT_SECRET,
        )

        service = build("calendar", "v3", credentials=credentials)
        return service

    except Exception as e:
        logger.error(f"Error building calendar service: {e}")
        return None


async def create_calendar_event(
    token_data: Dict[str, str],
    task_id: str,
    title: str,
    deadline: datetime,
    description: str = "",
    priority: str = "normal",
    reminder_source: str = "both",
) -> Optional[str]:
    """
    Create a calendar event for a task.

    Args:
        token_data: User's OAuth token data
        task_id: Task public ID
        title: Event title (task content)
        deadline: Task deadline
        description: Optional description
        priority: Task priority for color coding
        reminder_source: User's reminder source setting (telegram/google_calendar/both)

    Returns:
        Google Calendar event ID or None
    """
    service = get_calendar_service(token_data)
    if not service:
        return None

    try:
        # Color based on priority (Google Calendar colorId)
        color_map = {
            "urgent": "11",  # Red
            "high": "6",     # Orange
            "normal": "7",   # Cyan
            "low": "2",      # Green
        }

        # Create event
        event = {
            "summary": f"[{task_id}] {title}",
            "description": f"TeleTask: {task_id}\n\n{description}" if description else f"TeleTask: {task_id}",
            "start": {
                "dateTime": deadline.isoformat(),
                "timeZone": "Asia/Ho_Chi_Minh",
            },
            "end": {
                "dateTime": (deadline + timedelta(hours=1)).isoformat(),
                "timeZone": "Asia/Ho_Chi_Minh",
            },
            "colorId": color_map.get(priority, "7"),
        }

        # Set Google Calendar reminders based on user preference
        if reminder_source in ("google_calendar", "both"):
            event["reminders"] = {
                "useDefault": False,
                "overrides": [
                    {"method": "popup", "minutes": 5},     # 5 minutes before
                    {"method": "popup", "minutes": 30},    # 30 minutes before
                    {"method": "popup", "minutes": 60},    # 1 hour before
                    {"method": "popup", "minutes": 1440},  # 24 hours before
                ],
            }
        else:
            # telegram only - no Google Calendar reminders
            event["reminders"] = {
                "useDefault": False,
                "overrides": [],
            }

        result = service.events().insert(
            calendarId="primary",
            body=event
        ).execute()

        logger.info(f"Created calendar event for task {task_id}: {result.get('id')}")
        return result.get("id")

    except HttpError as e:
        logger.error(f"Calendar API error creating event: {e}")
        return None
    except Exception as e:
        logger.error(f"Error creating calendar event: {e}")
        return None


async def update_calendar_event(
    token_data: Dict[str, str],
    event_id: str,
    task_id: str,
    title: str,
    deadline: datetime,
    description: str = "",
    priority: str = "normal",
    status: str = "pending",
) -> bool:
    """
    Update an existing calendar event.

    Args:
        token_data: User's OAuth token data
        event_id: Google Calendar event ID
        task_id: Task public ID
        title: Event title
        deadline: Task deadline
        description: Optional description
        priority: Task priority
        status: Task status

    Returns:
        True if updated successfully
    """
    service = get_calendar_service(token_data)
    if not service:
        return False

    try:
        color_map = {
            "urgent": "11",  # Red
            "high": "6",     # Orange
            "normal": "7",   # Cyan
            "low": "2",      # Green
        }

        # Mark completed tasks visually
        summary = f"[{task_id}] {title}"
        if status == "completed":
            summary = f"✅ [DONE] {title}"
            color_id = "8"  # Gray for completed
        else:
            color_id = color_map.get(priority, "7")

        event = {
            "summary": summary,
            "description": f"TeleTask: {task_id}\nStatus: {status.upper()}\n\n{description}" if description else f"TeleTask: {task_id}\nStatus: {status.upper()}",
            "start": {
                "dateTime": deadline.isoformat(),
                "timeZone": "Asia/Ho_Chi_Minh",
            },
            "end": {
                "dateTime": (deadline + timedelta(hours=1)).isoformat(),
                "timeZone": "Asia/Ho_Chi_Minh",
            },
            "colorId": color_id,
        }

        service.events().update(
            calendarId="primary",
            eventId=event_id,
            body=event
        ).execute()

        logger.info(f"Updated calendar event for task {task_id}")
        return True

    except HttpError as e:
        logger.error(f"Calendar API error updating event: {e}")
        return False
    except Exception as e:
        logger.error(f"Error updating calendar event: {e}")
        return False


async def delete_calendar_event(
    token_data: Dict[str, str],
    event_id: str,
) -> bool:
    """
    Delete a calendar event.

    Args:
        token_data: User's OAuth token data
        event_id: Google Calendar event ID

    Returns:
        True if deleted successfully
    """
    service = get_calendar_service(token_data)
    if not service:
        return False

    try:
        service.events().delete(
            calendarId="primary",
            eventId=event_id
        ).execute()

        logger.info(f"Deleted calendar event: {event_id}")
        return True

    except HttpError as e:
        if e.resp.status == 404:
            # Event already deleted
            return True
        logger.error(f"Calendar API error deleting event: {e}")
        return False
    except Exception as e:
        logger.error(f"Error deleting calendar event: {e}")
        return False


async def get_user_token_data(db, user_id: int) -> Optional[Dict[str, str]]:
    """
    Get user's stored Google Calendar token data.

    Args:
        db: Database connection
        user_id: Database user ID

    Returns:
        Token data dict or None
    """
    try:
        user = await db.fetch_one(
            "SELECT google_calendar_token, google_calendar_refresh_token FROM users WHERE id = $1",
            user_id
        )

        if not user or not user["google_calendar_token"]:
            return None

        return {
            "access_token": user["google_calendar_token"],
            "refresh_token": user["google_calendar_refresh_token"],
        }

    except Exception as e:
        logger.error(f"Error getting user token data: {e}")
        return None


async def get_user_reminder_source(db, user_id: int) -> str:
    """
    Get user's reminder source setting.

    Args:
        db: Database connection
        user_id: Database user ID

    Returns:
        Reminder source: 'telegram', 'google_calendar', or 'both'
    """
    try:
        user = await db.fetch_one(
            "SELECT reminder_source FROM users WHERE id = $1",
            user_id
        )
        return user["reminder_source"] if user and user["reminder_source"] else "both"

    except Exception as e:
        logger.error(f"Error getting user reminder source: {e}")
        return "both"


async def save_user_tokens(
    db,
    user_id: int,
    access_token: str,
    refresh_token: str,
) -> bool:
    """
    Save user's Google Calendar tokens.

    Args:
        db: Database connection
        user_id: Database user ID
        access_token: OAuth access token
        refresh_token: OAuth refresh token

    Returns:
        True if saved successfully
    """
    try:
        await db.execute(
            """
            UPDATE users SET
                google_calendar_token = $2,
                google_calendar_refresh_token = $3,
                updated_at = NOW()
            WHERE id = $1
            """,
            user_id, access_token, refresh_token
        )
        return True

    except Exception as e:
        logger.error(f"Error saving user tokens: {e}")
        return False


async def disconnect_calendar(db, user_id: int) -> bool:
    """
    Disconnect user's Google Calendar.

    Args:
        db: Database connection
        user_id: Database user ID

    Returns:
        True if disconnected successfully
    """
    try:
        await db.execute(
            """
            UPDATE users SET
                google_calendar_token = NULL,
                google_calendar_refresh_token = NULL,
                updated_at = NOW()
            WHERE id = $1
            """,
            user_id
        )
        return True

    except Exception as e:
        logger.error(f"Error disconnecting calendar: {e}")
        return False


async def is_user_connected(db, user_id: int) -> bool:
    """
    Check if user has connected Google Calendar.

    Args:
        db: Database connection
        user_id: Database user ID

    Returns:
        True if connected
    """
    try:
        user = await db.fetch_one(
            "SELECT google_calendar_token FROM users WHERE id = $1",
            user_id
        )
        return bool(user and user["google_calendar_token"])

    except Exception as e:
        logger.error(f"Error checking user connection: {e}")
        return False
</file>

<file path="services/notification.py">
"""
Notification Service
Send reminder and status notifications to users
"""

import logging
from datetime import datetime, timedelta
from typing import Any, Dict

from telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup
import pytz

logger = logging.getLogger(__name__)

TZ = pytz.timezone("Asia/Ho_Chi_Minh")


async def send_reminder_notification(bot: Bot, reminder: Dict[str, Any]) -> None:
    """
    Send a reminder notification to user.

    Args:
        bot: Telegram bot instance
        reminder: Reminder data with task and user info
    """
    now = datetime.now(TZ)
    deadline = reminder["deadline"]

    if deadline.tzinfo is None:
        deadline = TZ.localize(deadline)

    # Format message based on type
    task_id = reminder["public_id"]
    reminder_type = reminder.get("reminder_type", "")

    if reminder_type == "creator_overdue":
        # Special message for task creators when assigned task is overdue
        overdue = now - deadline
        text = format_creator_overdue_message(reminder, overdue)
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("📝 Chi tiết", callback_data=f"task_detail:{task_id}"),
            ],
        ])
    elif reminder_type == "after_deadline":
        overdue = now - deadline
        text = format_overdue_message(reminder, overdue)
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("📊 Tiến độ", callback_data=f"task_progress:{task_id}"),
                InlineKeyboardButton("⏰ Nhắc sau 30p", callback_data=f"snooze:{reminder['id']}:30"),
            ],
            [
                InlineKeyboardButton("✅ HOÀN THÀNH", callback_data=f"task_complete:{task_id}"),
            ],
        ])
    else:
        time_left = deadline - now
        text = format_upcoming_message(reminder, time_left)
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("📊 Tiến độ", callback_data=f"task_progress:{task_id}"),
                InlineKeyboardButton("⏰ Nhắc sau 30p", callback_data=f"snooze:{reminder['id']}:30"),
            ],
            [
                InlineKeyboardButton("✅ HOÀN THÀNH", callback_data=f"task_complete:{task_id}"),
            ],
        ])

    await bot.send_message(
        chat_id=reminder["telegram_id"],
        text=text,
        reply_markup=keyboard,
    )


async def send_reminder_by_task(
    bot: Bot,
    db,
    task_id: int,
    user_id: int,
) -> None:
    """
    Send reminder for a specific task to a user.

    Args:
        bot: Telegram bot instance
        db: Database connection
        task_id: Task internal ID
        user_id: User internal ID
    """
    # Get task and user info
    task = await db.fetch_one(
        """
        SELECT t.*, u.telegram_id, u.display_name
        FROM tasks t
        JOIN users u ON u.id = $2
        WHERE t.id = $1 AND t.is_deleted = false
        """,
        task_id, user_id
    )

    if not task or task["status"] == "completed":
        return

    task = dict(task)
    now = datetime.now(TZ)
    deadline = task.get("deadline")

    if deadline:
        if deadline.tzinfo is None:
            deadline = TZ.localize(deadline)

        if now > deadline:
            text = format_overdue_message(task, now - deadline)
        else:
            text = format_upcoming_message(task, deadline - now)
    else:
        text = format_simple_reminder(task)

    keyboard = InlineKeyboardMarkup([
        [
            InlineKeyboardButton("📝 Chi tiết", callback_data=f"task_detail:{task['public_id']}"),
        ],
        [
            InlineKeyboardButton("✅ HOÀN THÀNH", callback_data=f"task_complete:{task['public_id']}"),
        ],
    ])

    await bot.send_message(
        chat_id=task["telegram_id"],
        text=text,
        reply_markup=keyboard,
    )


def format_upcoming_message(data: Dict[str, Any], time_left: timedelta) -> str:
    """Format reminder message for upcoming deadline."""
    hours = time_left.total_seconds() / 3600

    if hours <= 0.5:
        prefix = "🚨 KHẨN CẤP - Còn 30 phút!"
    elif hours <= 1:
        prefix = "🚨 KHẨN CẤP - Còn 1 giờ!"
    elif hours <= 3:
        prefix = "⚠️ SẮP ĐẾN HẠN - Còn vài giờ"
    elif hours <= 24:
        prefix = "🔔 NHẮC VIỆC - Còn 1 ngày"
    else:
        prefix = "🔔 NHẮC VIỆC"

    content = data.get("content", "")
    if len(content) > 100:
        content = content[:97] + "..."

    deadline = data.get("deadline")
    deadline_str = deadline.strftime("%H:%M %d/%m") if deadline else "N/A"

    return f"""{prefix}

{data.get('public_id', '')}: {content}

Ưu tiên: {format_priority(data.get('priority', 'normal'))}
Tiến độ: {format_progress_bar(data.get('progress', 0))}
Deadline: {deadline_str}
Còn lại: {format_time_delta(time_left)}"""


def format_overdue_message(data: Dict[str, Any], overdue: timedelta) -> str:
    """Format reminder message for overdue task."""
    hours = overdue.total_seconds() / 3600

    if hours >= 168:  # 1 week
        prefix = "🚨 TRỄ RẤT NGHIÊM TRỌNG!"
    elif hours >= 24:
        prefix = "🚨 TRỄ NGHIÊM TRỌNG!"
    else:
        prefix = "🚨 VIỆC ĐÃ TRỄ HẠN!"

    content = data.get("content", "")
    if len(content) > 100:
        content = content[:97] + "..."

    deadline = data.get("deadline")
    deadline_str = deadline.strftime("%H:%M %d/%m") if deadline else "N/A"

    return f"""{prefix}

{data.get('public_id', '')}: {content}

Ưu tiên: {format_priority(data.get('priority', 'normal'))}
Tiến độ: {format_progress_bar(data.get('progress', 0))}
Deadline: {deadline_str}
Đã trễ: {format_time_delta(overdue)}

Vui lòng hoàn thành sớm nhất!"""


def format_creator_overdue_message(data: Dict[str, Any], overdue: timedelta) -> str:
    """Format reminder message for task creators when assigned task is overdue."""
    content = data.get("content", "")
    if len(content) > 100:
        content = content[:97] + "..."

    deadline = data.get("deadline")
    deadline_str = deadline.strftime("%H:%M %d/%m") if deadline else "N/A"

    return f"""⚠️ VIỆC GIAO ĐÃ TRỄ HẠN!

{data.get('public_id', '')}: {content}

Deadline: {deadline_str}
Đã trễ: {format_time_delta(overdue)}
Tiến độ: {format_progress_bar(data.get('progress', 0))}

Công việc bạn giao chưa được hoàn thành đúng hạn.
Hãy liên hệ người nhận việc để cập nhật."""


def format_simple_reminder(data: Dict[str, Any]) -> str:
    """Format simple reminder without deadline."""
    content = data.get("content", "")
    if len(content) > 100:
        content = content[:97] + "..."

    return f"""🔔 NHẮC VIỆC

{data.get('public_id', '')}: {content}

Ưu tiên: {format_priority(data.get('priority', 'normal'))}
Tiến độ: {format_progress_bar(data.get('progress', 0))}"""


def format_time_delta(td: timedelta) -> str:
    """Format timedelta as readable Vietnamese."""
    total_seconds = int(abs(td.total_seconds()))

    if total_seconds < 60:
        return f"{total_seconds} giây"

    minutes = total_seconds // 60
    if minutes < 60:
        return f"{minutes} phút"

    hours = minutes // 60
    remaining_mins = minutes % 60
    if hours < 24:
        if remaining_mins > 0:
            return f"{hours} giờ {remaining_mins} phút"
        return f"{hours} giờ"

    days = hours // 24
    remaining_hours = hours % 24
    if remaining_hours > 0:
        return f"{days} ngày {remaining_hours} giờ"
    return f"{days} ngày"


def format_priority(priority: str) -> str:
    """Format priority label."""
    return {
        "urgent": "🔴 Khẩn cấp",
        "high": "🟠 Cao",
        "normal": "🟡 Bình thường",
        "low": "🟢 Thấp",
    }.get(priority, "🟡 Bình thường")


def format_progress_bar(percent: int, width: int = 10) -> str:
    """Format progress bar."""
    filled = int(width * percent / 100)
    empty = width - filled
    bar = "█" * filled + "░" * empty
    return f"{bar} {percent}%"


# ============================================
# GROUP TASK NOTIFICATIONS
# ============================================

async def send_group_task_created_notification(
    bot: Bot,
    group_task: Dict[str, Any],
    child_tasks: list,
    assignees: list,
    creator: Dict[str, Any],
) -> None:
    """
    Send notification to all assignees when group task is created.

    Args:
        bot: Telegram bot instance
        group_task: Parent G-ID task data
        child_tasks: List of P-ID child tasks
        assignees: List of assignee user data
        creator: Creator user data
    """
    content = group_task.get("content", "")
    if len(content) > 100:
        content = content[:97] + "..."

    deadline = group_task.get("deadline")
    deadline_str = deadline.strftime("%H:%M %d/%m") if deadline else "Không có"

    for i, assignee in enumerate(assignees):
        if assignee.get("telegram_id") == creator.get("telegram_id"):
            continue  # Skip notifying creator

        # Check user notification preferences
        if not assignee.get("notify_all", True):
            continue  # User disabled all notifications
        if not assignee.get("notify_task_assigned", True):
            continue  # User disabled task assignment notifications

        child_task = child_tasks[i] if i < len(child_tasks) else None
        if not child_task:
            continue

        text = f"""👥 VIỆC NHÓM MỚI!

{group_task['public_id']}: {content}

Từ: {creator.get('display_name', 'N/A')}
Deadline: {deadline_str}
Thành viên: {len(assignees)} người

📋 Việc của bạn: {child_task['public_id']}

Trả lời /xong {child_task['public_id']} khi hoàn thành."""

        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("📊 Tiến độ", callback_data=f"task_progress:{child_task['public_id']}"),
                InlineKeyboardButton("👥 Xem nhóm", callback_data=f"task_detail:{group_task['public_id']}"),
            ],
            [
                InlineKeyboardButton("✅ HOÀN THÀNH", callback_data=f"task_complete:{child_task['public_id']}"),
            ],
        ])

        try:
            await bot.send_message(
                chat_id=assignee["telegram_id"],
                text=text,
                reply_markup=keyboard,
            )
        except Exception as e:
            logger.warning(f"Could not notify assignee {assignee.get('telegram_id')}: {e}")


async def send_member_completed_notification(
    bot: Bot,
    db,
    completed_task: Dict[str, Any],
    completer: Dict[str, Any],
) -> None:
    """
    Notify other group members when someone completes their task.

    Args:
        bot: Telegram bot instance
        db: Database connection
        completed_task: The P-ID task that was completed
        completer: User who completed the task
    """
    # Get parent task
    parent_id = completed_task.get("parent_task_id")
    if not parent_id:
        return

    parent = await db.fetch_one(
        "SELECT * FROM tasks WHERE id = $1 AND is_deleted = false",
        parent_id
    )
    if not parent:
        return

    parent = dict(parent)

    # Get all child tasks with assignee info and notification preferences
    siblings = await db.fetch_all(
        """
        SELECT t.*, u.telegram_id, u.display_name, u.notify_all, u.notify_task_status
        FROM tasks t
        JOIN users u ON t.assignee_id = u.id
        WHERE t.parent_task_id = $1 AND t.is_deleted = false
        """,
        parent_id
    )

    # Calculate progress
    total = len(siblings)
    completed = sum(1 for s in siblings if s["status"] == "completed")
    progress = int((completed / total) * 100) if total > 0 else 0

    content = parent.get("content", "")
    if len(content) > 50:
        content = content[:47] + "..."

    # Notify each sibling (except completer)
    for sibling in siblings:
        if sibling["telegram_id"] == completer.get("telegram_id"):
            continue
        if sibling["status"] == "completed":
            continue  # Don't notify already completed members

        # Check user notification preferences
        if not sibling.get("notify_all", True):
            continue  # User disabled all notifications
        if not sibling.get("notify_task_status", True):
            continue  # User disabled task status notifications

        text = f"""📊 CẬP NHẬT VIỆC NHÓM

{parent['public_id']}: {content}

✅ {completer.get('display_name', 'Ai đó')} đã hoàn thành!

Tiến độ nhóm: {format_progress_bar(progress)}
Hoàn thành: {completed}/{total}

Việc của bạn: {sibling['public_id']}"""

        try:
            await bot.send_message(
                chat_id=sibling["telegram_id"],
                text=text,
            )
        except Exception as e:
            logger.warning(f"Could not notify sibling {sibling.get('telegram_id')}: {e}")


async def send_group_completed_notification(
    bot: Bot,
    db,
    group_task: Dict[str, Any],
) -> None:
    """
    Notify creator when all group members have completed.

    Args:
        bot: Telegram bot instance
        db: Database connection
        group_task: The G-ID parent task that is now complete
    """
    # Get creator with notification preferences
    creator = await db.fetch_one(
        "SELECT telegram_id, display_name, notify_all, notify_task_status FROM users WHERE id = $1",
        group_task["creator_id"]
    )

    if not creator:
        return

    # Check user notification preferences
    if not creator.get("notify_all", True):
        return  # User disabled all notifications
    if not creator.get("notify_task_status", True):
        return  # User disabled task status notifications

    # Get child task count
    children = await db.fetch_all(
        """
        SELECT t.public_id, u.display_name
        FROM tasks t
        JOIN users u ON t.assignee_id = u.id
        WHERE t.parent_task_id = $1 AND t.is_deleted = false
        ORDER BY t.completed_at DESC
        """,
        group_task["id"]
    )

    member_list = "\n".join(f"  ✅ {c['display_name']}" for c in children)

    content = group_task.get("content", "")
    if len(content) > 100:
        content = content[:97] + "..."

    text = f"""🎉 VIỆC NHÓM ĐÃ HOÀN THÀNH!

{group_task['public_id']}: {content}

👥 TẤT CẢ {len(children)} THÀNH VIÊN ĐÃ HOÀN THÀNH:
{member_list}

Xem chi tiết: /xemviec {group_task['public_id']}"""

    keyboard = InlineKeyboardMarkup([
        [
            InlineKeyboardButton("📝 Chi tiết", callback_data=f"task_detail:{group_task['public_id']}"),
        ],
    ])

    try:
        await bot.send_message(
            chat_id=creator["telegram_id"],
            text=text,
            reply_markup=keyboard,
        )
    except Exception as e:
        logger.warning(f"Could not notify creator {creator.get('telegram_id')}: {e}")


async def send_task_completed_to_assigner(
    bot: Bot,
    db,
    task: Dict[str, Any],
    completer: Dict[str, Any],
) -> None:
    """
    Notify the task assigner/creator when assigned task is completed.

    Args:
        bot: Telegram bot instance
        db: Database connection
        task: The completed task data
        completer: User who completed the task
    """
    # Skip if this is a group task child (handled separately)
    if task.get("parent_task_id"):
        return

    # Get creator info
    creator_id = task.get("creator_id")
    assignee_id = task.get("assignee_id")

    # Skip if creator completed their own task
    if not creator_id or not assignee_id or creator_id == assignee_id:
        return

    creator = await db.fetch_one(
        "SELECT telegram_id, display_name, notify_all, notify_task_status FROM users WHERE id = $1",
        creator_id
    )

    if not creator:
        return

    # Check user notification preferences
    if not creator.get("notify_all", True):
        return  # User disabled all notifications
    if not creator.get("notify_task_status", True):
        return  # User disabled task status notifications

    content = task.get("content", "")
    if len(content) > 100:
        content = content[:97] + "..."

    completed_at = task.get("completed_at")
    if completed_at:
        completed_str = completed_at.strftime("%H:%M %d/%m")
    else:
        completed_str = datetime.now(TZ).strftime("%H:%M %d/%m")

    text = f"""✅ VIỆC ĐÃ HOÀN THÀNH!

{task['public_id']}: {content}

👤 Người thực hiện: {completer.get('display_name', 'N/A')}
⏰ Hoàn thành lúc: {completed_str}

Xem chi tiết: /xemviec {task['public_id']}"""

    keyboard = InlineKeyboardMarkup([
        [
            InlineKeyboardButton("📝 Chi tiết", callback_data=f"task_detail:{task['public_id']}"),
        ],
    ])

    try:
        await bot.send_message(
            chat_id=creator["telegram_id"],
            text=text,
            reply_markup=keyboard,
        )
        logger.info(f"Notified creator {creator_id} about task {task['public_id']} completion")
    except Exception as e:
        logger.warning(f"Could not notify creator {creator.get('telegram_id')}: {e}")
</file>

<file path="services/oauth_callback.py">
"""
OAuth Callback Handler
HTTP endpoint to receive Google OAuth callback
"""

import logging
import os
from aiohttp import web

from database import get_db
from services.calendar_service import (
    exchange_code_for_tokens,
    save_user_tokens,
    verify_oauth_state,
)
from services.user_service import get_user_by_telegram_id

logger = logging.getLogger(__name__)

# OAuth callback port
OAUTH_PORT = int(os.getenv("OAUTH_CALLBACK_PORT", "8081"))


def _macos_page(title: str, icon: str, heading: str, message: str, is_success: bool = False) -> str:
    """Generate MacOS-style HTML page."""
    icon_bg = "linear-gradient(180deg, #34c759 0%, #248a3d 100%)" if is_success else "linear-gradient(180deg, #ff3b30 0%, #d32f2f 100%)"
    icon_shadow = "rgba(52,199,89,0.3)" if is_success else "rgba(255,59,48,0.3)"

    return f'''<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TeleTask - {title}</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', sans-serif;
            background: linear-gradient(180deg, #f5f5f7 0%, #e8e8ed 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            -webkit-font-smoothing: antialiased;
        }}
        .macos-window {{
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 12px;
            max-width: 380px;
            width: 100%;
            box-shadow: 0 22px 70px 4px rgba(0,0,0,0.15), 0 0 0 1px rgba(0,0,0,0.05);
            overflow: hidden;
        }}
        .window-header {{
            background: linear-gradient(180deg, #e8e8e8 0%, #d6d6d6 100%);
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
        }}
        .traffic-lights {{
            display: flex;
            gap: 8px;
        }}
        .traffic-light {{
            width: 12px;
            height: 12px;
            border-radius: 50%;
            box-shadow: inset 0 0 0 1px rgba(0,0,0,0.1);
        }}
        .light-close {{ background: #ff5f57; }}
        .light-minimize {{ background: #febc2e; }}
        .light-maximize {{ background: #28c840; }}
        .window-title {{
            flex: 1;
            text-align: center;
            font-size: 13px;
            font-weight: 500;
            color: #4d4d4d;
            margin-right: 52px;
        }}
        .window-content {{
            padding: 30px;
            text-align: center;
        }}
        .status-icon {{
            width: 64px;
            height: 64px;
            background: {icon_bg};
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            margin: 0 auto 16px;
            box-shadow: 0 4px 12px {icon_shadow};
        }}
        h1 {{
            font-size: 18px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 12px;
        }}
        .message {{
            font-size: 13px;
            color: #86868b;
            line-height: 1.6;
        }}
        .message code {{
            background: #f5f5f7;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 12px;
            color: #007aff;
        }}
    </style>
</head>
<body>
    <div class="macos-window">
        <div class="window-header">
            <div class="traffic-lights">
                <div class="traffic-light light-close"></div>
                <div class="traffic-light light-minimize"></div>
                <div class="traffic-light light-maximize"></div>
            </div>
            <div class="window-title">Google Calendar</div>
        </div>
        <div class="window-content">
            <div class="status-icon">{icon}</div>
            <h1>{heading}</h1>
            <p class="message">{message}</p>
        </div>
    </div>
</body>
</html>'''


async def oauth_callback_handler(request: web.Request) -> web.Response:
    """
    Handle OAuth callback from Google.

    Query params:
        code: Authorization code
        state: Cryptographically signed state with user ID
    """
    try:
        code = request.query.get("code")
        state = request.query.get("state")  # Signed state parameter
        error = request.query.get("error")

        if error:
            return web.Response(
                text=_macos_page(
                    "Lỗi",
                    "❌",
                    "Kết nối thất bại",
                    f"Lỗi: {error}<br><br>Vui lòng thử lại trong Telegram."
                ),
                content_type="text/html"
            )

        if not code or not state:
            return web.Response(
                text=_macos_page(
                    "Lỗi",
                    "❌",
                    "Thiếu thông tin",
                    "Vui lòng thử lại từ đầu trong Telegram."
                ),
                content_type="text/html"
            )

        # Verify state parameter (CSRF protection)
        is_valid, telegram_id, error_msg = verify_oauth_state(state)
        if not is_valid:
            logger.warning(f"OAuth state verification failed: {error_msg}")
            return web.Response(
                text=_macos_page(
                    "Lỗi",
                    "❌",
                    "Xác thực thất bại",
                    f"Liên kết không hợp lệ hoặc đã hết hạn.<br><br>"
                    "Vui lòng tạo liên kết mới trong Telegram bằng lệnh <code>/lichgoogle</code>"
                ),
                content_type="text/html"
            )

        # Exchange code for tokens
        tokens = await exchange_code_for_tokens(code)

        if not tokens:
            return web.Response(
                text=_macos_page(
                    "Lỗi",
                    "❌",
                    "Không thể lấy token",
                    "Vui lòng thử lại trong Telegram."
                ),
                content_type="text/html"
            )

        # Get user by Telegram ID (already verified from state)
        db = get_db()
        db_user = await get_user_by_telegram_id(db, telegram_id)

        if not db_user:
            return web.Response(
                text=_macos_page(
                    "Lỗi",
                    "❌",
                    "Không tìm thấy người dùng",
                    "Vui lòng gửi <code>/start</code> trong bot trước khi kết nối."
                ),
                content_type="text/html"
            )

        # Save tokens
        success = await save_user_tokens(
            db,
            db_user["id"],
            tokens["access_token"],
            tokens["refresh_token"],
        )

        if success:
            return web.Response(
                text=_macos_page(
                    "Thành công",
                    "✅",
                    "Kết nối thành công!",
                    "Google Calendar đã được kết nối với tài khoản Telegram của bạn.<br><br>"
                    "Bạn có thể đóng trang này và quay lại Telegram.<br><br>"
                    "Sử dụng <code>/lichgoogle</code> để xem tùy chọn.",
                    is_success=True
                ),
                content_type="text/html"
            )
        else:
            return web.Response(
                text=_macos_page(
                    "Lỗi",
                    "❌",
                    "Lỗi lưu token",
                    "Vui lòng thử lại trong Telegram."
                ),
                content_type="text/html"
            )

    except Exception as e:
        logger.error(f"OAuth callback error: {e}")
        return web.Response(
            text=_macos_page(
                "Lỗi",
                "❌",
                "Lỗi hệ thống",
                "Vui lòng thử lại trong Telegram."
            ),
            content_type="text/html"
        )


async def start_oauth_server(app_runner=None) -> web.AppRunner:
    """
    Start the OAuth callback HTTP server.

    Returns:
        AppRunner instance
    """
    app = web.Application()
    app.router.add_get("/oauth/callback", oauth_callback_handler)

    runner = web.AppRunner(app)
    await runner.setup()

    # Bind to localhost only - nginx proxies external traffic
    site = web.TCPSite(runner, "127.0.0.1", OAUTH_PORT)
    await site.start()

    logger.info(f"OAuth callback server started on port {OAUTH_PORT}")
    return runner


async def stop_oauth_server(runner: web.AppRunner) -> None:
    """Stop the OAuth callback server."""
    if runner:
        await runner.cleanup()
        logger.info("OAuth callback server stopped")
</file>

<file path="services/recurring_service.py">
"""
Recurring Task Service
CRUD operations for recurring task templates
"""

import re
import logging
from datetime import datetime, timedelta, time
from typing import Any, Dict, List, Optional, Tuple
from dateutil.relativedelta import relativedelta
import pytz

from database.connection import Database

logger = logging.getLogger(__name__)

TZ = pytz.timezone("Asia/Ho_Chi_Minh")


async def generate_recurring_id(db: Database) -> str:
    """
    Generate unique recurring template ID.

    Args:
        db: Database connection

    Returns:
        Recurring ID like R-0001
    """
    result = await db.fetch_one(
        """
        UPDATE bot_config
        SET value = (CAST(value AS INTEGER) + 1)::TEXT, updated_at = NOW()
        WHERE key = 'recurring_id_counter'
        RETURNING value
        """
    )

    counter = int(result["value"]) if result else 1
    return f"R-{counter:04d}"


async def create_recurring_template(
    db: Database,
    content: str,
    creator_id: int,
    recurrence_type: str,
    recurrence_interval: int = 1,
    recurrence_days: List[int] = None,
    recurrence_time: time = None,
    recurrence_end_date: datetime = None,
    recurrence_count: int = None,
    assignee_id: int = None,
    group_id: int = None,
    priority: str = "normal",
    description: str = None,
    is_personal: bool = True,
) -> Dict[str, Any]:
    """
    Create a new recurring task template.

    Args:
        db: Database connection
        content: Task content template
        creator_id: Creator user ID
        recurrence_type: daily, weekly, or monthly
        recurrence_interval: Every N periods (default 1)
        recurrence_days: Days of week (0-6) or month (1-31)
        recurrence_time: Time of day for deadline
        recurrence_end_date: When to stop generating
        recurrence_count: Max instances to generate
        assignee_id: Default assignee
        group_id: Group ID for group tasks
        priority: Task priority
        description: Optional description
        is_personal: Personal or group template

    Returns:
        Created recurring template record
    """
    public_id = await generate_recurring_id(db)

    # Calculate first next_due
    next_due = calculate_next_due(
        recurrence_type=recurrence_type,
        recurrence_interval=recurrence_interval,
        recurrence_days=recurrence_days,
        recurrence_time=recurrence_time,
        from_date=datetime.now(TZ),
    )

    template = await db.fetch_one(
        """
        INSERT INTO recurring_templates (
            public_id, content, description, priority,
            creator_id, assignee_id, group_id, is_personal,
            recurrence_type, recurrence_interval, recurrence_days,
            recurrence_time, recurrence_end_date, recurrence_count,
            next_due
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
        RETURNING *
        """,
        public_id,
        content,
        description,
        priority,
        creator_id,
        assignee_id or creator_id,
        group_id,
        is_personal,
        recurrence_type,
        recurrence_interval,
        recurrence_days,
        recurrence_time,
        recurrence_end_date,
        recurrence_count,
        next_due,
    )

    logger.info(f"Created recurring template {public_id}: {content[:30]}...")
    return dict(template)


def calculate_next_due(
    recurrence_type: str,
    recurrence_interval: int = 1,
    recurrence_days: List[int] = None,
    recurrence_time: time = None,
    from_date: datetime = None,
    last_generated: datetime = None,
) -> Optional[datetime]:
    """
    Calculate next due date for recurring template.

    Args:
        recurrence_type: daily, weekly, monthly
        recurrence_interval: Every N periods
        recurrence_days: Days of week/month
        recurrence_time: Time of day
        from_date: Start calculating from this date
        last_generated: Last time task was generated

    Returns:
        Next due datetime
    """
    now = datetime.now(TZ)
    base = last_generated or from_date or now

    if base.tzinfo is None:
        base = TZ.localize(base)

    # Default time is 9:00 AM
    target_time = recurrence_time or time(9, 0)

    if recurrence_type == "daily":
        # Every N days
        next_date = base + timedelta(days=recurrence_interval)
        next_date = next_date.replace(
            hour=target_time.hour,
            minute=target_time.minute,
            second=0,
            microsecond=0,
        )
        # Ensure it's in the future
        while next_date <= now:
            next_date += timedelta(days=recurrence_interval)
        return next_date

    elif recurrence_type == "weekly":
        # Days of week (0=Monday, 6=Sunday)
        if not recurrence_days:
            recurrence_days = [base.weekday()]  # Same day as created

        # Find next matching day
        next_date = base + timedelta(days=1)
        while True:
            if next_date.weekday() in recurrence_days:
                candidate = next_date.replace(
                    hour=target_time.hour,
                    minute=target_time.minute,
                    second=0,
                    microsecond=0,
                )
                if candidate > now:
                    return candidate
            next_date += timedelta(days=1)
            # Safety limit: don't loop forever
            if (next_date - base).days > 365:
                break

    elif recurrence_type == "monthly":
        # Days of month (1-31)
        if not recurrence_days:
            recurrence_days = [base.day]  # Same day as created

        # Start from next month if interval > 1
        next_month = base + relativedelta(months=recurrence_interval)

        for day in sorted(recurrence_days):
            try:
                candidate = next_month.replace(
                    day=day,
                    hour=target_time.hour,
                    minute=target_time.minute,
                    second=0,
                    microsecond=0,
                )
                if candidate > now:
                    return candidate
            except ValueError:
                # Day doesn't exist in this month (e.g., Feb 30)
                continue

        # Try next month
        next_month += relativedelta(months=1)
        for day in sorted(recurrence_days):
            try:
                return next_month.replace(
                    day=day,
                    hour=target_time.hour,
                    minute=target_time.minute,
                    second=0,
                    microsecond=0,
                )
            except ValueError:
                continue

    return None


def parse_recurrence_pattern(text: str) -> Tuple[Optional[Dict[str, Any]], str]:
    """
    Parse Vietnamese recurrence pattern from text.

    Supported patterns:
    - "hàng ngày" / "mỗi ngày" -> daily
    - "hàng tuần" / "mỗi tuần" -> weekly
    - "hàng tháng" / "mỗi tháng" -> monthly
    - "thứ 2, thứ 4" -> weekly on Mon, Wed
    - "ngày 1, ngày 15" -> monthly on 1st, 15th
    - "mỗi 2 ngày" -> every 2 days
    - "mỗi 2 tuần" -> every 2 weeks

    Args:
        text: Input text

    Returns:
        Tuple of (recurrence config dict, remaining text)
    """
    text_lower = text.lower()
    result = None
    matched_parts = []

    # Daily patterns
    daily_patterns = [
        (r"hàng\s*ngày", 1),
        (r"mỗi\s*ngày", 1),
        (r"mỗi\s*(\d+)\s*ngày", None),  # "mỗi 2 ngày"
    ]

    for pattern, interval in daily_patterns:
        match = re.search(pattern, text_lower)
        if match:
            actual_interval = interval
            if interval is None and match.lastindex >= 1:
                actual_interval = int(match.group(1))
            result = {
                "recurrence_type": "daily",
                "recurrence_interval": actual_interval or 1,
                "recurrence_days": None,
            }
            matched_parts.append(match.group(0))
            text_lower = text_lower.replace(match.group(0), " ")
            break

    # Weekly patterns
    if not result:
        weekly_patterns = [
            (r"hàng\s*tuần", 1),
            (r"mỗi\s*tuần", 1),
            (r"mỗi\s*(\d+)\s*tuần", None),
        ]

        for pattern, interval in weekly_patterns:
            match = re.search(pattern, text_lower)
            if match:
                actual_interval = interval
                if interval is None and match.lastindex >= 1:
                    actual_interval = int(match.group(1))
                result = {
                    "recurrence_type": "weekly",
                    "recurrence_interval": actual_interval or 1,
                    "recurrence_days": None,
                }
                matched_parts.append(match.group(0))
                text_lower = text_lower.replace(match.group(0), " ")
                break

    # Monthly patterns
    if not result:
        monthly_patterns = [
            (r"hàng\s*tháng", 1),
            (r"mỗi\s*tháng", 1),
            (r"mỗi\s*(\d+)\s*tháng", None),
        ]

        for pattern, interval in monthly_patterns:
            match = re.search(pattern, text_lower)
            if match:
                actual_interval = interval
                if interval is None and match.lastindex >= 1:
                    actual_interval = int(match.group(1))
                result = {
                    "recurrence_type": "monthly",
                    "recurrence_interval": actual_interval or 1,
                    "recurrence_days": None,
                }
                matched_parts.append(match.group(0))
                text_lower = text_lower.replace(match.group(0), " ")
                break

    # Extract specific days of week
    if result and result["recurrence_type"] == "weekly":
        weekday_map = {
            "thứ 2": 0, "thứ hai": 0, "t2": 0,
            "thứ 3": 1, "thứ ba": 1, "t3": 1,
            "thứ 4": 2, "thứ tư": 2, "t4": 2,
            "thứ 5": 3, "thứ năm": 3, "t5": 3,
            "thứ 6": 4, "thứ sáu": 4, "t6": 4,
            "thứ 7": 5, "thứ bảy": 5, "t7": 5,
            "chủ nhật": 6, "cn": 6,
        }

        days = []
        for keyword, day_num in weekday_map.items():
            if re.search(rf"\b{re.escape(keyword)}\b", text_lower):
                days.append(day_num)
                text_lower = re.sub(rf"\b{re.escape(keyword)}\b", " ", text_lower)

        if days:
            result["recurrence_days"] = sorted(set(days))

    # Extract specific days of month
    if result and result["recurrence_type"] == "monthly":
        # Pattern: "ngày 1, ngày 15" or "1, 15"
        day_matches = re.findall(r"ngày\s*(\d{1,2})|(?:^|,)\s*(\d{1,2})(?:,|$)", text_lower)
        days = []
        for m in day_matches:
            day = int(m[0] or m[1])
            if 1 <= day <= 31:
                days.append(day)
        if days:
            result["recurrence_days"] = sorted(set(days))
            text_lower = re.sub(r"ngày\s*\d{1,2}[,\s]*", " ", text_lower)

    # Extract time
    time_match = re.search(r"(\d{1,2})h(\d{2})?|(\d{1,2}):(\d{2})", text_lower)
    if time_match and result:
        hour = int(time_match.group(1) or time_match.group(3))
        minute = int(time_match.group(2) or time_match.group(4) or 0)
        if 0 <= hour <= 23 and 0 <= minute <= 59:
            result["recurrence_time"] = time(hour, minute)
            text_lower = text_lower.replace(time_match.group(0), " ")

    # Clean remaining text
    remaining = re.sub(r"\s+", " ", text_lower).strip()

    return result, remaining


async def get_recurring_template(
    db: Database,
    public_id: str,
) -> Optional[Dict[str, Any]]:
    """
    Get recurring template by public ID.

    Args:
        db: Database connection
        public_id: Template public ID (R-xxxx)

    Returns:
        Template record or None
    """
    template = await db.fetch_one(
        """
        SELECT r.*, u.display_name as creator_name, a.display_name as assignee_name
        FROM recurring_templates r
        LEFT JOIN users u ON r.creator_id = u.id
        LEFT JOIN users a ON r.assignee_id = a.id
        WHERE r.public_id = $1
        """,
        public_id.upper(),
    )
    return dict(template) if template else None


async def get_user_recurring_templates(
    db: Database,
    user_id: int,
    active_only: bool = True,
    limit: int = 20,
) -> List[Dict[str, Any]]:
    """
    Get recurring templates created by user.

    Args:
        db: Database connection
        user_id: User ID
        active_only: Only return active templates
        limit: Max results

    Returns:
        List of template records
    """
    conditions = ["creator_id = $1"]
    params = [user_id]

    if active_only:
        conditions.append("is_active = true")

    query = f"""
        SELECT r.*, u.display_name as assignee_name
        FROM recurring_templates r
        LEFT JOIN users u ON r.assignee_id = u.id
        WHERE {' AND '.join(conditions)}
        ORDER BY created_at DESC
        LIMIT ${len(params) + 1}
    """

    templates = await db.fetch_all(query, *params, limit)
    return [dict(t) for t in templates]


async def get_due_templates(db: Database) -> List[Dict[str, Any]]:
    """
    Get templates due for task generation.

    Returns templates where:
    - is_active = true
    - next_due <= now
    - recurrence_end_date is null or > now
    - instances_created < recurrence_count (if set)

    Returns:
        List of due template records
    """
    now = datetime.now(TZ)

    templates = await db.fetch_all(
        """
        SELECT r.*, u.telegram_id as creator_telegram_id
        FROM recurring_templates r
        JOIN users u ON r.creator_id = u.id
        WHERE r.is_active = true
        AND r.next_due <= $1
        AND (r.recurrence_end_date IS NULL OR r.recurrence_end_date > $1)
        AND (r.recurrence_count IS NULL OR r.instances_created < r.recurrence_count)
        ORDER BY r.next_due ASC
        """,
        now,
    )
    return [dict(t) for t in templates]


async def generate_task_from_template(
    db: Database,
    template: Dict[str, Any],
) -> Optional[Dict[str, Any]]:
    """
    Generate a task instance from recurring template.

    Args:
        db: Database connection
        template: Recurring template record

    Returns:
        Created task record
    """
    from .task_service import create_task

    # Calculate deadline from next_due
    deadline = template["next_due"]

    # Create task
    task = await create_task(
        db=db,
        content=template["content"],
        creator_id=template["creator_id"],
        assignee_id=template["assignee_id"],
        deadline=deadline,
        priority=template["priority"],
        is_personal=template["is_personal"],
        group_id=template["group_id"],
        description=template["description"],
    )

    # Link task to template
    await db.execute(
        "UPDATE tasks SET recurring_template_id = $1 WHERE id = $2",
        template["id"],
        task["id"],
    )

    # Update template: last_generated, instances_created, next_due
    next_due = calculate_next_due(
        recurrence_type=template["recurrence_type"],
        recurrence_interval=template["recurrence_interval"],
        recurrence_days=template["recurrence_days"],
        recurrence_time=template["recurrence_time"],
        last_generated=deadline,
    )

    await db.execute(
        """
        UPDATE recurring_templates SET
            last_generated = $2,
            instances_created = instances_created + 1,
            next_due = $3,
            updated_at = NOW()
        WHERE id = $1
        """,
        template["id"],
        datetime.now(TZ),
        next_due,
    )

    logger.info(f"Generated task {task['public_id']} from template {template['public_id']}")
    return task


async def toggle_recurring_template(
    db: Database,
    template_id: int,
    is_active: bool,
) -> Optional[Dict[str, Any]]:
    """
    Activate or deactivate a recurring template.

    Args:
        db: Database connection
        template_id: Template ID
        is_active: New active state

    Returns:
        Updated template record
    """
    template = await db.fetch_one(
        """
        UPDATE recurring_templates SET
            is_active = $2,
            updated_at = NOW()
        WHERE id = $1
        RETURNING *
        """,
        template_id,
        is_active,
    )
    return dict(template) if template else None


async def delete_recurring_template(
    db: Database,
    template_id: int,
) -> bool:
    """
    Delete a recurring template.

    Args:
        db: Database connection
        template_id: Template ID

    Returns:
        True if deleted
    """
    result = await db.execute(
        "DELETE FROM recurring_templates WHERE id = $1",
        template_id,
    )
    return result > 0


def format_recurrence_description(template: Dict[str, Any]) -> str:
    """
    Format recurrence pattern as Vietnamese description.

    Args:
        template: Template record

    Returns:
        Vietnamese description like "Hàng ngày lúc 9:00"
    """
    rec_type = template["recurrence_type"]
    interval = template["recurrence_interval"] or 1
    days = template["recurrence_days"]
    rec_time = template["recurrence_time"]

    time_str = rec_time.strftime("%H:%M") if rec_time else "9:00"

    if rec_type == "daily":
        if interval == 1:
            return f"Hàng ngày lúc {time_str}"
        return f"Mỗi {interval} ngày lúc {time_str}"

    elif rec_type == "weekly":
        weekday_names = ["T2", "T3", "T4", "T5", "T6", "T7", "CN"]
        if days:
            day_str = ", ".join(weekday_names[d] for d in days)
        else:
            day_str = "mỗi tuần"

        if interval == 1:
            return f"Hàng tuần ({day_str}) lúc {time_str}"
        return f"Mỗi {interval} tuần ({day_str}) lúc {time_str}"

    elif rec_type == "monthly":
        if days:
            day_str = ", ".join(f"ngày {d}" for d in days)
        else:
            day_str = "hàng tháng"

        if interval == 1:
            return f"Hàng tháng ({day_str}) lúc {time_str}"
        return f"Mỗi {interval} tháng ({day_str}) lúc {time_str}"

    return "Không xác định"
</file>

<file path="services/reminder_service.py">
"""
Reminder Service
CRUD operations for task reminders
"""

import logging
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

import pytz

from database.connection import Database

logger = logging.getLogger(__name__)

TZ = pytz.timezone("Asia/Ho_Chi_Minh")

# Default reminder offsets before deadline
BEFORE_DEADLINE = [
    ("24h", timedelta(hours=24)),
    ("1h", timedelta(hours=1)),
    ("30m", timedelta(minutes=30)),
    ("5m", timedelta(minutes=5)),
]

# Default reminder offsets after deadline (for overdue tasks)
AFTER_DEADLINE = [
    ("1h", timedelta(hours=1)),
    ("1d", timedelta(days=1)),
]


async def create_default_reminders(
    db: Database,
    task_id: int,
    user_id: int,
    deadline: datetime,
) -> None:
    """
    Create default reminders for a task.

    Args:
        db: Database connection
        task_id: Task internal ID
        user_id: User to remind
        deadline: Task deadline
    """
    now = datetime.now(TZ)

    # Make deadline timezone-aware if needed
    if deadline.tzinfo is None:
        deadline = TZ.localize(deadline)

    # Before deadline reminders
    for offset_name, offset in BEFORE_DEADLINE:
        remind_at = deadline - offset
        if remind_at > now:
            await create_reminder(
                db, task_id, user_id, remind_at,
                "before_deadline", offset_name
            )

    # After deadline reminders (for escalation)
    for offset_name, offset in AFTER_DEADLINE:
        remind_at = deadline + offset
        await create_reminder(
            db, task_id, user_id, remind_at,
            "after_deadline", offset_name
        )

    logger.info(f"Created default reminders for task {task_id}")


async def create_reminder(
    db: Database,
    task_id: int,
    user_id: int,
    remind_at: datetime,
    reminder_type: str,
    reminder_offset: str,
) -> Optional[Dict[str, Any]]:
    """
    Create a single reminder.

    Args:
        db: Database connection
        task_id: Task internal ID
        user_id: User to remind
        remind_at: When to send reminder
        reminder_type: Type (before_deadline, after_deadline, custom)
        reminder_offset: Offset label (24h, 1h, etc.)

    Returns:
        Created reminder or None if duplicate
    """
    try:
        reminder = await db.fetch_one(
            """
            INSERT INTO reminders (task_id, user_id, remind_at, reminder_type, reminder_offset)
            VALUES ($1, $2, $3, $4, $5)
            ON CONFLICT DO NOTHING
            RETURNING *
            """,
            task_id, user_id, remind_at, reminder_type, reminder_offset
        )
        return dict(reminder) if reminder else None
    except Exception as e:
        logger.error(f"Error creating reminder: {e}")
        return None


async def get_pending_reminders(db: Database) -> List[Dict[str, Any]]:
    """
    Get all reminders due now, respecting user's reminder preferences.

    Args:
        db: Database connection

    Returns:
        List of pending reminders with task and user info
    """
    reminders = await db.fetch_all(
        """
        SELECT r.*,
               t.content, t.public_id, t.status, t.priority, t.progress, t.deadline,
               u.telegram_id, u.display_name, u.reminder_source,
               u.remind_24h, u.remind_1h, u.remind_30m, u.remind_5m, u.remind_overdue,
               u.notify_all
        FROM reminders r
        JOIN tasks t ON r.task_id = t.id
        JOIN users u ON r.user_id = u.id
        WHERE r.is_sent = false
          AND r.remind_at <= CURRENT_TIMESTAMP
          AND t.is_deleted = false
          AND t.status != 'completed'
          AND (u.reminder_source IS NULL OR u.reminder_source IN ('telegram', 'both'))
          AND u.notify_all = true
        ORDER BY r.remind_at
        LIMIT 50
        """
    )

    # Filter based on user's individual reminder preferences
    filtered = []
    for r in reminders:
        reminder = dict(r)
        offset = reminder.get("reminder_offset", "")
        reminder_type = reminder.get("reminder_type", "")

        # Map reminder_offset to user setting
        if reminder_type == "after_deadline":
            # Overdue reminders for assignee
            if reminder.get("remind_overdue", True):
                filtered.append(reminder)
        elif reminder_type == "creator_overdue":
            # Overdue reminder for creator - always send
            filtered.append(reminder)
        elif offset == "24h":
            if reminder.get("remind_24h", True):
                filtered.append(reminder)
        elif offset == "1h":
            if reminder.get("remind_1h", True):
                filtered.append(reminder)
        elif offset == "30m":
            if reminder.get("remind_30m", True):
                filtered.append(reminder)
        elif offset == "5m":
            if reminder.get("remind_5m", True):
                filtered.append(reminder)
        else:
            # Custom reminders always go through
            filtered.append(reminder)

    return filtered


async def mark_reminder_sent(
    db: Database,
    reminder_id: int,
    error: Optional[str] = None,
) -> None:
    """
    Mark a reminder as sent.

    Args:
        db: Database connection
        reminder_id: Reminder ID
        error: Error message if failed
    """
    await db.execute(
        """
        UPDATE reminders
        SET is_sent = true, sent_at = CURRENT_TIMESTAMP, error_message = $2
        WHERE id = $1
        """,
        reminder_id, error
    )


async def delete_task_reminders(db: Database, task_id: int) -> int:
    """
    Delete all unsent reminders for a task.
    Called when task is completed or deleted.

    Args:
        db: Database connection
        task_id: Task internal ID

    Returns:
        Number of reminders deleted
    """
    result = await db.execute(
        """
        DELETE FROM reminders
        WHERE task_id = $1 AND is_sent = false
        """,
        task_id
    )
    return int(result.split()[-1]) if result else 0


async def get_task_reminders(
    db: Database,
    task_id: int,
    pending_only: bool = True,
) -> List[Dict[str, Any]]:
    """
    Get all reminders for a task.

    Args:
        db: Database connection
        task_id: Task internal ID
        pending_only: Only return unsent reminders

    Returns:
        List of reminders
    """
    conditions = ["task_id = $1"]
    if pending_only:
        conditions.append("is_sent = false")

    query = f"""
        SELECT * FROM reminders
        WHERE {' AND '.join(conditions)}
        ORDER BY remind_at
    """

    reminders = await db.fetch_all(query, task_id)
    return [dict(r) for r in reminders]


async def snooze_reminder(
    db: Database,
    reminder_id: int,
    snooze_minutes: int = 30,
) -> Optional[Dict[str, Any]]:
    """
    Snooze a reminder by delaying it.

    Args:
        db: Database connection
        reminder_id: Reminder ID
        snooze_minutes: Minutes to delay

    Returns:
        Updated reminder
    """
    new_time = datetime.now(TZ) + timedelta(minutes=snooze_minutes)

    reminder = await db.fetch_one(
        """
        UPDATE reminders
        SET remind_at = $2, is_sent = false, sent_at = NULL
        WHERE id = $1
        RETURNING *
        """,
        reminder_id, new_time
    )
    return dict(reminder) if reminder else None
</file>

<file path="services/report_service.py">
"""
Report Generation Service
Generate statistical reports in CSV, Excel, and PDF formats
"""

import os
import csv
import logging
import hashlib
import hmac
import secrets
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple
from io import BytesIO

import pytz

logger = logging.getLogger(__name__)

TZ = pytz.timezone("Asia/Ho_Chi_Minh")

# Export directory - dynamically set based on bot location
BOT_NAME = os.environ.get("BOT_NAME", "default")
EXPORT_DIR = Path(f"/home/botpanel/bots/{BOT_NAME}/exports")
EXPORT_DIR.mkdir(parents=True, exist_ok=True)

# Report TTL (72 hours)
REPORT_TTL_HOURS = 72


def generate_report_id() -> str:
    """Generate unique report ID."""
    return secrets.token_hex(16)


def generate_password() -> str:
    """Generate random password for report access."""
    return secrets.token_urlsafe(12)


def hash_password(password: str) -> str:
    """Hash password for storage using PBKDF2 with salt."""
    salt = secrets.token_hex(16)
    key = hashlib.pbkdf2_hmac(
        'sha256',
        password.encode(),
        salt.encode(),
        iterations=100000
    )
    return f"{salt}${key.hex()}"


def verify_password(password: str, password_hash: str) -> bool:
    """Verify password against hash."""
    try:
        salt, stored_key = password_hash.split('$')
        key = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode(),
            salt.encode(),
            iterations=100000
        )
        return hmac.compare_digest(key.hex(), stored_key)
    except (ValueError, AttributeError):
        # Fallback for legacy SHA-256 hashes (no salt)
        return hashlib.sha256(password.encode()).hexdigest() == password_hash


async def get_tasks_for_export(
    db,
    user_id: int,
    period_start: Optional[datetime],
    period_end: Optional[datetime],
    task_filter: str = "all",
) -> List[Dict[str, Any]]:
    """
    Get tasks for export based on filter criteria.

    Args:
        db: Database connection
        user_id: User ID
        period_start: Start of period (optional)
        period_end: End of period (optional)
        task_filter: Filter type - 'all', 'created', 'assigned', 'received'

    Returns:
        List of task records
    """
    # Build filter conditions
    filter_conditions = []
    params = [user_id]
    param_idx = 2

    if task_filter == "created":
        filter_conditions.append("t.creator_id = $1")
    elif task_filter == "assigned":
        filter_conditions.append("t.creator_id = $1 AND t.assignee_id != $1")
    elif task_filter == "received":
        filter_conditions.append("t.assignee_id = $1 AND t.creator_id != $1")
    else:  # all
        filter_conditions.append("(t.creator_id = $1 OR t.assignee_id = $1)")

    if period_start:
        filter_conditions.append(f"t.created_at >= ${param_idx}")
        params.append(period_start)
        param_idx += 1

    if period_end:
        filter_conditions.append(f"t.created_at < ${param_idx}")
        params.append(period_end)
        param_idx += 1

    where_clause = " AND ".join(filter_conditions)

    query = f"""
        SELECT
            t.public_id,
            t.content,
            t.status,
            t.priority,
            t.progress,
            t.deadline,
            t.completed_at,
            t.created_at,
            t.updated_at,
            t.is_personal,
            t.group_task_id,
            creator.display_name as creator_name,
            creator.username as creator_username,
            assignee.display_name as assignee_name,
            assignee.username as assignee_username,
            g.title as group_name
        FROM tasks t
        LEFT JOIN users creator ON t.creator_id = creator.id
        LEFT JOIN users assignee ON t.assignee_id = assignee.id
        LEFT JOIN groups g ON t.group_id = g.id
        WHERE t.is_deleted = false AND {where_clause}
        ORDER BY t.created_at DESC
    """

    rows = await db.fetch_all(query, *params)
    return [dict(r) for r in rows]


async def calculate_stats_for_export(
    db,
    user_id: int,
    period_start: Optional[datetime],
    period_end: Optional[datetime],
) -> Dict[str, Any]:
    """Calculate statistics for export report."""
    params = [user_id]
    param_idx = 2

    date_filter = ""
    if period_start:
        date_filter += f" AND created_at >= ${param_idx}"
        params.append(period_start)
        param_idx += 1
    if period_end:
        date_filter += f" AND created_at < ${param_idx}"
        params.append(period_end)
        param_idx += 1

    query = f"""
        SELECT
            COUNT(*) FILTER (WHERE creator_id = $1) as tasks_created,
            COUNT(*) FILTER (WHERE creator_id = $1 AND status = 'completed') as created_completed,
            COUNT(*) FILTER (WHERE creator_id = $1 AND assignee_id != $1) as tasks_assigned,
            COUNT(*) FILTER (WHERE creator_id = $1 AND assignee_id != $1 AND status = 'completed') as assigned_completed,
            COUNT(*) FILTER (WHERE assignee_id = $1 AND creator_id != $1) as tasks_received,
            COUNT(*) FILTER (WHERE assignee_id = $1 AND creator_id != $1 AND status = 'completed') as received_completed,
            COUNT(*) FILTER (WHERE assignee_id = $1 AND is_personal = true) as personal_tasks,
            COUNT(*) FILTER (WHERE assignee_id = $1 AND is_personal = true AND status = 'completed') as personal_completed,
            COUNT(*) FILTER (WHERE (creator_id = $1 OR assignee_id = $1) AND status != 'completed' AND deadline < NOW()) as overdue
        FROM tasks
        WHERE is_deleted = false AND (creator_id = $1 OR assignee_id = $1) {date_filter}
    """

    row = await db.fetch_one(query, *params)

    if row:
        return {
            "tasks_created": row["tasks_created"] or 0,
            "created_completed": row["created_completed"] or 0,
            "tasks_assigned": row["tasks_assigned"] or 0,
            "assigned_completed": row["assigned_completed"] or 0,
            "tasks_received": row["tasks_received"] or 0,
            "received_completed": row["received_completed"] or 0,
            "personal_tasks": row["personal_tasks"] or 0,
            "personal_completed": row["personal_completed"] or 0,
            "overdue": row["overdue"] or 0,
        }
    return {}


def format_status(status: str) -> str:
    """Format status for display."""
    status_map = {
        "pending": "Chờ xử lý",
        "in_progress": "Đang làm",
        "completed": "Hoàn thành",
    }
    return status_map.get(status, status)


def format_priority(priority: str) -> str:
    """Format priority for display."""
    priority_map = {
        "urgent": "Khẩn cấp",
        "high": "Cao",
        "normal": "Bình thường",
        "low": "Thấp",
    }
    return priority_map.get(priority, priority)


def format_datetime_vn(dt: Optional[datetime]) -> str:
    """Format datetime for Vietnamese display."""
    if not dt:
        return "—"
    if dt.tzinfo is None:
        dt = TZ.localize(dt)
    else:
        dt = dt.astimezone(TZ)
    return dt.strftime("%H:%M %d/%m/%Y")


async def generate_csv_report(
    db,
    user_id: int,
    period_start: Optional[datetime],
    period_end: Optional[datetime],
    task_filter: str,
    user_name: str,
) -> Tuple[str, int]:
    """
    Generate CSV report.

    Returns:
        Tuple of (file_path, file_size)
    """
    tasks = await get_tasks_for_export(db, user_id, period_start, period_end, task_filter)
    stats = await calculate_stats_for_export(db, user_id, period_start, period_end)

    report_id = generate_report_id()
    file_path = EXPORT_DIR / f"{report_id}.csv"

    with open(file_path, 'w', newline='', encoding='utf-8-sig') as f:
        writer = csv.writer(f)

        # Header
        writer.writerow(["BÁO CÁO THỐNG KÊ CÔNG VIỆC"])
        writer.writerow(["Người dùng:", user_name])

        period_str = "Tất cả thời gian"
        if period_start and period_end:
            period_str = f"{format_datetime_vn(period_start)} - {format_datetime_vn(period_end)}"
        writer.writerow(["Khoảng thời gian:", period_str])
        writer.writerow(["Xuất lúc:", format_datetime_vn(datetime.now(TZ))])
        writer.writerow([])

        # Statistics summary
        writer.writerow(["THỐNG KÊ TỔNG HỢP"])
        writer.writerow(["Việc đã tạo:", stats.get("tasks_created", 0)])
        writer.writerow(["  - Hoàn thành:", stats.get("created_completed", 0)])
        writer.writerow(["Việc đã giao:", stats.get("tasks_assigned", 0)])
        writer.writerow(["  - Hoàn thành:", stats.get("assigned_completed", 0)])
        writer.writerow(["Việc được giao:", stats.get("tasks_received", 0)])
        writer.writerow(["  - Hoàn thành:", stats.get("received_completed", 0)])
        writer.writerow(["Việc cá nhân:", stats.get("personal_tasks", 0)])
        writer.writerow(["  - Hoàn thành:", stats.get("personal_completed", 0)])
        writer.writerow(["Việc trễ hạn:", stats.get("overdue", 0)])
        writer.writerow([])

        # Task list
        writer.writerow(["CHI TIẾT CÔNG VIỆC"])
        writer.writerow([
            "Mã việc", "Nội dung", "Trạng thái", "Ưu tiên", "Tiến độ",
            "Người tạo", "Người nhận", "Deadline", "Hoàn thành lúc", "Tạo lúc", "Nhóm"
        ])

        for task in tasks:
            writer.writerow([
                task["public_id"],
                task["content"],
                format_status(task["status"]),
                format_priority(task["priority"]),
                f"{task['progress'] or 0}%",
                task.get("creator_name") or task.get("creator_username") or "—",
                task.get("assignee_name") or task.get("assignee_username") or "—",
                format_datetime_vn(task.get("deadline")),
                format_datetime_vn(task.get("completed_at")),
                format_datetime_vn(task.get("created_at")),
                task.get("group_name") or "—",
            ])

    file_size = file_path.stat().st_size
    return str(file_path), file_size


async def generate_excel_report(
    db,
    user_id: int,
    period_start: Optional[datetime],
    period_end: Optional[datetime],
    task_filter: str,
    user_name: str,
) -> Tuple[str, int]:
    """
    Generate Excel report with charts.

    Returns:
        Tuple of (file_path, file_size)
    """
    from openpyxl import Workbook
    from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
    from openpyxl.chart import PieChart, BarChart, Reference
    from openpyxl.chart.label import DataLabelList

    tasks = await get_tasks_for_export(db, user_id, period_start, period_end, task_filter)
    stats = await calculate_stats_for_export(db, user_id, period_start, period_end)

    report_id = generate_report_id()
    file_path = EXPORT_DIR / f"{report_id}.xlsx"

    wb = Workbook()

    # ===== Sheet 1: Dashboard =====
    ws_dashboard = wb.active
    ws_dashboard.title = "Dashboard"

    # Styles
    title_font = Font(size=16, bold=True)
    header_font = Font(size=12, bold=True, color="FFFFFF")
    header_fill = PatternFill(start_color="4472C4", end_color="4472C4", fill_type="solid")
    number_font = Font(size=14, bold=True)
    thin_border = Border(
        left=Side(style='thin'),
        right=Side(style='thin'),
        top=Side(style='thin'),
        bottom=Side(style='thin')
    )

    # Title
    ws_dashboard["A1"] = "BÁO CÁO THỐNG KÊ CÔNG VIỆC"
    ws_dashboard["A1"].font = title_font
    ws_dashboard.merge_cells("A1:F1")

    ws_dashboard["A2"] = f"Người dùng: {user_name}"
    period_str = "Tất cả thời gian"
    if period_start and period_end:
        period_str = f"{format_datetime_vn(period_start)} - {format_datetime_vn(period_end)}"
    ws_dashboard["A3"] = f"Khoảng thời gian: {period_str}"
    ws_dashboard["A4"] = f"Xuất lúc: {format_datetime_vn(datetime.now(TZ))}"

    # Statistics summary - starting from row 6
    row = 6
    stats_data = [
        ("Loại", "Tổng", "Hoàn thành", "Tỷ lệ (%)"),
        ("Việc đã tạo", stats.get("tasks_created", 0), stats.get("created_completed", 0),
         round(stats.get("created_completed", 0) / max(stats.get("tasks_created", 1), 1) * 100, 1)),
        ("Việc đã giao", stats.get("tasks_assigned", 0), stats.get("assigned_completed", 0),
         round(stats.get("assigned_completed", 0) / max(stats.get("tasks_assigned", 1), 1) * 100, 1)),
        ("Việc được giao", stats.get("tasks_received", 0), stats.get("received_completed", 0),
         round(stats.get("received_completed", 0) / max(stats.get("tasks_received", 1), 1) * 100, 1)),
        ("Việc cá nhân", stats.get("personal_tasks", 0), stats.get("personal_completed", 0),
         round(stats.get("personal_completed", 0) / max(stats.get("personal_tasks", 1), 1) * 100, 1)),
    ]

    for i, row_data in enumerate(stats_data):
        for j, value in enumerate(row_data):
            cell = ws_dashboard.cell(row=row + i, column=j + 1, value=value)
            cell.border = thin_border
            if i == 0:
                cell.font = header_font
                cell.fill = header_fill
            else:
                cell.alignment = Alignment(horizontal="center") if j > 0 else Alignment(horizontal="left")

    # Adjust column widths
    ws_dashboard.column_dimensions['A'].width = 20
    ws_dashboard.column_dimensions['B'].width = 12
    ws_dashboard.column_dimensions['C'].width = 15
    ws_dashboard.column_dimensions['D'].width = 12

    # Add Pie Chart for task distribution
    chart_row = row + len(stats_data) + 2

    # Pie chart data
    ws_dashboard.cell(row=chart_row, column=6, value="Phân bổ việc")
    ws_dashboard.cell(row=chart_row + 1, column=6, value="Việc đã giao")
    ws_dashboard.cell(row=chart_row + 1, column=7, value=stats.get("tasks_assigned", 0))
    ws_dashboard.cell(row=chart_row + 2, column=6, value="Việc được giao")
    ws_dashboard.cell(row=chart_row + 2, column=7, value=stats.get("tasks_received", 0))
    ws_dashboard.cell(row=chart_row + 3, column=6, value="Việc cá nhân")
    ws_dashboard.cell(row=chart_row + 3, column=7, value=stats.get("personal_tasks", 0))

    if any([stats.get("tasks_assigned", 0), stats.get("tasks_received", 0), stats.get("personal_tasks", 0)]):
        pie_chart = PieChart()
        pie_chart.title = "Phân bổ công việc"
        labels = Reference(ws_dashboard, min_col=6, min_row=chart_row + 1, max_row=chart_row + 3)
        data = Reference(ws_dashboard, min_col=7, min_row=chart_row, max_row=chart_row + 3)
        pie_chart.add_data(data, titles_from_data=True)
        pie_chart.set_categories(labels)
        pie_chart.dataLabels = DataLabelList()
        pie_chart.dataLabels.showPercent = True
        pie_chart.dataLabels.showVal = False
        pie_chart.width = 12
        pie_chart.height = 8
        ws_dashboard.add_chart(pie_chart, "A14")

    # ===== Sheet 2: Task Details =====
    ws_tasks = wb.create_sheet("Chi tiết việc")

    # Headers
    headers = ["Mã việc", "Nội dung", "Trạng thái", "Ưu tiên", "Tiến độ",
               "Người tạo", "Người nhận", "Deadline", "Hoàn thành", "Tạo lúc", "Nhóm"]

    for col, header in enumerate(headers, 1):
        cell = ws_tasks.cell(row=1, column=col, value=header)
        cell.font = header_font
        cell.fill = header_fill
        cell.alignment = Alignment(horizontal="center")
        cell.border = thin_border

    # Task data
    status_fills = {
        "completed": PatternFill(start_color="C6EFCE", end_color="C6EFCE", fill_type="solid"),
        "in_progress": PatternFill(start_color="FFEB9C", end_color="FFEB9C", fill_type="solid"),
        "pending": PatternFill(start_color="FFC7CE", end_color="FFC7CE", fill_type="solid"),
    }

    for row_idx, task in enumerate(tasks, 2):
        row_data = [
            task["public_id"],
            task["content"][:100] + ("..." if len(task["content"]) > 100 else ""),
            format_status(task["status"]),
            format_priority(task["priority"]),
            f"{task['progress'] or 0}%",
            task.get("creator_name") or task.get("creator_username") or "—",
            task.get("assignee_name") or task.get("assignee_username") or "—",
            format_datetime_vn(task.get("deadline")),
            format_datetime_vn(task.get("completed_at")),
            format_datetime_vn(task.get("created_at")),
            task.get("group_name") or "—",
        ]

        for col_idx, value in enumerate(row_data, 1):
            cell = ws_tasks.cell(row=row_idx, column=col_idx, value=value)
            cell.border = thin_border
            if col_idx == 2:  # Content column - add text wrap
                cell.alignment = Alignment(wrap_text=True, vertical="top")
            if col_idx == 3:  # Status column
                cell.fill = status_fills.get(task["status"], PatternFill())

    # Adjust column widths
    column_widths = [12, 50, 15, 12, 10, 20, 20, 18, 18, 18, 20]
    for i, width in enumerate(column_widths, 1):
        ws_tasks.column_dimensions[chr(64 + i)].width = width

    wb.save(file_path)
    file_size = file_path.stat().st_size
    return str(file_path), file_size


async def generate_pdf_report(
    db,
    user_id: int,
    period_start: Optional[datetime],
    period_end: Optional[datetime],
    task_filter: str,
    user_name: str,
) -> Tuple[str, int]:
    """
    Generate PDF report with charts.

    Returns:
        Tuple of (file_path, file_size)
    """
    from reportlab.lib import colors
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import inch, cm
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image
    from reportlab.pdfbase import pdfmetrics
    from reportlab.pdfbase.ttfonts import TTFont
    import matplotlib.pyplot as plt
    import matplotlib
    matplotlib.use('Agg')  # Non-interactive backend

    tasks = await get_tasks_for_export(db, user_id, period_start, period_end, task_filter)
    stats = await calculate_stats_for_export(db, user_id, period_start, period_end)

    report_id = generate_report_id()
    file_path = EXPORT_DIR / f"{report_id}.pdf"

    # Register Vietnamese-compatible fonts (DejaVu Sans supports UTF-8)
    FONT_PATH = "/usr/share/fonts/truetype/dejavu/"
    try:
        pdfmetrics.registerFont(TTFont('DejaVu', f'{FONT_PATH}DejaVuSans.ttf'))
        pdfmetrics.registerFont(TTFont('DejaVu-Bold', f'{FONT_PATH}DejaVuSans-Bold.ttf'))
        FONT_NAME = 'DejaVu'
        FONT_BOLD = 'DejaVu-Bold'
    except Exception as e:
        logger.warning(f"Could not load DejaVu font: {e}, using default")
        FONT_NAME = 'Helvetica'
        FONT_BOLD = 'Helvetica-Bold'

    # Create PDF
    doc = SimpleDocTemplate(
        str(file_path),
        pagesize=A4,
        rightMargin=1.5*cm,
        leftMargin=1.5*cm,
        topMargin=1.5*cm,
        bottomMargin=1.5*cm
    )

    elements = []
    styles = getSampleStyleSheet()

    # Custom styles with Vietnamese font
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontName=FONT_BOLD,
        fontSize=18,
        spaceAfter=20,
        alignment=1  # Center
    )

    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Normal'],
        fontName=FONT_NAME,
        fontSize=10,
        spaceAfter=5,
        alignment=1
    )

    section_style = ParagraphStyle(
        'SectionTitle',
        parent=styles['Heading2'],
        fontName=FONT_BOLD,
        fontSize=14,
        spaceBefore=15,
        spaceAfter=10
    )

    # Title
    elements.append(Paragraph("BÁO CÁO THỐNG KÊ CÔNG VIỆC", title_style))
    elements.append(Paragraph(f"Người dùng: {user_name}", subtitle_style))

    period_str = "Tất cả thời gian"
    if period_start and period_end:
        period_str = f"{format_datetime_vn(period_start)} - {format_datetime_vn(period_end)}"
    elements.append(Paragraph(f"Khoảng thời gian: {period_str}", subtitle_style))
    elements.append(Paragraph(f"Xuất lúc: {format_datetime_vn(datetime.now(TZ))}", subtitle_style))
    elements.append(Spacer(1, 20))

    # Statistics summary table
    elements.append(Paragraph("THỐNG KÊ TỔNG HỢP", section_style))

    stats_data = [
        ["Loại", "Tổng", "Hoàn thành", "Tỷ lệ (%)"],
        ["Việc đã tạo", str(stats.get("tasks_created", 0)), str(stats.get("created_completed", 0)),
         f"{round(stats.get('created_completed', 0) / max(stats.get('tasks_created', 1), 1) * 100, 1)}%"],
        ["Việc đã giao", str(stats.get("tasks_assigned", 0)), str(stats.get("assigned_completed", 0)),
         f"{round(stats.get('assigned_completed', 0) / max(stats.get('tasks_assigned', 1), 1) * 100, 1)}%"],
        ["Việc được giao", str(stats.get("tasks_received", 0)), str(stats.get("received_completed", 0)),
         f"{round(stats.get('received_completed', 0) / max(stats.get('tasks_received', 1), 1) * 100, 1)}%"],
        ["Việc cá nhân", str(stats.get("personal_tasks", 0)), str(stats.get("personal_completed", 0)),
         f"{round(stats.get('personal_completed', 0) / max(stats.get('personal_tasks', 1), 1) * 100, 1)}%"],
        ["Việc trễ hạn", str(stats.get("overdue", 0)), "—", "—"],
    ]

    stats_table = Table(stats_data, colWidths=[4*cm, 3*cm, 3*cm, 3*cm])
    stats_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#4472C4')),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), FONT_BOLD),
        ('FONTNAME', (0, 1), (-1, -1), FONT_NAME),
        ('FONTSIZE', (0, 0), (-1, 0), 11),
        ('FONTSIZE', (0, 1), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
        ('TOPPADDING', (0, 0), (-1, 0), 10),
        ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#D9E2F3')),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
    ]))
    elements.append(stats_table)
    elements.append(Spacer(1, 20))

    # Generate charts
    chart_path = EXPORT_DIR / f"{report_id}_chart.png"

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))

    # Pie chart - Task distribution
    labels = ['Việc đã giao', 'Việc được giao', 'Việc cá nhân']
    sizes = [
        stats.get("tasks_assigned", 0),
        stats.get("tasks_received", 0),
        stats.get("personal_tasks", 0)
    ]
    colors_pie = ['#4472C4', '#ED7D31', '#70AD47']

    if sum(sizes) > 0:
        ax1.pie(sizes, labels=labels, colors=colors_pie, autopct='%1.1f%%', startangle=90)
        ax1.set_title('Phân bổ công việc', fontsize=12, fontweight='bold')
    else:
        ax1.text(0.5, 0.5, 'Không có dữ liệu', ha='center', va='center')
        ax1.set_title('Phân bổ công việc', fontsize=12, fontweight='bold')

    # Bar chart - Completion rates
    categories = ['Đã tạo', 'Đã giao', 'Được giao', 'Cá nhân']
    total = [
        stats.get("tasks_created", 0),
        stats.get("tasks_assigned", 0),
        stats.get("tasks_received", 0),
        stats.get("personal_tasks", 0)
    ]
    completed = [
        stats.get("created_completed", 0),
        stats.get("assigned_completed", 0),
        stats.get("received_completed", 0),
        stats.get("personal_completed", 0)
    ]

    x = range(len(categories))
    width = 0.35

    bars1 = ax2.bar([i - width/2 for i in x], total, width, label='Tổng', color='#4472C4')
    bars2 = ax2.bar([i + width/2 for i in x], completed, width, label='Hoàn thành', color='#70AD47')

    ax2.set_ylabel('Số lượng')
    ax2.set_title('Tỷ lệ hoàn thành', fontsize=12, fontweight='bold')
    ax2.set_xticks(x)
    ax2.set_xticklabels(categories, fontsize=9)
    ax2.legend()

    plt.tight_layout()
    plt.savefig(chart_path, dpi=150, bbox_inches='tight')
    plt.close()

    # Add chart image
    elements.append(Image(str(chart_path), width=16*cm, height=6.5*cm))
    elements.append(Spacer(1, 20))

    # Task list (first 30 tasks)
    if tasks:
        elements.append(Paragraph("CHI TIẾT CÔNG VIỆC", section_style))

        # Content style for wrapping text
        content_style = ParagraphStyle(
            'ContentStyle',
            parent=styles['Normal'],
            fontName=FONT_NAME,
            fontSize=8,
            leading=10,
        )

        task_data = [["Mã", "Nội dung", "Trạng thái", "Deadline"]]
        for task in tasks[:30]:
            content = task["content"][:60] + ("..." if len(task["content"]) > 60 else "")
            task_data.append([
                task["public_id"],
                Paragraph(content, content_style),
                format_status(task["status"]),
                format_datetime_vn(task.get("deadline"))[:10] if task.get("deadline") else "—"
            ])

        if len(tasks) > 30:
            task_data.append(["...", Paragraph(f"và {len(tasks) - 30} việc khác", content_style), "", ""])

        task_table = Table(task_data, colWidths=[2*cm, 9*cm, 3*cm, 3*cm])
        task_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#4472C4')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('ALIGN', (0, 0), (0, -1), 'CENTER'),
            ('ALIGN', (2, 0), (3, -1), 'CENTER'),
            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
            ('FONTNAME', (0, 0), (-1, 0), FONT_BOLD),
            ('FONTNAME', (0, 1), (0, -1), FONT_NAME),
            ('FONTNAME', (2, 1), (3, -1), FONT_NAME),
            ('FONTSIZE', (0, 0), (-1, 0), 10),
            ('FONTSIZE', (0, 1), (0, -1), 8),
            ('FONTSIZE', (2, 1), (3, -1), 8),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 8),
            ('TOPPADDING', (0, 0), (-1, 0), 8),
            ('BOTTOMPADDING', (0, 1), (-1, -1), 5),
            ('TOPPADDING', (0, 1), (-1, -1), 5),
            ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#F2F2F2')]),
        ]))
        elements.append(task_table)

    # Build PDF
    doc.build(elements)

    # Clean up chart image
    if chart_path.exists():
        chart_path.unlink()

    file_size = file_path.stat().st_size
    return str(file_path), file_size


async def create_export_report(
    db,
    user_id: int,
    user_name: str,
    report_type: str,
    file_format: str,
    task_filter: str,
    period_start: Optional[datetime] = None,
    period_end: Optional[datetime] = None,
) -> Dict[str, Any]:
    """
    Create and store an export report.

    Args:
        db: Database connection
        user_id: User ID
        user_name: User display name
        report_type: 'last7', 'last30', 'this_week', 'last_week', 'this_month', 'last_month', 'custom'
        file_format: 'csv', 'xlsx', 'pdf'
        task_filter: 'all', 'created', 'assigned', 'received'
        period_start: Start of custom period
        period_end: End of custom period

    Returns:
        Dict with report info including URL and password
    """
    now = datetime.now(TZ)

    # Calculate period based on report_type
    if report_type == "last7":
        period_start = now - timedelta(days=7)
        period_end = now
    elif report_type == "last30":
        period_start = now - timedelta(days=30)
        period_end = now
    elif report_type == "this_week":
        period_start = now - timedelta(days=now.weekday())
        period_start = period_start.replace(hour=0, minute=0, second=0, microsecond=0)
        period_end = now
    elif report_type == "last_week":
        period_end = now - timedelta(days=now.weekday())
        period_end = period_end.replace(hour=0, minute=0, second=0, microsecond=0)
        period_start = period_end - timedelta(days=7)
    elif report_type == "this_month":
        period_start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        period_end = now
    elif report_type == "last_month":
        period_end = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        if period_end.month == 1:
            period_start = period_end.replace(year=period_end.year - 1, month=12)
        else:
            period_start = period_end.replace(month=period_end.month - 1)
    # else: use provided period_start and period_end

    # Generate report based on format
    if file_format == "csv":
        file_path, file_size = await generate_csv_report(
            db, user_id, period_start, period_end, task_filter, user_name
        )
    elif file_format == "xlsx":
        file_path, file_size = await generate_excel_report(
            db, user_id, period_start, period_end, task_filter, user_name
        )
    elif file_format == "pdf":
        file_path, file_size = await generate_pdf_report(
            db, user_id, period_start, period_end, task_filter, user_name
        )
    else:
        raise ValueError(f"Unknown file format: {file_format}")

    # Generate report ID and password
    report_id = generate_report_id()
    password = generate_password()
    password_hash = hash_password(password)
    expires_at = now + timedelta(hours=REPORT_TTL_HOURS)

    # Store in database
    await db.execute(
        """
        INSERT INTO export_reports (
            report_id, password_hash, user_id, report_type, file_format,
            task_filter, period_start, period_end, file_path, file_size, expires_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
        """,
        report_id, password_hash, user_id, report_type, file_format,
        task_filter, period_start, period_end, file_path, file_size, expires_at
    )

    return {
        "report_id": report_id,
        "password": password,
        "file_format": file_format,
        "file_size": file_size,
        "expires_at": expires_at,
        "period_start": period_start,
        "period_end": period_end,
    }


async def get_report_by_id(db, report_id: str) -> Optional[Dict[str, Any]]:
    """Get report record by ID."""
    row = await db.fetch_one(
        "SELECT * FROM export_reports WHERE report_id = $1",
        report_id
    )
    return dict(row) if row else None


async def increment_download_count(db, report_id: str) -> None:
    """Increment download count for a report."""
    await db.execute(
        "UPDATE export_reports SET download_count = download_count + 1 WHERE report_id = $1",
        report_id
    )


async def cleanup_expired_reports(db) -> int:
    """Delete expired reports from database and filesystem."""
    now = datetime.now(TZ)

    # Get expired reports
    rows = await db.fetch_all(
        "SELECT id, file_path FROM export_reports WHERE expires_at < $1",
        now
    )

    deleted_count = 0
    for row in rows:
        try:
            file_path = Path(row["file_path"])
            if file_path.exists():
                file_path.unlink()
            deleted_count += 1
        except Exception as e:
            logger.warning(f"Failed to delete report file: {e}")

    # Delete from database
    await db.execute("DELETE FROM export_reports WHERE expires_at < $1", now)

    return deleted_count
</file>

<file path="services/statistics_service.py">
"""
Statistics Service
Calculate and store user statistics
"""

import logging
from datetime import datetime, date, timedelta
from typing import Any, Dict, List, Optional

import pytz

from utils.db_utils import get_report_column, InvalidColumnError

logger = logging.getLogger(__name__)

TZ = pytz.timezone("Asia/Ho_Chi_Minh")


async def calculate_user_stats(
    db,
    user_id: int,
    period_type: str,
    period_start: date,
    period_end: date,
    group_id: Optional[int] = None,
) -> Dict[str, int]:
    """Calculate stats for user in period."""

    base_query = """
        SELECT
            COUNT(*) FILTER (WHERE creator_id = $1) as assigned_total,
            COUNT(*) FILTER (WHERE creator_id = $1 AND status = 'completed') as assigned_completed,
            COUNT(*) FILTER (WHERE creator_id = $1 AND status != 'completed' AND deadline < CURRENT_TIMESTAMP) as assigned_overdue,

            COUNT(*) FILTER (WHERE assignee_id = $1 AND creator_id != $1) as received_total,
            COUNT(*) FILTER (WHERE assignee_id = $1 AND creator_id != $1 AND status = 'completed') as received_completed,
            COUNT(*) FILTER (WHERE assignee_id = $1 AND creator_id != $1 AND status != 'completed' AND deadline < CURRENT_TIMESTAMP) as received_overdue,

            COUNT(*) FILTER (WHERE assignee_id = $1 AND creator_id = $1 AND is_personal = true) as personal_total,
            COUNT(*) FILTER (WHERE assignee_id = $1 AND creator_id = $1 AND is_personal = true AND status = 'completed') as personal_completed
        FROM tasks
        WHERE is_deleted = false
          AND created_at >= $2
          AND created_at < $3
    """

    if group_id:
        base_query += " AND group_id = $4"
        row = await db.fetch_one(base_query, user_id, period_start, period_end, group_id)
    else:
        row = await db.fetch_one(base_query, user_id, period_start, period_end)

    if row:
        return {
            "assigned_total": row["assigned_total"] or 0,
            "assigned_completed": row["assigned_completed"] or 0,
            "assigned_overdue": row["assigned_overdue"] or 0,
            "received_total": row["received_total"] or 0,
            "received_completed": row["received_completed"] or 0,
            "received_overdue": row["received_overdue"] or 0,
            "personal_total": row["personal_total"] or 0,
            "personal_completed": row["personal_completed"] or 0,
        }
    return {}


async def calculate_all_time_stats(db, user_id: int) -> Dict[str, int]:
    """Calculate all-time stats for user."""
    row = await db.fetch_one(
        """
        SELECT
            COUNT(*) FILTER (WHERE creator_id = $1) as total_assigned,
            COUNT(*) FILTER (WHERE creator_id = $1 AND status = 'completed') as assigned_done,
            COUNT(*) FILTER (WHERE assignee_id = $1 AND creator_id != $1) as total_received,
            COUNT(*) FILTER (WHERE assignee_id = $1 AND creator_id != $1 AND status = 'completed') as received_done,
            COUNT(*) FILTER (WHERE assignee_id = $1 AND is_personal = true) as total_personal,
            COUNT(*) FILTER (WHERE assignee_id = $1 AND is_personal = true AND status = 'completed') as personal_done
        FROM tasks
        WHERE is_deleted = false AND (creator_id = $1 OR assignee_id = $1)
        """,
        user_id,
    )

    if row:
        return {
            "total_assigned": row["total_assigned"] or 0,
            "assigned_done": row["assigned_done"] or 0,
            "total_received": row["total_received"] or 0,
            "received_done": row["received_done"] or 0,
            "total_personal": row["total_personal"] or 0,
            "personal_done": row["personal_done"] or 0,
        }
    return {}


async def store_user_stats(
    db,
    user_id: int,
    group_id: Optional[int],
    period_type: str,
    stats: Dict[str, int],
    period_start: date,
    period_end: date,
) -> None:
    """Store calculated stats."""
    await db.execute(
        """
        INSERT INTO user_statistics (
            user_id, group_id, period_type, period_start, period_end,
            tasks_assigned_total, tasks_assigned_completed, tasks_assigned_overdue,
            tasks_received_total, tasks_received_completed, tasks_received_overdue,
            tasks_personal_total, tasks_personal_completed
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
        ON CONFLICT (user_id, COALESCE(group_id, 0), period_type, period_start)
        DO UPDATE SET
            tasks_assigned_total = $6,
            tasks_assigned_completed = $7,
            tasks_assigned_overdue = $8,
            tasks_received_total = $9,
            tasks_received_completed = $10,
            tasks_received_overdue = $11,
            tasks_personal_total = $12,
            tasks_personal_completed = $13,
            updated_at = CURRENT_TIMESTAMP
        """,
        user_id,
        group_id,
        period_type,
        period_start,
        period_end,
        stats.get("assigned_total", 0),
        stats.get("assigned_completed", 0),
        stats.get("assigned_overdue", 0),
        stats.get("received_total", 0),
        stats.get("received_completed", 0),
        stats.get("received_overdue", 0),
        stats.get("personal_total", 0),
        stats.get("personal_completed", 0),
    )


def get_week_range() -> tuple:
    """Get current week's start/end (Mon-Sun)."""
    today = datetime.now(TZ).date()
    start = today - timedelta(days=today.weekday())
    end = start + timedelta(days=7)
    return start, end


def get_previous_week_range() -> tuple:
    """Get previous week's start/end."""
    today = datetime.now(TZ).date()
    start = today - timedelta(days=today.weekday() + 7)
    end = start + timedelta(days=7)
    return start, end


def get_month_range() -> tuple:
    """Get current month's start/end."""
    today = datetime.now(TZ).date()
    start = today.replace(day=1)
    if start.month == 12:
        next_month = start.replace(year=start.year + 1, month=1)
    else:
        next_month = start.replace(month=start.month + 1)
    return start, next_month


def get_previous_month_range() -> tuple:
    """Get previous month's start/end."""
    today = datetime.now(TZ).date()
    end = today.replace(day=1)
    if end.month == 1:
        start = end.replace(year=end.year - 1, month=12)
    else:
        start = end.replace(month=end.month - 1)
    return start, end


async def get_group_rankings(
    db, group_id: int, period_type: str, period_start: date
) -> List[Dict[str, Any]]:
    """Get user rankings in group."""
    rows = await db.fetch_all(
        """
        SELECT us.*, u.display_name, u.username,
               CASE
                   WHEN us.tasks_received_total > 0
                   THEN (us.tasks_received_completed::float / us.tasks_received_total * 100)
                   ELSE 0
               END as completion_rate
        FROM user_statistics us
        JOIN users u ON us.user_id = u.id
        WHERE us.group_id = $1
          AND us.period_type = $2
          AND us.period_start = $3
        ORDER BY completion_rate DESC NULLS LAST
        """,
        group_id,
        period_type,
        period_start,
    )
    return [dict(r) for r in rows]


async def get_active_users_for_report(db, report_type: str = "weekly") -> List[Dict]:
    """Get users who have report notification enabled."""
    try:
        column = get_report_column(report_type)
    except InvalidColumnError:
        logger.warning(f"Invalid report type: {report_type}")
        return []

    # Use validated column - safe from SQL injection
    rows = await db.fetch_all(
        f"""
        SELECT id, telegram_id, display_name, username
        FROM users
        WHERE is_active = true AND {column} = true
        """
    )
    return [dict(r) for r in rows]


async def get_user_groups(db, user_id: int) -> List[Dict]:
    """Get groups user belongs to."""
    rows = await db.fetch_all(
        """
        SELECT g.id, g.title
        FROM groups g
        JOIN group_members gm ON g.id = gm.group_id
        WHERE gm.user_id = $1 AND g.is_active = true
        """,
        user_id,
    )
    return [dict(r) for r in rows]


async def get_overdue_tasks(
    db,
    user_id: int,
    period: str = "all",
) -> List[Dict[str, Any]]:
    """
    Get overdue tasks for user.

    Args:
        db: Database connection
        user_id: User ID
        period: Filter period - 'day' (today), 'week', 'month', 'all'

    Returns:
        List of overdue task records
    """
    now = datetime.now(TZ)

    # Build date filter based on period
    if period == "day":
        # Today only
        period_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        period_filter = "AND deadline >= $3"
    elif period == "week":
        # This week (Mon-Sun)
        today = now.date()
        week_start = today - timedelta(days=today.weekday())
        period_start = datetime.combine(week_start, datetime.min.time()).replace(tzinfo=TZ)
        period_filter = "AND deadline >= $3"
    elif period == "month":
        # This month
        period_start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        period_filter = "AND deadline >= $3"
    else:
        # All overdue
        period_start = None
        period_filter = ""

    base_query = f"""
        SELECT t.*, u.display_name as creator_name,
               g.title as group_name
        FROM tasks t
        LEFT JOIN users u ON t.creator_id = u.id
        LEFT JOIN groups g ON t.group_id = g.id
        WHERE (t.assignee_id = $1 OR t.creator_id = $1)
          AND t.is_deleted = false
          AND t.status != 'completed'
          AND t.deadline IS NOT NULL
          AND t.deadline < $2
          {period_filter}
        ORDER BY t.deadline ASC
    """

    if period_start:
        rows = await db.fetch_all(base_query, user_id, now, period_start)
    else:
        rows = await db.fetch_all(base_query.replace("$3", ""), user_id, now)

    return [dict(r) for r in rows]


async def get_overdue_stats(
    db,
    user_id: int,
) -> Dict[str, int]:
    """
    Get overdue task counts by period.

    Args:
        db: Database connection
        user_id: User ID

    Returns:
        Dict with overdue counts: today, this_week, this_month, total
    """
    now = datetime.now(TZ)
    today_start = now.replace(hour=0, minute=0, second=0, microsecond=0)
    week_start = datetime.combine(
        now.date() - timedelta(days=now.date().weekday()),
        datetime.min.time()
    ).replace(tzinfo=TZ)
    month_start = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)

    row = await db.fetch_one(
        """
        SELECT
            COUNT(*) FILTER (WHERE deadline >= $3) as today,
            COUNT(*) FILTER (WHERE deadline >= $4) as this_week,
            COUNT(*) FILTER (WHERE deadline >= $5) as this_month,
            COUNT(*) as total
        FROM tasks
        WHERE (assignee_id = $1 OR creator_id = $1)
          AND is_deleted = false
          AND status != 'completed'
          AND deadline IS NOT NULL
          AND deadline < $2
        """,
        user_id, now, today_start, week_start, month_start,
    )

    if row:
        return {
            "today": row["today"] or 0,
            "this_week": row["this_week"] or 0,
            "this_month": row["this_month"] or 0,
            "total": row["total"] or 0,
        }
    return {"today": 0, "this_week": 0, "this_month": 0, "total": 0}
</file>

<file path="services/task_service.py">
"""
Task Service
CRUD operations for tasks
"""

import json
import logging
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional
import pytz

from database.connection import Database

logger = logging.getLogger(__name__)

# Timezone
TZ = pytz.timezone("Asia/Ho_Chi_Minh")


async def generate_task_id(db: Database, prefix: str = "P") -> str:
    """
    Generate unique task ID using PostgreSQL sequence.

    Uses atomic sequence to prevent race conditions in concurrent task creation.

    Args:
        db: Database connection
        prefix: Task ID prefix - P (personal/individual), G (group parent)

    Returns:
        Task ID like P0001, G0001
    """
    # Validate prefix
    if prefix not in ("P", "G"):
        prefix = "P"

    # Atomic sequence increment - no race conditions
    result = await db.fetch_one(
        "SELECT nextval('task_id_seq') as counter"
    )

    counter = int(result["counter"]) if result else 1

    # Format: P0001-P9999 (4 digits), P10000+ grows automatically
    return f"{prefix}{counter:04d}"


async def create_task(
    db: Database,
    content: str,
    creator_id: int,
    assignee_id: int,
    deadline: Optional[datetime] = None,
    priority: str = "normal",
    is_personal: bool = True,
    group_id: Optional[int] = None,
    description: str = None,
    group_task_id: str = None,
) -> Dict[str, Any]:
    """
    Create a new task.

    Args:
        db: Database connection
        content: Task content
        creator_id: Creator user ID
        assignee_id: Assignee user ID
        deadline: Task deadline
        priority: Task priority (low/normal/high/urgent)
        is_personal: True for personal task
        group_id: Group ID (for group tasks)
        description: Optional description
        group_task_id: Parent group task ID (for multi-assignee)

    Returns:
        Created task record
    """
    # Generate unique public ID
    # P-xxx for all individual tasks, G-xxx for group parent tasks
    public_id = await generate_task_id(db, prefix="P")

    task = await db.fetch_one(
        """
        INSERT INTO tasks (
            public_id, content, description, creator_id, assignee_id,
            deadline, priority, is_personal, group_id, group_task_id
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
        RETURNING *
        """,
        public_id,
        content,
        description,
        creator_id,
        assignee_id,
        deadline,
        priority,
        is_personal,
        group_id,
        group_task_id,
    )

    # Log history
    await add_task_history(
        db,
        task["id"],
        creator_id,
        action="created",
        note=f"Task created: {content[:50]}"
    )

    # Create default reminders if deadline exists
    if deadline:
        await create_default_reminders(db, task["id"], assignee_id, deadline, creator_id)

    # Auto-sync to Google Calendar if enabled
    if deadline:
        try:
            from services.calendar_service import (
                is_calendar_enabled,
                get_user_token_data,
                create_calendar_event,
                get_user_reminder_source,
            )
            if is_calendar_enabled():
                token_data = await get_user_token_data(db, assignee_id)
                if token_data:
                    reminder_source = await get_user_reminder_source(db, assignee_id)
                    event_id = await create_calendar_event(
                        token_data,
                        public_id,
                        content,
                        deadline,
                        description or "",
                        priority,
                        reminder_source,
                    )
                    if event_id:
                        await db.execute(
                            "UPDATE tasks SET google_event_id = $2 WHERE id = $1",
                            task["id"], event_id
                        )
                        logger.info(f"Task {public_id} synced to calendar: {event_id}")
        except Exception as e:
            logger.warning(f"Calendar sync failed for task {public_id}: {e}")

    logger.info(f"Created task {public_id}: {content[:30]}...")
    return dict(task)


async def get_task_by_public_id(db: Database, public_id: str) -> Optional[Dict[str, Any]]:
    """
    Get task by public ID (P-xxxx or G-xxxx).

    Args:
        db: Database connection
        public_id: Task public ID

    Returns:
        Task record or None
    """
    task = await db.fetch_one(
        """
        SELECT t.*, u.display_name as assignee_name, c.display_name as creator_name,
               g.title as group_name
        FROM tasks t
        LEFT JOIN users u ON t.assignee_id = u.id
        LEFT JOIN users c ON t.creator_id = c.id
        LEFT JOIN groups g ON t.group_id = g.id
        WHERE t.public_id = $1 AND t.is_deleted = false
        """,
        public_id.upper()
    )
    return dict(task) if task else None


async def get_task_by_id(db: Database, task_id: int) -> Optional[Dict[str, Any]]:
    """Get task by internal ID."""
    task = await db.fetch_one(
        """
        SELECT t.*, u.display_name as assignee_name, c.display_name as creator_name,
               g.title as group_name
        FROM tasks t
        LEFT JOIN users u ON t.assignee_id = u.id
        LEFT JOIN users c ON t.creator_id = c.id
        LEFT JOIN groups g ON t.group_id = g.id
        WHERE t.id = $1 AND t.is_deleted = false
        """,
        task_id
    )
    return dict(task) if task else None


async def get_user_tasks(
    db: Database,
    user_id: int,
    status: Optional[str] = None,
    limit: int = 20,
    offset: int = 0,
    include_completed: bool = False,
) -> List[Dict[str, Any]]:
    """
    Get tasks assigned to user.

    Args:
        db: Database connection
        user_id: Assignee user ID
        status: Filter by status
        limit: Max results
        offset: Skip results
        include_completed: Include completed tasks

    Returns:
        List of task records
    """
    conditions = ["t.assignee_id = $1", "t.is_deleted = false"]
    params = [user_id]

    if status:
        conditions.append(f"t.status = ${len(params) + 1}")
        params.append(status)
    elif not include_completed:
        conditions.append("t.status != 'completed'")

    query = f"""
        SELECT t.*, u.display_name as creator_name
        FROM tasks t
        LEFT JOIN users u ON t.creator_id = u.id
        WHERE {' AND '.join(conditions)}
        ORDER BY
            CASE t.priority
                WHEN 'urgent' THEN 1
                WHEN 'high' THEN 2
                WHEN 'normal' THEN 3
                WHEN 'low' THEN 4
            END,
            t.deadline ASC NULLS LAST,
            t.created_at DESC
        LIMIT ${len(params) + 1} OFFSET ${len(params) + 2}
    """

    tasks = await db.fetch_all(query, *params, limit, offset)
    return [dict(t) for t in tasks]


async def get_user_created_tasks(
    db: Database,
    user_id: int,
    limit: int = 20,
    offset: int = 0,
) -> List[Dict[str, Any]]:
    """Get tasks created by user (assigned to others)."""
    tasks = await db.fetch_all(
        """
        SELECT t.*, u.display_name as assignee_name
        FROM tasks t
        LEFT JOIN users u ON t.assignee_id = u.id
        WHERE t.creator_id = $1
        AND t.assignee_id != $1
        AND t.is_deleted = false
        ORDER BY t.created_at DESC
        LIMIT $2 OFFSET $3
        """,
        user_id, limit, offset
    )
    return [dict(t) for t in tasks]


async def get_user_received_tasks(
    db: Database,
    user_id: int,
    limit: int = 20,
    offset: int = 0,
    include_completed: bool = False,
) -> List[Dict[str, Any]]:
    """Get tasks assigned TO the user BY others (not self-created)."""
    status_filter = "" if include_completed else "AND t.status != 'completed'"
    tasks = await db.fetch_all(
        f"""
        SELECT t.*, c.display_name as creator_name
        FROM tasks t
        LEFT JOIN users c ON t.creator_id = c.id
        WHERE t.assignee_id = $1
        AND t.creator_id != $1
        AND t.is_deleted = false
        {status_filter}
        ORDER BY
            CASE t.priority
                WHEN 'urgent' THEN 1
                WHEN 'high' THEN 2
                WHEN 'normal' THEN 3
                WHEN 'low' THEN 4
            END,
            t.deadline ASC NULLS LAST,
            t.created_at DESC
        LIMIT $2 OFFSET $3
        """,
        user_id, limit, offset
    )
    return [dict(t) for t in tasks]


async def get_user_personal_tasks(
    db: Database,
    user_id: int,
    limit: int = 20,
    offset: int = 0,
    include_completed: bool = False,
) -> List[Dict[str, Any]]:
    """Get personal tasks (created by user for themselves)."""
    status_filter = "" if include_completed else "AND t.status != 'completed'"
    tasks = await db.fetch_all(
        f"""
        SELECT t.*, u.display_name as creator_name
        FROM tasks t
        LEFT JOIN users u ON t.creator_id = u.id
        WHERE t.creator_id = $1
        AND t.assignee_id = $1
        AND t.is_deleted = false
        {status_filter}
        ORDER BY
            CASE t.priority
                WHEN 'urgent' THEN 1
                WHEN 'high' THEN 2
                WHEN 'normal' THEN 3
                WHEN 'low' THEN 4
            END,
            t.deadline ASC NULLS LAST,
            t.created_at DESC
        LIMIT $2 OFFSET $3
        """,
        user_id, limit, offset
    )
    return [dict(t) for t in tasks]


async def get_all_user_related_tasks(
    db: Database,
    user_id: int,
    limit: int = 20,
    offset: int = 0,
    include_completed: bool = False,
) -> List[Dict[str, Any]]:
    """Get ALL tasks related to user (created, received, or assigned)."""
    status_filter = "" if include_completed else "AND t.status != 'completed'"
    tasks = await db.fetch_all(
        f"""
        SELECT t.*,
            u.display_name as assignee_name,
            c.display_name as creator_name
        FROM tasks t
        LEFT JOIN users u ON t.assignee_id = u.id
        LEFT JOIN users c ON t.creator_id = c.id
        WHERE (t.assignee_id = $1 OR t.creator_id = $1)
        AND t.is_deleted = false
        {status_filter}
        ORDER BY
            CASE t.priority
                WHEN 'urgent' THEN 1
                WHEN 'high' THEN 2
                WHEN 'normal' THEN 3
                WHEN 'low' THEN 4
            END,
            t.deadline ASC NULLS LAST,
            t.created_at DESC
        LIMIT $2 OFFSET $3
        """,
        user_id, limit, offset
    )
    return [dict(t) for t in tasks]


async def get_group_tasks(
    db: Database,
    group_id: int,
    limit: int = 50,
    offset: int = 0,
) -> List[Dict[str, Any]]:
    """Get all tasks in a group."""
    tasks = await db.fetch_all(
        """
        SELECT t.*,
            u.display_name as assignee_name,
            c.display_name as creator_name
        FROM tasks t
        LEFT JOIN users u ON t.assignee_id = u.id
        LEFT JOIN users c ON t.creator_id = c.id
        WHERE t.group_id = $1 AND t.is_deleted = false
        ORDER BY t.created_at DESC
        LIMIT $2 OFFSET $3
        """,
        group_id, limit, offset
    )
    return [dict(t) for t in tasks]


async def update_task_status(
    db: Database,
    task_id: int,
    status: str,
    user_id: int,
    progress: Optional[int] = None,
) -> Optional[Dict[str, Any]]:
    """
    Update task status.

    Args:
        db: Database connection
        task_id: Task ID
        status: New status
        user_id: User making the change
        progress: Optional progress percentage

    Returns:
        Updated task record
    """
    # Get current task
    current = await get_task_by_id(db, task_id)
    if not current:
        return None

    old_status = current["status"]

    # Set completed_at if completing
    completed_at = None
    if status == "completed":
        completed_at = datetime.now()
        progress = 100

    task = await db.fetch_one(
        """
        UPDATE tasks SET
            status = $2,
            progress = COALESCE($3, progress),
            completed_at = $4,
            updated_at = NOW()
        WHERE id = $1
        RETURNING *
        """,
        task_id, status, progress, completed_at
    )

    # Log history
    await add_task_history(
        db, task_id, user_id,
        action="status_changed",
        field_name="status",
        old_value=old_status,
        new_value=status
    )

    # Update Google Calendar event if completed
    if status == "completed" and current.get("google_event_id"):
        try:
            from services.calendar_service import (
                is_calendar_enabled,
                get_user_token_data,
                update_calendar_event,
            )
            if is_calendar_enabled():
                token_data = await get_user_token_data(db, current.get("assignee_id"))
                if token_data and current.get("deadline"):
                    await update_calendar_event(
                        token_data, current["google_event_id"],
                        current["public_id"], current["content"],
                        current["deadline"], current.get("description", ""),
                        current.get("priority", "normal"), "completed",
                    )
        except Exception as e:
            logger.warning(f"Calendar update failed for task {task_id}: {e}")

    # Update parent task progress if this is a child task
    if current.get("parent_task_id"):
        try:
            parent_id = current["parent_task_id"]
            # Get all child tasks' status
            children = await db.fetch_all(
                """
                SELECT status, progress FROM tasks
                WHERE parent_task_id = $1 AND is_deleted = false
                """,
                parent_id
            )
            if children:
                total = len(children)
                completed = sum(1 for c in children if c["status"] == "completed")
                avg_progress = sum(c["progress"] or 0 for c in children) // total

                # Determine parent status
                if completed == total:
                    parent_status = "completed"
                    parent_progress = 100
                elif completed > 0 or any(c["status"] == "in_progress" for c in children):
                    parent_status = "in_progress"
                    parent_progress = avg_progress
                else:
                    parent_status = "pending"
                    parent_progress = 0

                # Update parent
                if parent_status == "completed":
                    await db.execute(
                        """
                        UPDATE tasks SET
                            status = $2,
                            progress = $3,
                            completed_at = NOW(),
                            updated_at = NOW()
                        WHERE id = $1
                        """,
                        parent_id, parent_status, parent_progress
                    )
                else:
                    await db.execute(
                        """
                        UPDATE tasks SET
                            status = $2,
                            progress = $3,
                            completed_at = NULL,
                            updated_at = NOW()
                        WHERE id = $1
                        """,
                        parent_id, parent_status, parent_progress
                    )
                logger.info(f"Updated parent task {parent_id}: status={parent_status}, progress={parent_progress}%")
        except Exception as e:
            logger.warning(f"Failed to update parent task: {e}")

    return dict(task) if task else None


async def update_task_progress(
    db: Database,
    task_id: int,
    progress: int,
    user_id: int,
) -> Optional[Dict[str, Any]]:
    """Update task progress percentage."""
    # Validate progress
    progress = max(0, min(100, progress))

    # Get current
    current = await get_task_by_id(db, task_id)
    if not current:
        return None

    # Auto-update status based on progress
    status = current["status"]
    if progress == 100 and status != "completed":
        status = "completed"
    elif progress > 0 and status == "pending":
        status = "in_progress"

    return await update_task_status(db, task_id, status, user_id, progress)


async def update_task_content(
    db: Database,
    task_id: int,
    content: str,
    user_id: int,
) -> Optional[Dict[str, Any]]:
    """Update task content."""
    current = await get_task_by_id(db, task_id)
    if not current:
        return None

    old_content = current["content"]

    task = await db.fetch_one(
        """
        UPDATE tasks SET
            content = $2,
            updated_at = NOW()
        WHERE id = $1
        RETURNING *
        """,
        task_id, content
    )

    await add_task_history(
        db, task_id, user_id,
        action="content_changed",
        field_name="content",
        old_value=old_content[:100] if old_content else None,
        new_value=content[:100]
    )

    # Sync to Google Calendar if task has event
    if task and current.get("google_event_id"):
        try:
            from services.calendar_service import (
                is_calendar_enabled,
                get_user_token_data,
                update_calendar_event,
            )
            if is_calendar_enabled():
                assignee_id = current.get("assignee_id")
                token_data = await get_user_token_data(db, assignee_id)
                if token_data:
                    await update_calendar_event(
                        token_data, current["google_event_id"],
                        current["public_id"], content,  # Use new content
                        current.get("deadline"), current.get("description", ""),
                        current.get("priority", "normal"),
                        current.get("status", "pending"),
                    )
                    logger.info(f"Updated calendar event for task {task_id} content change")
        except Exception as e:
            logger.warning(f"Calendar sync failed for task {task_id}: {e}")

    return dict(task) if task else None


async def update_task_deadline(
    db: Database,
    task_id: int,
    deadline: Optional[datetime],
    user_id: int,
) -> Optional[Dict[str, Any]]:
    """Update task deadline."""
    current = await get_task_by_id(db, task_id)
    if not current:
        return None

    old_deadline = current.get("deadline")

    task = await db.fetch_one(
        """
        UPDATE tasks SET
            deadline = $2,
            updated_at = NOW()
        WHERE id = $1
        RETURNING *
        """,
        task_id, deadline
    )

    await add_task_history(
        db, task_id, user_id,
        action="deadline_changed",
        field_name="deadline",
        old_value=str(old_deadline) if old_deadline else None,
        new_value=str(deadline) if deadline else None
    )

    # Sync to Google Calendar
    if deadline and task:
        try:
            from services.calendar_service import (
                is_calendar_enabled,
                get_user_token_data,
                create_calendar_event,
                update_calendar_event,
                get_user_reminder_source,
            )
            if is_calendar_enabled():
                assignee_id = current.get("assignee_id")
                token_data = await get_user_token_data(db, assignee_id)
                if token_data:
                    reminder_source = await get_user_reminder_source(db, assignee_id)
                    event_id = current.get("google_event_id")
                    if event_id:
                        # Update existing event
                        await update_calendar_event(
                            token_data, event_id,
                            current["public_id"], current["content"],
                            deadline, current.get("description", ""),
                            current.get("priority", "normal"),
                            current.get("status", "pending"),
                        )
                    else:
                        # Create new event
                        new_event_id = await create_calendar_event(
                            token_data,
                            current["public_id"], current["content"],
                            deadline, current.get("description", ""),
                            current.get("priority", "normal"),
                            reminder_source,
                        )
                        if new_event_id:
                            await db.execute(
                                "UPDATE tasks SET google_event_id = $2 WHERE id = $1",
                                task_id, new_event_id
                            )
        except Exception as e:
            logger.warning(f"Calendar sync failed for task {task_id}: {e}")

    return dict(task) if task else None


async def update_task_priority(
    db: Database,
    task_id: int,
    priority: str,
    user_id: int,
) -> Optional[Dict[str, Any]]:
    """Update task priority."""
    current = await get_task_by_id(db, task_id)
    if not current:
        return None

    old_priority = current.get("priority", "normal")

    task = await db.fetch_one(
        """
        UPDATE tasks SET
            priority = $2,
            updated_at = NOW()
        WHERE id = $1
        RETURNING *
        """,
        task_id, priority
    )

    await add_task_history(
        db, task_id, user_id,
        action="priority_changed",
        field_name="priority",
        old_value=old_priority,
        new_value=priority
    )

    return dict(task) if task else None


async def update_task_assignee(
    db: Database,
    task_id: int,
    new_assignee_id: int,
    user_id: int,
) -> Optional[Dict[str, Any]]:
    """Update task assignee."""
    current = await get_task_by_id(db, task_id)
    if not current:
        return None

    old_assignee_id = current.get("assignee_id")

    # Get old assignee name
    old_assignee = await db.fetch_one(
        "SELECT display_name FROM users WHERE id = $1",
        old_assignee_id
    )
    old_name = old_assignee["display_name"] if old_assignee else str(old_assignee_id)

    # Get new assignee name
    new_assignee = await db.fetch_one(
        "SELECT display_name FROM users WHERE id = $1",
        new_assignee_id
    )
    new_name = new_assignee["display_name"] if new_assignee else str(new_assignee_id)

    task = await db.fetch_one(
        """
        UPDATE tasks SET
            assignee_id = $2,
            updated_at = NOW()
        WHERE id = $1
        RETURNING *
        """,
        task_id, new_assignee_id
    )

    await add_task_history(
        db, task_id, user_id,
        action="assignee_changed",
        field_name="assignee_id",
        old_value=old_name,
        new_value=new_name
    )

    return dict(task) if task else None


async def soft_delete_task(
    db: Database,
    task_id: int,
    user_id: int,
) -> Optional[Dict[str, Any]]:
    """
    Soft delete task with 30-second undo window.

    Args:
        db: Database connection
        task_id: Task ID
        user_id: User deleting the task

    Returns:
        Undo record for restoring
    """
    task = await get_task_by_id(db, task_id)
    if not task:
        return None

    # Store in undo buffer
    expires_at = datetime.now() + timedelta(seconds=30)
    undo = await db.fetch_one(
        """
        INSERT INTO deleted_tasks_undo (task_id, task_data, deleted_by, expires_at)
        VALUES ($1, $2, $3, $4)
        RETURNING *
        """,
        task_id,
        json.dumps(task, default=str),
        user_id,
        expires_at
    )

    # Mark task as deleted
    await db.execute(
        """
        UPDATE tasks SET
            is_deleted = true,
            deleted_at = NOW(),
            deleted_by = $2,
            updated_at = NOW()
        WHERE id = $1
        """,
        task_id, user_id
    )

    # Log history
    await add_task_history(
        db, task_id, user_id,
        action="deleted",
        note="Task deleted (30s undo available)"
    )

    # Delete from Google Calendar if event exists
    if task.get("google_event_id"):
        try:
            from services.calendar_service import (
                is_calendar_enabled,
                get_user_token_data,
                delete_calendar_event,
            )
            if is_calendar_enabled():
                assignee_id = task.get("assignee_id")
                token_data = await get_user_token_data(db, assignee_id)
                if token_data:
                    await delete_calendar_event(token_data, task["google_event_id"])
                    # Clear google_event_id so restore can recreate
                    await db.execute(
                        "UPDATE tasks SET google_event_id = NULL WHERE id = $1",
                        task_id
                    )
                    logger.info(f"Deleted calendar event for task {task_id}")
        except Exception as e:
            logger.warning(f"Calendar delete failed for task {task_id}: {e}")

    return dict(undo) if undo else None


async def restore_task(db: Database, undo_id: int) -> Optional[Dict[str, Any]]:
    """
    Restore deleted task from undo buffer.

    Args:
        db: Database connection
        undo_id: Undo record ID

    Returns:
        Restored task record
    """
    # Get undo record
    undo = await db.fetch_one(
        """
        SELECT * FROM deleted_tasks_undo
        WHERE id = $1 AND is_restored = false AND expires_at > NOW()
        """,
        undo_id
    )

    if not undo:
        return None

    task_id = undo["task_id"]

    # Restore task
    await db.execute(
        """
        UPDATE tasks SET
            is_deleted = false,
            deleted_at = NULL,
            deleted_by = NULL,
            updated_at = NOW()
        WHERE id = $1
        """,
        task_id
    )

    # Mark undo as used
    await db.execute(
        "UPDATE deleted_tasks_undo SET is_restored = true WHERE id = $1",
        undo_id
    )

    # Log history
    await add_task_history(
        db, task_id, undo["deleted_by"],
        action="restored",
        note="Task restored from undo"
    )

    # Get restored task
    task = await get_task_by_id(db, task_id)

    # Recreate Google Calendar event if task has deadline
    if task and task.get("deadline") and not task.get("google_event_id"):
        try:
            from services.calendar_service import (
                is_calendar_enabled,
                get_user_token_data,
                create_calendar_event,
                get_user_reminder_source,
            )
            if is_calendar_enabled():
                assignee_id = task.get("assignee_id")
                token_data = await get_user_token_data(db, assignee_id)
                if token_data:
                    reminder_source = await get_user_reminder_source(db, assignee_id)
                    event_id = await create_calendar_event(
                        token_data,
                        task["public_id"], task["content"],
                        task["deadline"], task.get("description", ""),
                        task.get("priority", "normal"),
                        reminder_source,
                    )
                    if event_id:
                        await db.execute(
                            "UPDATE tasks SET google_event_id = $2 WHERE id = $1",
                            task_id, event_id
                        )
                        task["google_event_id"] = event_id
                        logger.info(f"Recreated calendar event for restored task {task_id}: {event_id}")
        except Exception as e:
            logger.warning(f"Calendar recreation failed for task {task_id}: {e}")

    return task


async def get_tasks_created_by_user(
    db: Database,
    user_id: int,
    include_assigned_to_others: bool = True,
) -> List[Dict[str, Any]]:
    """
    Get all non-deleted tasks created by user.

    Args:
        db: Database connection
        user_id: Creator user ID
        include_assigned_to_others: Include tasks assigned to others

    Returns:
        List of tasks
    """
    if include_assigned_to_others:
        query = """
            SELECT t.*, u.display_name as assignee_name
            FROM tasks t
            LEFT JOIN users u ON t.assignee_id = u.id
            WHERE t.creator_id = $1 AND t.is_deleted = false
            ORDER BY t.created_at DESC
        """
    else:
        # Only tasks assigned to self
        query = """
            SELECT t.*, u.display_name as assignee_name
            FROM tasks t
            LEFT JOIN users u ON t.assignee_id = u.id
            WHERE t.creator_id = $1 AND t.assignee_id = $1 AND t.is_deleted = false
            ORDER BY t.created_at DESC
        """

    tasks = await db.fetch_all(query, user_id)
    return [dict(t) for t in tasks]


async def get_tasks_assigned_to_others(
    db: Database,
    creator_id: int,
) -> List[Dict[str, Any]]:
    """
    Get tasks created by user but assigned to others (not self).
    Includes:
    - Group tasks (G-IDs) that have child tasks assigned to others
    - Individual tasks (T-IDs) assigned to others

    Args:
        db: Database connection
        creator_id: Creator user ID

    Returns:
        List of tasks assigned to others
    """
    tasks = await db.fetch_all(
        """
        SELECT DISTINCT t.*,
               COALESCE(u.display_name, 'Nhóm') as assignee_name
        FROM tasks t
        LEFT JOIN users u ON t.assignee_id = u.id
        WHERE t.creator_id = $1
          AND t.is_deleted = false
          AND t.parent_task_id IS NULL
          AND (
              -- Individual tasks assigned to others
              (t.assignee_id IS NOT NULL AND t.assignee_id != $1)
              OR
              -- Group tasks (have children assigned to others)
              EXISTS (
                  SELECT 1 FROM tasks child
                  WHERE child.parent_task_id = t.id
                    AND child.assignee_id != $1
                    AND child.is_deleted = false
              )
          )
        ORDER BY t.created_at DESC
        """,
        creator_id
    )
    return [dict(t) for t in tasks]


async def bulk_delete_tasks(
    db: Database,
    task_ids: List[int],
    user_id: int,
) -> int:
    """
    Bulk delete multiple tasks (no undo).

    Args:
        db: Database connection
        task_ids: List of task IDs to delete
        user_id: User performing deletion

    Returns:
        Number of tasks deleted
    """
    if not task_ids:
        return 0

    # Mark tasks as deleted
    result = await db.execute(
        """
        UPDATE tasks SET
            is_deleted = true,
            deleted_at = NOW(),
            deleted_by = $2,
            updated_at = NOW()
        WHERE id = ANY($1) AND is_deleted = false
        """,
        task_ids, user_id
    )

    # Also delete child tasks (for group tasks)
    await db.execute(
        """
        UPDATE tasks SET
            is_deleted = true,
            deleted_at = NOW(),
            deleted_by = $2,
            updated_at = NOW()
        WHERE parent_task_id = ANY($1) AND is_deleted = false
        """,
        task_ids, user_id
    )

    return len(task_ids)


async def bulk_soft_delete_with_undo(
    db: Database,
    task_ids: List[int],
    user_id: int,
) -> Optional[int]:
    """
    Bulk soft delete tasks with undo support.

    Creates a single undo record for all tasks.

    Args:
        db: Database connection
        task_ids: List of task IDs to delete
        user_id: User performing deletion

    Returns:
        Undo ID for restoring all tasks
    """
    if not task_ids:
        return None

    # Get all tasks data for undo
    tasks = await db.fetch_all(
        "SELECT * FROM tasks WHERE id = ANY($1) AND is_deleted = false",
        task_ids
    )

    if not tasks:
        return None

    # Store in undo buffer (store all task IDs and data)
    expires_at = datetime.now() + timedelta(seconds=30)
    undo = await db.fetch_one(
        """
        INSERT INTO deleted_tasks_undo (task_id, task_data, deleted_by, expires_at)
        VALUES ($1, $2, $3, $4)
        RETURNING *
        """,
        task_ids[0],  # Store first task ID as reference
        json.dumps({
            "bulk": True,
            "task_ids": task_ids,
            "tasks": [dict(t) for t in tasks]
        }, default=str),
        user_id,
        expires_at
    )

    # Mark all tasks as deleted
    await db.execute(
        """
        UPDATE tasks SET
            is_deleted = true,
            deleted_at = NOW(),
            deleted_by = $2,
            updated_at = NOW()
        WHERE id = ANY($1) AND is_deleted = false
        """,
        task_ids, user_id
    )

    # Also delete child tasks
    await db.execute(
        """
        UPDATE tasks SET
            is_deleted = true,
            deleted_at = NOW(),
            deleted_by = $2,
            updated_at = NOW()
        WHERE parent_task_id = ANY($1) AND is_deleted = false
        """,
        task_ids, user_id
    )

    return undo["id"] if undo else None


async def bulk_restore_tasks(db: Database, undo_id: int) -> int:
    """
    Restore bulk deleted tasks from undo buffer.

    Args:
        db: Database connection
        undo_id: Undo record ID

    Returns:
        Number of tasks restored
    """
    # Get undo record
    undo = await db.fetch_one(
        """
        SELECT * FROM deleted_tasks_undo
        WHERE id = $1 AND is_restored = false AND expires_at > NOW()
        """,
        undo_id
    )

    if not undo:
        return 0

    try:
        task_data = json.loads(undo["task_data"])
    except (json.JSONDecodeError, TypeError):
        return 0

    # Check if this is a bulk delete record
    if not task_data.get("bulk"):
        return 0

    task_ids = task_data.get("task_ids", [])
    if not task_ids:
        return 0

    # Restore all tasks
    await db.execute(
        """
        UPDATE tasks SET
            is_deleted = false,
            deleted_at = NULL,
            deleted_by = NULL,
            updated_at = NOW()
        WHERE id = ANY($1)
        """,
        task_ids
    )

    # Also restore child tasks
    await db.execute(
        """
        UPDATE tasks SET
            is_deleted = false,
            deleted_at = NULL,
            deleted_by = NULL,
            updated_at = NOW()
        WHERE parent_task_id = ANY($1)
        """,
        task_ids
    )

    # Mark undo record as used
    await db.execute(
        "UPDATE deleted_tasks_undo SET is_restored = true WHERE id = $1",
        undo_id
    )

    return len(task_ids)


async def add_task_history(
    db: Database,
    task_id: int,
    user_id: int,
    action: str,
    field_name: str = None,
    old_value: str = None,
    new_value: str = None,
    note: str = None,
) -> None:
    """Add entry to task history."""
    await db.execute(
        """
        INSERT INTO task_history (task_id, user_id, action, field_name, old_value, new_value, note)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        """,
        task_id, user_id, action, field_name, old_value, new_value, note
    )


async def create_default_reminders(
    db: Database,
    task_id: int,
    assignee_id: int,
    deadline: datetime,
    creator_id: Optional[int] = None,
) -> None:
    """
    Create default reminders for a task.

    Args:
        db: Database connection
        task_id: Task internal ID
        assignee_id: User assigned to task (receives before-deadline reminders)
        deadline: Task deadline
        creator_id: Task creator (receives 1-min overdue reminder if different from assignee)
    """
    now = datetime.now(TZ)

    # Reminder 24h before for assignee
    remind_24h = deadline - timedelta(hours=24)
    if remind_24h > now:
        await db.execute(
            """
            INSERT INTO reminders (task_id, user_id, remind_at, reminder_type, reminder_offset)
            VALUES ($1, $2, $3, 'before_deadline', '24h')
            ON CONFLICT DO NOTHING
            """,
            task_id, assignee_id, remind_24h
        )

    # Reminder 1h before for assignee
    remind_1h = deadline - timedelta(hours=1)
    if remind_1h > now:
        await db.execute(
            """
            INSERT INTO reminders (task_id, user_id, remind_at, reminder_type, reminder_offset)
            VALUES ($1, $2, $3, 'before_deadline', '1h')
            ON CONFLICT DO NOTHING
            """,
            task_id, assignee_id, remind_1h
        )

    # Reminder 1 minute after deadline for CREATOR (if different from assignee)
    # This notifies the creator when assigned task is overdue
    if creator_id and creator_id != assignee_id:
        remind_overdue_1m = deadline + timedelta(minutes=1)
        if remind_overdue_1m > now:
            await db.execute(
                """
                INSERT INTO reminders (task_id, user_id, remind_at, reminder_type, reminder_offset)
                VALUES ($1, $2, $3, 'creator_overdue', '1m')
                ON CONFLICT DO NOTHING
                """,
                task_id, creator_id, remind_overdue_1m
            )
            logger.info(f"Created 1-min overdue reminder for creator {creator_id} on task {task_id}")


async def get_tasks_with_deadline(
    db: Database,
    hours: int = 24,
    user_id: Optional[int] = None,
) -> List[Dict[str, Any]]:
    """Get tasks with deadline within specified hours."""
    deadline_cutoff = datetime.now(TZ) + timedelta(hours=hours)

    conditions = [
        "is_deleted = false",
        "status != 'completed'",
        "deadline IS NOT NULL",
        "deadline <= $1"
    ]
    params = [deadline_cutoff]

    if user_id:
        conditions.append(f"assignee_id = ${len(params) + 1}")
        params.append(user_id)

    query = f"""
        SELECT t.*, u.display_name as assignee_name
        FROM tasks t
        LEFT JOIN users u ON t.assignee_id = u.id
        WHERE {' AND '.join(conditions)}
        ORDER BY t.deadline ASC
    """

    tasks = await db.fetch_all(query, *params)
    return [dict(t) for t in tasks]


# ============================================
# GROUP TASK FUNCTIONS (G-ID / P-ID System)
# ============================================

async def create_group_task(
    db: Database,
    content: str,
    creator_id: int,
    assignees: List[Dict[str, Any]],
    deadline: Optional[datetime] = None,
    priority: str = "normal",
    group_id: Optional[int] = None,
    description: str = None,
) -> tuple:
    """
    Create group task with individual assignments.

    Args:
        db: Database connection
        content: Task content
        creator_id: Creator user ID
        assignees: List of assignee user dicts
        deadline: Task deadline
        priority: Task priority
        group_id: Telegram group ID
        description: Optional description

    Returns:
        Tuple of (parent_task, list of (child_task, assignee))
    """
    # Generate G-ID for parent
    group_task_id = await generate_task_id(db, prefix="G")

    # Create parent task (container)
    parent = await db.fetch_one(
        """
        INSERT INTO tasks (
            public_id, content, description, creator_id,
            deadline, priority, is_personal, group_id
        )
        VALUES ($1, $2, $3, $4, $5, $6, false, $7)
        RETURNING *
        """,
        group_task_id,
        content,
        description,
        creator_id,
        deadline,
        priority,
        group_id,
    )

    # Log history for parent
    await add_task_history(
        db, parent["id"], creator_id,
        action="created",
        note=f"Group task created with {len(assignees)} assignees"
    )

    # Create individual P-IDs for each assignee
    individual_tasks = []
    parent_id = parent["id"]  # Integer ID for FK

    for assignee in assignees:
        personal_id = await generate_task_id(db, prefix="P")

        task = await db.fetch_one(
            """
            INSERT INTO tasks (
                public_id, group_task_id, parent_task_id, content, description,
                creator_id, assignee_id, deadline, priority,
                is_personal, group_id
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, false, $10)
            RETURNING *
            """,
            personal_id,
            group_task_id,
            parent_id,
            content,
            description,
            creator_id,
            assignee["id"],
            deadline,
            priority,
            group_id,
        )

        # Log history
        await add_task_history(
            db, task["id"], creator_id,
            action="created",
            note=f"Individual task for {assignee.get('display_name', 'user')}"
        )

        # Create reminders
        if deadline:
            await create_default_reminders(db, task["id"], assignee["id"], deadline, creator_id)

        individual_tasks.append((dict(task), assignee))

    logger.info(f"Created group task {group_task_id} with {len(assignees)} P-IDs")
    return dict(parent), individual_tasks


async def get_group_task_progress(
    db: Database,
    group_task_id: str,
) -> Dict[str, Any]:
    """
    Get aggregated progress for group task.

    Args:
        db: Database connection
        group_task_id: Parent G-ID

    Returns:
        Dict with total, completed, progress, members, is_complete
    """
    result = await db.fetch_one(
        """
        SELECT
            COUNT(*) as total,
            COUNT(*) FILTER (WHERE status = 'completed') as completed,
            COALESCE(AVG(progress), 0) as avg_progress
        FROM tasks
        WHERE group_task_id = $1 AND is_deleted = false
        """,
        group_task_id,
    )

    # Get individual member status
    members = await db.fetch_all(
        """
        SELECT t.public_id, t.status, t.progress, t.completed_at,
               u.display_name as assignee_name, u.telegram_id
        FROM tasks t
        JOIN users u ON t.assignee_id = u.id
        WHERE t.group_task_id = $1 AND t.is_deleted = false
        ORDER BY t.created_at
        """,
        group_task_id,
    )

    total = result["total"] or 0
    completed = result["completed"] or 0

    return {
        "total": total,
        "completed": completed,
        "progress": int(result["avg_progress"] or 0),
        "members": [dict(m) for m in members],
        "is_complete": total > 0 and completed == total,
    }


async def get_child_tasks(
    db: Database,
    group_task_id: str,
) -> List[Dict[str, Any]]:
    """
    Get all child P-ID tasks under a G-ID.

    Args:
        db: Database connection
        group_task_id: Parent G-ID

    Returns:
        List of child task records
    """
    tasks = await db.fetch_all(
        """
        SELECT t.*, u.display_name as assignee_name, u.username as assignee_username, u.telegram_id
        FROM tasks t
        JOIN users u ON t.assignee_id = u.id
        WHERE t.group_task_id = $1 AND t.is_deleted = false
        ORDER BY t.created_at
        """,
        group_task_id,
    )
    return [dict(t) for t in tasks]


async def check_and_complete_group_task(
    db: Database,
    task_id: int,
    user_id: int,
) -> Optional[Dict[str, Any]]:
    """
    Check if group task should be completed after individual update.

    Args:
        db: Database connection
        task_id: Individual task ID
        user_id: User making the update

    Returns:
        Group task if completed, None otherwise
    """
    # Get task with group_task_id
    task = await db.fetch_one(
        "SELECT group_task_id FROM tasks WHERE id = $1",
        task_id
    )

    if not task or not task["group_task_id"]:
        return None

    group_task_id = task["group_task_id"]

    # Get group progress
    progress = await get_group_task_progress(db, group_task_id)

    if progress["is_complete"]:
        # Mark parent as complete
        parent = await db.fetch_one(
            """
            UPDATE tasks SET
                status = 'completed',
                progress = 100,
                completed_at = NOW(),
                updated_at = NOW()
            WHERE public_id = $1
            RETURNING *
            """,
            group_task_id,
        )

        await add_task_history(
            db, parent["id"], user_id,
            action="status_changed",
            field_name="status",
            old_value="in_progress",
            new_value="completed",
            note="All members completed"
        )

        logger.info(f"Group task {group_task_id} completed (all members done)")
        return dict(parent)

    # Update parent progress
    await db.execute(
        """
        UPDATE tasks SET
            progress = $2,
            status = CASE WHEN $2 > 0 THEN 'in_progress' ELSE status END,
            updated_at = NOW()
        WHERE public_id = $1
        """,
        group_task_id,
        progress["progress"],
    )

    return None


async def is_group_task(db: Database, public_id: str) -> bool:
    """Check if task is a group task (G-ID or GXXXX)."""
    upper_id = public_id.upper()
    # Check G- prefix or G followed by digits (G0041, G-0041, etc.)
    if upper_id.startswith("G-"):
        return True
    if upper_id.startswith("G") and len(upper_id) > 1 and upper_id[1:].lstrip("0").isdigit():
        return True
    return False


async def convert_individual_to_group(
    db: Database,
    task_id: int,
    assignees: List[Dict[str, Any]],
    modifier_id: int,
) -> tuple:
    """
    Convert individual task to group task with multiple assignees.

    Args:
        db: Database connection
        task_id: Task ID (integer)
        assignees: List of assignee user dicts (must have 2+ assignees)
        modifier_id: User making the change

    Returns:
        Tuple of (group_task, list of child_tasks)
    """
    # Get original task
    task = await db.fetch_one("SELECT * FROM tasks WHERE id = $1", task_id)
    if not task:
        return None, []

    # Generate G-ID for new parent
    group_task_id = await generate_task_id(db, prefix="G")

    # Create parent task
    parent = await db.fetch_one(
        """
        INSERT INTO tasks (
            public_id, content, description, creator_id,
            deadline, priority, is_personal, group_id
        )
        VALUES ($1, $2, $3, $4, $5, $6, false, $7)
        RETURNING *
        """,
        group_task_id,
        task["content"],
        task.get("description"),
        task["creator_id"],
        task.get("deadline"),
        task.get("priority", "normal"),
        task.get("group_id"),
    )

    parent_id = parent["id"]

    # Create P-IDs for each assignee
    child_tasks = []
    for assignee in assignees:
        personal_id = await generate_task_id(db, prefix="P")
        child = await db.fetch_one(
            """
            INSERT INTO tasks (
                public_id, group_task_id, parent_task_id, content, description,
                creator_id, assignee_id, deadline, priority,
                is_personal, group_id
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, false, $10)
            RETURNING *
            """,
            personal_id,
            group_task_id,
            parent_id,
            task["content"],
            task.get("description"),
            task["creator_id"],
            assignee["id"],
            task.get("deadline"),
            task.get("priority", "normal"),
            task.get("group_id"),
        )
        child_tasks.append((dict(child), assignee))

        # Create reminders
        if task.get("deadline"):
            await create_default_reminders(db, child["id"], assignee["id"], task["deadline"], task["creator_id"])

    # Soft delete original task
    await db.execute(
        """
        UPDATE tasks SET
            is_deleted = true,
            deleted_at = NOW(),
            deleted_by = $2
        WHERE id = $1
        """,
        task_id, modifier_id
    )

    # Log history
    await add_task_history(
        db, parent_id, modifier_id,
        action="converted",
        note=f"Converted from {task['public_id']} to group task with {len(assignees)} assignees"
    )

    logger.info(f"Converted task {task['public_id']} to group task {group_task_id}")
    return dict(parent), child_tasks


async def update_group_assignees(
    db: Database,
    group_task_id: str,
    assignees: List[Dict[str, Any]],
    modifier_id: int,
) -> List[tuple]:
    """
    Update assignees for a group task (add/remove P-IDs).

    Args:
        db: Database connection
        group_task_id: G-ID of parent task
        assignees: New list of assignee user dicts
        modifier_id: User making the change

    Returns:
        List of (child_task, assignee) tuples
    """
    # Get parent task
    parent = await get_task_by_public_id(db, group_task_id)
    if not parent:
        return []

    # Get current child tasks
    current_children = await get_child_tasks(db, group_task_id)
    current_assignee_ids = {c["assignee_id"] for c in current_children}
    new_assignee_ids = {a["id"] for a in assignees}

    # Find assignees to add and remove
    to_remove = current_assignee_ids - new_assignee_ids
    to_add = [a for a in assignees if a["id"] not in current_assignee_ids]

    # Soft delete removed assignees' tasks
    for child in current_children:
        if child["assignee_id"] in to_remove:
            await db.execute(
                """
                UPDATE tasks SET
                    is_deleted = true,
                    deleted_at = NOW(),
                    deleted_by = $2
                WHERE id = $1
                """,
                child["id"], modifier_id
            )

    # Add new P-IDs
    new_children = []
    for assignee in to_add:
        personal_id = await generate_task_id(db, prefix="P")
        child = await db.fetch_one(
            """
            INSERT INTO tasks (
                public_id, group_task_id, parent_task_id, content, description,
                creator_id, assignee_id, deadline, priority,
                is_personal, group_id
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, false, $10)
            RETURNING *
            """,
            personal_id,
            group_task_id,
            parent["id"],
            parent["content"],
            parent.get("description"),
            parent["creator_id"],
            assignee["id"],
            parent.get("deadline"),
            parent.get("priority", "normal"),
            parent.get("group_id"),
        )
        new_children.append((dict(child), assignee))

        if parent.get("deadline"):
            await create_default_reminders(db, child["id"], assignee["id"], parent["deadline"], parent["creator_id"])

    # Log history
    await add_task_history(
        db, parent["id"], modifier_id,
        action="updated_assignees",
        note=f"Added {len(to_add)}, removed {len(to_remove)} assignees"
    )

    logger.info(f"Updated group {group_task_id}: +{len(to_add)}, -{len(to_remove)}")
    return new_children
</file>

<file path="services/time_parser.py">
"""
Vietnamese Time Parser
Parses Vietnamese time expressions to datetime objects

Supported formats:
- Hour: 10h, 10h30, 14:30, 10 giờ 30
- Period: sáng, trưa, chiều, tối, đêm
- Relative: hôm nay, ngày mai, ngày kia
- Weekday: thứ 2, thứ hai, t2, chủ nhật
- Date: 15/12, 15/12/2025
"""

import re
import calendar
from datetime import datetime, timedelta
from typing import Optional, Tuple
import pytz


class VietnameseTimeParser:
    """Parse Vietnamese time expressions."""

    def __init__(self, timezone: str = "Asia/Ho_Chi_Minh"):
        self.TZ = pytz.timezone(timezone)

    # Time patterns: (regex, group_info)
    TIME_PATTERNS = [
        (r"(\d{1,2})h(\d{2})?(?!\d)", "hour_h"),  # 10h, 10h30
        (r"(\d{1,2})\s*giờ\s*(\d{2})?(?:\s*phút)?", "hour_gio"),  # 10 giờ 30
        (r"(\d{1,2}):(\d{2})", "hour_colon"),  # 14:30
    ]

    # Period keywords: (start_hour, end_hour, add_12_if_hour_less_than_12)
    PERIOD_KEYWORDS = {
        "sáng": (5, 12, False),
        "trưa": (11, 14, False),
        "chiều": (12, 18, True),
        "tối": (18, 23, True),
        "đêm": (21, 5, True),
    }

    # Weekday mapping (Monday = 0)
    WEEKDAY_MAP = {
        "thứ 2": 0, "thứ hai": 0, "t2": 0, "hai": 0,
        "thứ 3": 1, "thứ ba": 1, "t3": 1, "ba": 1,
        "thứ 4": 2, "thứ tư": 2, "t4": 2, "tư": 2,
        "thứ 5": 3, "thứ năm": 3, "t5": 3, "năm": 3,
        "thứ 6": 4, "thứ sáu": 4, "t6": 4, "sáu": 4,
        "thứ 7": 5, "thứ bảy": 5, "t7": 5, "bảy": 5,
        "chủ nhật": 6, "cn": 6,
    }

    # Relative day mapping
    RELATIVE_MAP = {
        "hôm nay": 0,
        "ngày mai": 1,
        "ngày kia": 2,
        "hôm qua": -1,
        "mai": 1,
    }

    def extract_datetime(self, text: str) -> Tuple[Optional[datetime], str]:
        """
        Extract datetime from Vietnamese text.

        Args:
            text: Input text containing time expression

        Returns:
            Tuple of (parsed datetime or None, remaining text)
        """
        text_lower = text.lower()
        now = datetime.now(self.TZ)
        result_dt = None
        matched_parts = []

        # Step 1: Try relative keywords (hôm nay, ngày mai, etc.)
        for keyword, days in self.RELATIVE_MAP.items():
            if keyword in text_lower:
                result_dt = now + timedelta(days=days)
                matched_parts.append(keyword)
                text_lower = text_lower.replace(keyword, " ")
                break

        # Step 1.5: Try special keywords (cuối tuần, cuối tháng)
        if not result_dt:
            # "cuối tuần" = Saturday of current week
            if re.search(r"cuối\s*tuần", text_lower):
                days_until_saturday = (5 - now.weekday()) % 7
                if days_until_saturday == 0 and now.hour >= 12:
                    days_until_saturday = 7  # Next Saturday if already past noon on Saturday
                result_dt = now + timedelta(days=days_until_saturday)
                matched_parts.append("cuối tuần")
                text_lower = re.sub(r"cuối\s*tuần", " ", text_lower)

            # "cuối tháng" = last day of current month
            elif re.search(r"cuối\s*tháng", text_lower):
                last_day = calendar.monthrange(now.year, now.month)[1]
                result_dt = self.TZ.localize(datetime(now.year, now.month, last_day))
                matched_parts.append("cuối tháng")
                text_lower = re.sub(r"cuối\s*tháng", " ", text_lower)

        # Step 2: Try weekday patterns
        if not result_dt:
            for weekday, day_num in self.WEEKDAY_MAP.items():
                pattern = rf"\b{re.escape(weekday)}\b"
                if re.search(pattern, text_lower):
                    result_dt = self._next_weekday(now, day_num)

                    # Check for "tuần sau" or "tuần này"
                    if re.search(r"tuần\s*sau", text_lower):
                        result_dt += timedelta(days=7)
                        text_lower = re.sub(r"tuần\s*sau", " ", text_lower)
                    elif re.search(r"tuần\s*này", text_lower):
                        text_lower = re.sub(r"tuần\s*này", " ", text_lower)

                    matched_parts.append(weekday)
                    text_lower = re.sub(pattern, " ", text_lower)
                    break

        # Step 3: Try date patterns (dd/mm or dd/mm/yyyy)
        if not result_dt:
            date_match = re.search(r"(\d{1,2})/(\d{1,2})(?:/(\d{4}))?", text_lower)
            if date_match:
                day = int(date_match.group(1))
                month = int(date_match.group(2))
                year = int(date_match.group(3)) if date_match.group(3) else now.year

                # If date has passed this year, use next year
                if not date_match.group(3):
                    test_date = datetime(year, month, day)
                    if test_date.date() < now.date():
                        year += 1

                try:
                    result_dt = self.TZ.localize(datetime(year, month, day))
                    matched_parts.append(date_match.group(0))
                    text_lower = text_lower.replace(date_match.group(0), " ")
                except ValueError:
                    pass  # Invalid date

        # Step 4: Extract time (hour:minute)
        hour = None
        minute = 0

        for pattern, _ in self.TIME_PATTERNS:
            time_match = re.search(pattern, text_lower, re.IGNORECASE)
            if time_match:
                hour = int(time_match.group(1))
                minute = int(time_match.group(2)) if time_match.group(2) else 0

                # Validate hour/minute
                if 0 <= hour <= 23 and 0 <= minute <= 59:
                    matched_parts.append(time_match.group(0))
                    text_lower = text_lower.replace(time_match.group(0), " ")
                else:
                    hour = None
                break

        # Step 5: Apply period keywords (sáng/chiều/tối)
        if hour is not None:
            for period, (_, _, add_12) in self.PERIOD_KEYWORDS.items():
                if period in text_lower:
                    if add_12 and hour < 12:
                        hour += 12
                    elif not add_12 and hour == 12:
                        hour = 0  # 12h sáng = 0:00? No, keep 12
                    matched_parts.append(period)
                    text_lower = text_lower.replace(period, " ")
                    break

        # Step 6: Combine date and time
        if result_dt and hour is not None:
            result_dt = result_dt.replace(hour=hour, minute=minute, second=0, microsecond=0)
        elif result_dt and hour is None:
            # Date without time: set to current time or 9:00 AM
            result_dt = result_dt.replace(hour=9, minute=0, second=0, microsecond=0)
        elif hour is not None and not result_dt:
            # Time without date: today or tomorrow if time has passed
            result_dt = now.replace(hour=hour, minute=minute, second=0, microsecond=0)
            if result_dt < now:
                result_dt += timedelta(days=1)

        # Clean remaining text
        remaining = re.sub(r"\s+", " ", text_lower).strip()

        return result_dt, remaining

    def _next_weekday(self, now: datetime, weekday: int) -> datetime:
        """
        Get next occurrence of weekday.

        Args:
            now: Current datetime
            weekday: Target weekday (0=Monday, 6=Sunday)

        Returns:
            Datetime of next occurrence
        """
        days_ahead = weekday - now.weekday()
        if days_ahead <= 0:  # Target day already happened this week
            days_ahead += 7
        return now + timedelta(days=days_ahead)

    def format_datetime(self, dt: datetime) -> str:
        """
        Format datetime in Vietnamese style.

        Args:
            dt: Datetime to format

        Returns:
            Formatted string like "14:30 Thứ 2, 15/12/2025"
        """
        weekday_names = ["Thứ 2", "Thứ 3", "Thứ 4", "Thứ 5", "Thứ 6", "Thứ 7", "CN"]
        weekday = weekday_names[dt.weekday()]
        return f"{dt.strftime('%H:%M')} {weekday}, {dt.strftime('%d/%m/%Y')}"

    def format_relative(self, dt: datetime) -> str:
        """
        Format datetime relative to now.

        Args:
            dt: Datetime to format

        Returns:
            Relative string like "Ngày mai 14:30" or "15/12 14:30"
        """
        now = datetime.now(self.TZ)
        delta = (dt.date() - now.date()).days

        time_str = dt.strftime("%H:%M")

        if delta == 0:
            return f"Hôm nay {time_str}"
        elif delta == 1:
            return f"Ngày mai {time_str}"
        elif delta == 2:
            return f"Ngày kia {time_str}"
        elif delta == -1:
            return f"Hôm qua {time_str}"
        elif 2 < delta <= 7:
            weekday_names = ["Thứ 2", "Thứ 3", "Thứ 4", "Thứ 5", "Thứ 6", "Thứ 7", "CN"]
            return f"{weekday_names[dt.weekday()]} {time_str}"
        else:
            return f"{dt.strftime('%d/%m')} {time_str}"


# Convenience function
def parse_vietnamese_time(text: str, timezone: str = "Asia/Ho_Chi_Minh") -> Tuple[Optional[datetime], str]:
    """
    Parse Vietnamese time expression.

    Args:
        text: Input text
        timezone: Timezone name

    Returns:
        Tuple of (datetime or None, remaining text)
    """
    parser = VietnameseTimeParser(timezone)
    return parser.extract_datetime(text)
</file>

<file path="services/user_service.py">
"""
User Service
CRUD operations for Telegram users
"""

import logging
from typing import Any, Dict, List, Optional

from telegram import User as TelegramUser

from database.connection import Database

logger = logging.getLogger(__name__)


async def get_or_create_user(db: Database, tg_user: TelegramUser) -> Dict[str, Any]:
    """
    Get existing user or create new one.

    Args:
        db: Database connection
        tg_user: Telegram User object

    Returns:
        User record as dict
    """
    # Try to find existing user
    user = await db.fetch_one(
        "SELECT * FROM users WHERE telegram_id = $1",
        tg_user.id
    )

    if user:
        # Update user info if changed
        display_name = _build_display_name(tg_user)
        if (
            user["username"] != tg_user.username
            or user["first_name"] != tg_user.first_name
            or user["last_name"] != tg_user.last_name
        ):
            await db.execute(
                """
                UPDATE users SET
                    username = $2,
                    first_name = $3,
                    last_name = $4,
                    display_name = $5,
                    updated_at = NOW()
                WHERE telegram_id = $1
                """,
                tg_user.id,
                tg_user.username,
                tg_user.first_name,
                tg_user.last_name,
                display_name,
            )
            # Refresh user data
            user = await db.fetch_one(
                "SELECT * FROM users WHERE telegram_id = $1",
                tg_user.id
            )
        return dict(user)

    # Create new user
    display_name = _build_display_name(tg_user)
    user = await db.fetch_one(
        """
        INSERT INTO users (telegram_id, username, first_name, last_name, display_name)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING *
        """,
        tg_user.id,
        tg_user.username,
        tg_user.first_name,
        tg_user.last_name,
        display_name,
    )

    logger.info(f"Created new user: {tg_user.id} ({display_name})")
    return dict(user)


async def get_user_by_telegram_id(db: Database, telegram_id: int) -> Optional[Dict[str, Any]]:
    """
    Get user by Telegram ID.

    Args:
        db: Database connection
        telegram_id: Telegram user ID

    Returns:
        User record or None
    """
    user = await db.fetch_one(
        "SELECT * FROM users WHERE telegram_id = $1 AND is_active = true",
        telegram_id
    )
    return dict(user) if user else None


async def get_user_by_id(db: Database, user_id: int) -> Optional[Dict[str, Any]]:
    """
    Get user by internal ID.

    Args:
        db: Database connection
        user_id: Internal user ID

    Returns:
        User record or None
    """
    user = await db.fetch_one(
        "SELECT * FROM users WHERE id = $1 AND is_active = true",
        user_id
    )
    return dict(user) if user else None


async def get_user_by_username(db: Database, username: str) -> Optional[Dict[str, Any]]:
    """
    Get user by Telegram username.

    Args:
        db: Database connection
        username: Telegram username (without @)

    Returns:
        User record or None
    """
    # Remove @ if present
    username = username.lstrip("@")

    user = await db.fetch_one(
        "SELECT * FROM users WHERE LOWER(username) = LOWER($1) AND is_active = true",
        username
    )
    return dict(user) if user else None


async def find_users_by_mention(
    db: Database,
    group_telegram_id: int,
    usernames: List[str],
    name_text: str = ""
) -> List[Dict[str, Any]]:
    """
    Find users by @mentions or name search.

    Args:
        db: Database connection
        group_telegram_id: Telegram group ID
        usernames: List of @usernames to find
        name_text: Optional text to search for names

    Returns:
        List of user records
    """
    users = []

    # Find by usernames
    for username in usernames:
        user = await get_user_by_username(db, username)
        if user and user not in users:
            users.append(user)

    # Find by name in group members
    if name_text and not users:
        # Get group
        group = await db.fetch_one(
            "SELECT id FROM groups WHERE telegram_id = $1",
            group_telegram_id
        )

        if group:
            # Search by display name in group
            found = await db.fetch_all(
                """
                SELECT u.* FROM users u
                JOIN group_members gm ON u.id = gm.user_id
                WHERE gm.group_id = $1
                AND (
                    LOWER(u.display_name) LIKE LOWER($2)
                    OR LOWER(u.first_name) LIKE LOWER($2)
                )
                AND u.is_active = true
                LIMIT 5
                """,
                group["id"],
                f"%{name_text}%"
            )
            users.extend([dict(u) for u in found])

    return users


async def update_user_settings(
    db: Database,
    user_id: int,
    settings: Dict[str, Any]
) -> Dict[str, Any]:
    """
    Update user settings.

    Args:
        db: Database connection
        user_id: Internal user ID
        settings: Settings to update

    Returns:
        Updated user record
    """
    allowed_fields = {
        "timezone", "language",
        "notify_reminder", "notify_weekly_report", "notify_monthly_report"
    }

    # Filter to allowed fields
    updates = {k: v for k, v in settings.items() if k in allowed_fields}

    if not updates:
        user = await get_user_by_id(db, user_id)
        return user

    # Build update query
    set_clauses = ", ".join(f"{k} = ${i+2}" for i, k in enumerate(updates.keys()))
    values = [user_id] + list(updates.values())

    user = await db.fetch_one(
        f"""
        UPDATE users SET {set_clauses}, updated_at = NOW()
        WHERE id = $1
        RETURNING *
        """,
        *values
    )

    return dict(user) if user else None


async def get_or_create_group(db: Database, telegram_id: int, title: str) -> Dict[str, Any]:
    """
    Get existing group or create new one.

    Args:
        db: Database connection
        telegram_id: Telegram group ID
        title: Group title

    Returns:
        Group record as dict
    """
    group = await db.fetch_one(
        "SELECT * FROM groups WHERE telegram_id = $1",
        telegram_id
    )

    if group:
        # Update title if changed
        if group["title"] != title:
            await db.execute(
                "UPDATE groups SET title = $2, updated_at = NOW() WHERE telegram_id = $1",
                telegram_id,
                title
            )
        return dict(group)

    # Create new group
    group = await db.fetch_one(
        """
        INSERT INTO groups (telegram_id, title)
        VALUES ($1, $2)
        RETURNING *
        """,
        telegram_id,
        title
    )

    logger.info(f"Created new group: {telegram_id} ({title})")
    return dict(group)


async def add_group_member(
    db: Database,
    group_id: int,
    user_id: int,
    role: str = "member"
) -> None:
    """
    Add user to group.

    Args:
        db: Database connection
        group_id: Internal group ID
        user_id: Internal user ID
        role: Member role (admin/member)
    """
    await db.execute(
        """
        INSERT INTO group_members (group_id, user_id, role)
        VALUES ($1, $2, $3)
        ON CONFLICT (group_id, user_id) DO UPDATE SET role = $3
        """,
        group_id,
        user_id,
        role
    )


def _build_display_name(tg_user: TelegramUser) -> str:
    """Build display name from Telegram user."""
    if tg_user.first_name and tg_user.last_name:
        return f"{tg_user.first_name} {tg_user.last_name}"
    elif tg_user.first_name:
        return tg_user.first_name
    elif tg_user.username:
        return f"@{tg_user.username}"
    else:
        return f"User {tg_user.id}"
</file>

<file path="static/config.json">
{"bot_name": "TeleTask Bot"}
</file>

<file path="static/index.html">
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hướng Dẫn Sử Dụng</title>
    <style>
        /* Reset */
        *, *::before, *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Base */
        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Layout Container */
        .app-container {
            display: flex;
            min-height: 100vh;
        }

        /* ==================== SIDEBAR ==================== */
        .sidebar {
            width: 260px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-right: 1px solid rgba(0, 0, 0, 0.1);
            padding: 20px 16px;
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            overflow-y: auto;
            z-index: 1000;
            transition: transform 0.3s ease;
        }

        /* Desktop: sidebar always visible */
        @media (min-width: 769px) {
            .sidebar {
                position: sticky;
                top: 0;
                height: 100vh;
                transform: none !important;
            }
        }

        /* Mobile: sidebar hidden by default */
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
                box-shadow: 4px 0 20px rgba(0, 0, 0, 0.15);
                padding-bottom: 45px;
            }
            .sidebar.open {
                transform: translateX(0);
            }
        }

        .sidebar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding-bottom: 16px;
            margin-bottom: 16px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .sidebar-logo {
            font-size: 18px;
            font-weight: 700;
            color: #1d1d1f;
        }

        .sidebar-close {
            display: none;
            width: 32px;
            height: 32px;
            border: none;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            font-size: 18px;
            cursor: pointer;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
        }

        @media (max-width: 768px) {
            .sidebar-close {
                display: flex;
            }
        }

        .sidebar-section {
            margin-bottom: 24px;
        }

        .sidebar-title {
            font-size: 11px;
            font-weight: 600;
            color: #86868b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 0 12px;
            margin-bottom: 8px;
        }

        .sidebar-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 8px;
            font-size: 14px;
            color: #1d1d1f;
            text-decoration: none;
            transition: background 0.15s;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }

        .sidebar-item:hover,
        .sidebar-item:active {
            background: rgba(0, 0, 0, 0.05);
        }

        .sidebar-item.active {
            background: #007aff;
            color: white;
        }

        .sidebar-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
        }

        /* ==================== OVERLAY ==================== */
        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 999;
            -webkit-tap-highlight-color: transparent;
        }

        .overlay.active {
            display: block;
        }

        /* ==================== MAIN CONTENT ==================== */
        .main-wrapper {
            flex: 1;
            min-width: 0;
            background: rgba(246, 246, 246, 0.8);
        }

        @media (min-width: 769px) {
            .main-wrapper {
                margin-left: 0;
                background: transparent;
            }
        }

        /* Mobile Header */
        .mobile-header {
            display: none;
            position: sticky;
            top: 0;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 12px 16px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        @media (max-width: 768px) {
            .mobile-header {
                display: flex;
                align-items: center;
                gap: 12px;
            }
        }

        .menu-button {
            width: 40px;
            height: 40px;
            border: none;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 10px;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .menu-button:active {
            background: rgba(0, 0, 0, 0.1);
        }

        .mobile-title {
            font-size: 16px;
            font-weight: 600;
            color: #1d1d1f;
        }

        /* Main Content Area */
        .main-content {
            padding: 40px;
            max-width: 900px;
        }

        @media (max-width: 768px) {
            .main-content {
                padding: 20px 16px;
            }
        }

        /* Hero Section */
        .hero {
            text-align: center;
            padding: 40px 0 50px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
            margin-bottom: 40px;
        }

        .hero-icon {
            width: 80px;
            height: 80px;
            background: linear-gradient(180deg, #007aff 0%, #0055d4 100%);
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            margin: 0 auto 20px;
            box-shadow: 0 8px 24px rgba(0, 122, 255, 0.3);
        }

        .hero h1 {
            font-size: 32px;
            font-weight: 700;
            color: #1d1d1f;
            margin-bottom: 8px;
        }

        .hero p {
            font-size: 17px;
            color: #86868b;
        }

        @media (max-width: 768px) {
            .hero {
                padding: 30px 0 40px;
            }
            .hero-icon {
                width: 64px;
                height: 64px;
                font-size: 32px;
            }
            .hero h1 {
                font-size: 24px;
            }
            .hero p {
                font-size: 15px;
            }
        }

        /* Feature Grid */
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            margin-bottom: 50px;
        }

        @media (max-width: 768px) {
            .feature-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
        }

        .feature-card {
            background: #f5f5f7;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .feature-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
        }

        .feature-icon {
            font-size: 32px;
            margin-bottom: 12px;
        }

        .feature-card h3 {
            font-size: 15px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 4px;
        }

        .feature-card p {
            font-size: 13px;
            color: #86868b;
        }

        /* Sections */
        .section {
            margin-bottom: 50px;
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .section-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(180deg, #f5f5f7 0%, #e8e8ed 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .section-title {
            font-size: 20px;
            font-weight: 600;
            color: #1d1d1f;
        }

        /* Command Items */
        .command-item {
            display: flex;
            align-items: flex-start;
            padding: 12px 16px;
            background: #f5f5f7;
            border-radius: 10px;
            margin-bottom: 8px;
        }

        .command-code {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            font-size: 13px;
            font-weight: 600;
            color: #007aff;
            min-width: 200px;
            flex-shrink: 0;
        }

        .command-desc {
            font-size: 13px;
            color: #1d1d1f;
            line-height: 1.5;
        }

        @media (max-width: 768px) {
            .command-item {
                flex-direction: column;
            }
            .command-code {
                min-width: auto;
                margin-bottom: 6px;
            }
        }

        /* Example Box */
        .example-box {
            background: rgba(0, 122, 255, 0.06);
            border-radius: 10px;
            padding: 16px 20px;
            margin-top: 12px;
            border: 1px solid rgba(0, 122, 255, 0.1);
        }

        .example-label {
            font-size: 11px;
            font-weight: 600;
            color: #007aff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }

        .example-code {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 13px;
            color: #1d1d1f;
            display: block;
            padding: 4px 0;
        }

        /* Tip Box */
        .tip-box {
            background: rgba(52, 199, 89, 0.08);
            border-radius: 10px;
            padding: 16px 20px;
            margin-top: 16px;
            border: 1px solid rgba(52, 199, 89, 0.15);
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .tip-icon {
            font-size: 18px;
            flex-shrink: 0;
        }

        .tip-content {
            font-size: 13px;
            color: #1d1d1f;
            line-height: 1.5;
        }

        .tip-content strong {
            color: #248a3d;
        }

        .tip-content ul {
            margin: 8px 0 0 0;
            padding-left: 20px;
        }

        /* Tips Grid */
        .tips-grid {
            display: grid;
            gap: 12px;
        }

        .tip-card {
            border-radius: 10px;
            padding: 16px 20px;
            display: flex;
            align-items: flex-start;
            gap: 14px;
        }

        .tip-card.green {
            background: rgba(52, 199, 89, 0.08);
            border: 1px solid rgba(52, 199, 89, 0.12);
        }

        .tip-card.blue {
            background: rgba(0, 122, 255, 0.06);
            border: 1px solid rgba(0, 122, 255, 0.1);
        }

        .tip-card.purple {
            background: rgba(175, 82, 222, 0.08);
            border: 1px solid rgba(175, 82, 222, 0.12);
        }

        .tip-card .tip-icon {
            font-size: 24px;
        }

        .tip-card h4 {
            font-size: 14px;
            font-weight: 600;
            color: #1d1d1f;
            margin-bottom: 4px;
        }

        .tip-card p {
            font-size: 13px;
            color: #86868b;
            line-height: 1.5;
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 30px;
            border-top: 1px solid rgba(0, 0, 0, 0.08);
            margin-top: 40px;
        }

        .footer p {
            font-size: 13px;
            color: #86868b;
        }

        .footer .brand {
            font-weight: 600;
            color: #1d1d1f;
        }
    </style>
</head>
<body>
    <!-- Overlay for mobile menu -->
    <div class="overlay" id="overlay"></div>

    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <span class="sidebar-logo bot-name">TeleTask Bot</span>
                <button class="sidebar-close" id="sidebarClose">✕</button>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Bắt đầu</div>
                <a href="#features" class="sidebar-item active">
                    <span class="sidebar-icon">✨</span>
                    <span>Tính năng</span>
                </a>
                <a href="#basic" class="sidebar-item">
                    <span class="sidebar-icon">🚀</span>
                    <span>Lệnh cơ bản</span>
                </a>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Quản lý việc</div>
                <a href="#create" class="sidebar-item">
                    <span class="sidebar-icon">📝</span>
                    <span>Tạo việc</span>
                </a>
                <a href="#recurring" class="sidebar-item">
                    <span class="sidebar-icon">🔄</span>
                    <span>Việc lặp lại</span>
                </a>
                <a href="#view" class="sidebar-item">
                    <span class="sidebar-icon">👀</span>
                    <span>Xem việc</span>
                </a>
                <a href="#update" class="sidebar-item">
                    <span class="sidebar-icon">✏️</span>
                    <span>Cập nhật</span>
                </a>
                <a href="#reminder" class="sidebar-item">
                    <span class="sidebar-icon">⏰</span>
                    <span>Nhắc việc</span>
                </a>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Báo cáo</div>
                <a href="#stats" class="sidebar-item">
                    <span class="sidebar-icon">📊</span>
                    <span>Thống kê</span>
                </a>
                <a href="#export" class="sidebar-item">
                    <span class="sidebar-icon">📤</span>
                    <span>Xuất báo cáo</span>
                </a>
            </div>

            <div class="sidebar-section">
                <div class="sidebar-title">Khác</div>
                <a href="#calendar" class="sidebar-item">
                    <span class="sidebar-icon">📅</span>
                    <span>Google Calendar</span>
                </a>
                <a href="#settings" class="sidebar-item">
                    <span class="sidebar-icon">⚙️</span>
                    <span>Cài đặt</span>
                </a>
                <a href="#tips" class="sidebar-item">
                    <span class="sidebar-icon">💡</span>
                    <span>Mẹo sử dụng</span>
                </a>
                <a href="/user-guide.html" class="sidebar-item">
                    <span class="sidebar-icon">📖</span>
                    <span>Tài liệu đầy đủ</span>
                </a>
            </div>
        </aside>

        <!-- Main Content Wrapper -->
        <div class="main-wrapper">
            <!-- Mobile Header -->
            <header class="mobile-header">
                <button class="menu-button" id="menuButton">☰</button>
                <span class="mobile-title bot-name">TeleTask Bot</span>
            </header>

            <!-- Main Content -->
            <main class="main-content">
                <div class="hero">
                    <div class="hero-icon">📋</div>
                    <h1 class="bot-name">TeleTask Bot</h1>
                    <p>Hệ thống quản lý công việc qua Telegram</p>
                </div>

                <section id="features" class="section">
                    <div class="feature-grid">
                        <div class="feature-card">
                            <div class="feature-icon">✅</div>
                            <h3>Tạo & Giao Việc</h3>
                            <p>Tạo việc cá nhân hoặc giao cho người khác</p>
                        </div>
                        <div class="feature-card">
                            <div class="feature-icon">🔄</div>
                            <h3>Việc Lặp Lại</h3>
                            <p>Tự động tạo việc hàng ngày/tuần/tháng</p>
                        </div>
                        <div class="feature-card">
                            <div class="feature-icon">📊</div>
                            <h3>Thống Kê</h3>
                            <p>Báo cáo tiến độ tuần, tháng</p>
                        </div>
                        <div class="feature-card">
                            <div class="feature-icon">📅</div>
                            <h3>Google Calendar</h3>
                            <p>Đồng bộ deadline với lịch Google</p>
                        </div>
                    </div>
                </section>

                <section id="basic" class="section">
                    <div class="section-header">
                        <div class="section-icon">🚀</div>
                        <h2 class="section-title">Lệnh Cơ Bản</h2>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/start</span>
                        <span class="command-desc">Bắt đầu sử dụng bot, đăng ký tài khoản</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/menu</span>
                        <span class="command-desc">Menu tính năng với nút bấm tương tác</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/help</span>
                        <span class="command-desc">Xem hướng dẫn sử dụng nhanh</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/thongtin</span>
                        <span class="command-desc">Xem thông tin tài khoản và thống kê</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/caidat</span>
                        <span class="command-desc">Cài đặt nhắc nhở (24h, 1h trước deadline)</span>
                    </div>
                </section>

                <section id="create" class="section">
                    <div class="section-header">
                        <div class="section-icon">📝</div>
                        <h2 class="section-title">Tạo Việc</h2>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/taoviec [nội dung]</span>
                        <span class="command-desc">Tạo việc cá nhân mới (có wizard hướng dẫn)</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/giaoviec @user [nội dung]</span>
                        <span class="command-desc">Giao việc cho người khác</span>
                    </div>
                    <div class="example-box">
                        <div class="example-label">Ví dụ</div>
                        <code class="example-code">/taoviec Họp đội 14h30</code>
                        <code class="example-code">/taoviec Nộp báo cáo ngày mai 10h</code>
                        <code class="example-code">/giaoviec @nam Chuẩn bị slide ngày mai 15h</code>
                    </div>
                </section>

                <section id="recurring" class="section">
                    <div class="section-header">
                        <div class="section-icon">🔄</div>
                        <h2 class="section-title">Việc Lặp Lại</h2>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/vieclaplai [nội dung] [lịch]</span>
                        <span class="command-desc">Tạo việc tự động lặp lại</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/danhsachvieclaplai</span>
                        <span class="command-desc">Xem danh sách việc lặp lại</span>
                    </div>
                    <div class="example-box">
                        <div class="example-label">Ví dụ</div>
                        <code class="example-code">/vieclaplai Họp đội hàng tuần thứ 2 9h</code>
                        <code class="example-code">/vieclaplai Báo cáo hàng tháng ngày 1 10h</code>
                        <code class="example-code">/vieclaplai Kiểm tra email hàng ngày 8h</code>
                    </div>
                </section>

                <section id="view" class="section">
                    <div class="section-header">
                        <div class="section-icon">👀</div>
                        <h2 class="section-title">Xem Việc</h2>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/xemviec</span>
                        <span class="command-desc">Danh mục việc (menu với nút bấm)</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/xemviec [mã việc]</span>
                        <span class="command-desc">Xem chi tiết một việc (P-ID hoặc G-ID)</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/viecdagiao</span>
                        <span class="command-desc">Việc bạn đã giao cho người khác</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/viecdanhan</span>
                        <span class="command-desc">Việc được giao cho bạn</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/timviec [từ khóa]</span>
                        <span class="command-desc">Tìm kiếm việc theo nội dung</span>
                    </div>
                </section>

                <section id="update" class="section">
                    <div class="section-header">
                        <div class="section-icon">✏️</div>
                        <h2 class="section-title">Cập Nhật Việc</h2>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/xong [mã việc]</span>
                        <span class="command-desc">Đánh dấu việc hoàn thành</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/tiendo [mã] [%]</span>
                        <span class="command-desc">Cập nhật tiến độ (0-100%)</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/xoa [mã việc]</span>
                        <span class="command-desc">Xóa việc (hoàn tác trong 10s)</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/xoanhieu [mã1,mã2,...]</span>
                        <span class="command-desc">Xóa nhiều việc cùng lúc</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/xoatatca</span>
                        <span class="command-desc">Xóa tất cả việc (hoàn tác trong 10s)</span>
                    </div>
                </section>

                <section id="reminder" class="section">
                    <div class="section-header">
                        <div class="section-icon">⏰</div>
                        <h2 class="section-title">Nhắc Việc</h2>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/nhacviec [mã] [thời gian]</span>
                        <span class="command-desc">Đặt nhắc cho việc</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/xemnhac</span>
                        <span class="command-desc">Xem danh sách nhắc đã đặt</span>
                    </div>
                    <div class="example-box">
                        <div class="example-label">Ví dụ</div>
                        <code class="example-code">/nhacviec ABC123 15 phút</code>
                        <code class="example-code">/nhacviec ABC123 ngày mai 8h</code>
                    </div>
                </section>

                <section id="stats" class="section">
                    <div class="section-header">
                        <div class="section-icon">📊</div>
                        <h2 class="section-title">Thống Kê</h2>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/thongke</span>
                        <span class="command-desc">Thống kê tổng hợp của bạn</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/thongketuan</span>
                        <span class="command-desc">Thống kê tuần này</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/thongkethang</span>
                        <span class="command-desc">Thống kê tháng này</span>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/viectrehan</span>
                        <span class="command-desc">Xem danh sách việc trễ hạn</span>
                    </div>
                </section>

                <section id="export" class="section">
                    <div class="section-header">
                        <div class="section-icon">📤</div>
                        <h2 class="section-title">Xuất Báo Cáo</h2>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/export</span>
                        <span class="command-desc">Xuất báo cáo (CSV, Excel, PDF)</span>
                    </div>
                    <div class="tip-box">
                        <span class="tip-icon">💡</span>
                        <div class="tip-content">
                            <strong>Mẹo:</strong> Lệnh /export hỗ trợ chọn khoảng thời gian (7 ngày, 30 ngày, tuần này, tháng này, hoặc tùy chọn ngày cụ thể), loại việc, và định dạng file. Báo cáo có mật khẩu bảo vệ và hết hạn sau 72 giờ.
                        </div>
                    </div>
                </section>

                <section id="calendar" class="section">
                    <div class="section-header">
                        <div class="section-icon">📅</div>
                        <h2 class="section-title">Google Calendar</h2>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/lichgoogle</span>
                        <span class="command-desc">Kết nối và cài đặt Google Calendar</span>
                    </div>
                    <div class="tip-box">
                        <span class="tip-icon">💡</span>
                        <div class="tip-content">
                            <strong>Tính năng:</strong>
                            <ul>
                                <li><b>🔗 Kết nối:</b> Đăng nhập Google để đồng bộ lịch</li>
                                <li><b>⚙️ Chế độ đồng bộ:</b> Tự động khi có thay đổi hoặc thủ công</li>
                                <li><b>📤 Đồng bộ ngay:</b> Đồng bộ tất cả việc có deadline vào lịch</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section id="settings" class="section">
                    <div class="section-header">
                        <div class="section-icon">⚙️</div>
                        <h2 class="section-title">Cài Đặt</h2>
                    </div>
                    <div class="command-item">
                        <span class="command-code">/caidat</span>
                        <span class="command-desc">Mở menu cài đặt cá nhân</span>
                    </div>
                    <div class="tip-box">
                        <span class="tip-icon">💡</span>
                        <div class="tip-content">
                            <strong>Menu cài đặt:</strong>
                            <ul>
                                <li><b>🔔 Thông báo:</b> Giao việc mới, trạng thái việc, nhắc việc, báo cáo tuần/tháng</li>
                                <li><b>🌏 Múi giờ:</b> Chọn múi giờ hiển thị</li>
                            </ul>
                        </div>
                    </div>
                </section>

                <section id="tips" class="section">
                    <div class="section-header">
                        <div class="section-icon">💡</div>
                        <h2 class="section-title">Mẹo Sử Dụng</h2>
                    </div>
                    <div class="tips-grid">
                        <div class="tip-card green">
                            <span class="tip-icon">✨</span>
                            <div>
                                <h4>Thời gian linh hoạt</h4>
                                <p>Bot hiểu các cách viết thời gian như: "14h30", "ngày mai 10h", "thứ 2 tuần sau", "15/12 9h", "2 ngày nữa"...</p>
                            </div>
                        </div>
                        <div class="tip-card blue">
                            <span class="tip-icon">🎯</span>
                            <div>
                                <h4>Mức ưu tiên</h4>
                                <p>Khi tạo việc, bạn có thể chọn mức ưu tiên: Khẩn cấp > Cao > Bình thường > Thấp. Việc khẩn cấp sẽ được nhắc thường xuyên hơn.</p>
                            </div>
                        </div>
                        <div class="tip-card purple">
                            <span class="tip-icon">🔔</span>
                            <div>
                                <h4>Nhắc tự động</h4>
                                <p>Bot tự động nhắc trước deadline 24 giờ và 1 giờ. Bạn có thể đặt thêm nhắc tùy chỉnh với /nhacviec.</p>
                            </div>
                        </div>
                    </div>
                </section>

                <div class="footer">
                    <p><span class="brand bot-name">TeleTask Bot</span> — Quản lý công việc hiệu quả</p>
                </div>
            </main>
        </div>
    </div>

    <script>
        // Elements
        const sidebar = document.getElementById('sidebar');
        const overlay = document.getElementById('overlay');
        const menuButton = document.getElementById('menuButton');
        const sidebarClose = document.getElementById('sidebarClose');

        // Open sidebar
        function openSidebar() {
            sidebar.classList.add('open');
            overlay.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        // Close sidebar
        function closeSidebar() {
            sidebar.classList.remove('open');
            overlay.classList.remove('active');
            document.body.style.overflow = '';
        }

        // Event listeners
        menuButton.addEventListener('click', openSidebar);
        sidebarClose.addEventListener('click', closeSidebar);
        overlay.addEventListener('click', closeSidebar);

        // Handle navigation clicks
        document.querySelectorAll('.sidebar-item[href^="#"]').forEach(function(link) {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    // Update active state
                    document.querySelectorAll('.sidebar-item').forEach(function(item) {
                        item.classList.remove('active');
                    });
                    this.classList.add('active');

                    // Scroll to target
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });

                    // Close sidebar on mobile
                    if (window.innerWidth <= 768) {
                        closeSidebar();
                    }
                }
            });
        });

        // Load bot name from config
        fetch('/config.json')
            .then(function(response) { return response.json(); })
            .then(function(config) {
                var botName = config.bot_name || 'TeleTask Bot';
                document.querySelectorAll('.bot-name').forEach(function(el) {
                    el.textContent = botName;
                });
                document.title = 'Hướng Dẫn Sử Dụng - ' + botName;
            })
            .catch(function() {});
    </script>
</body>
</html>
</file>

<file path="static/user-guide.html">
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tài Liệu Đầy Đủ - TeleTask Bot</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'SF Pro Text', 'Helvetica Neue', sans-serif;
            background: linear-gradient(180deg, #f5f5f7 0%, #e8e8ed 100%);
            min-height: 100vh;
            padding: 30px;
            -webkit-font-smoothing: antialiased;
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            box-shadow: 0 22px 70px 4px rgba(0,0,0,0.12);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(180deg, #e8e8e8 0%, #d6d6d6 100%);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        .traffic-lights { display: flex; gap: 8px; }
        .traffic-light { width: 12px; height: 12px; border-radius: 50%; }
        .light-close { background: #ff5f57; }
        .light-minimize { background: #febc2e; }
        .light-maximize { background: #28c840; }
        .header-title { flex: 1; text-align: center; font-size: 13px; font-weight: 500; color: #4d4d4d; }
        .back-btn {
            background: none;
            border: none;
            font-size: 14px;
            color: #007aff;
            cursor: pointer;
            padding: 4px 12px;
            border-radius: 6px;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .back-btn:hover { background: rgba(0,122,255,0.1); }
        .content { padding: 40px; }

        /* Typography */
        h1 { font-size: 28px; font-weight: 700; color: #1d1d1f; margin-bottom: 12px; text-align: center; }
        .subtitle { font-size: 16px; color: #86868b; text-align: center; margin-bottom: 40px; }
        h2 { font-size: 22px; font-weight: 600; color: #1d1d1f; margin: 40px 0 16px; padding-bottom: 10px; border-bottom: 2px solid #007aff; }
        h3 { font-size: 17px; font-weight: 600; color: #1d1d1f; margin: 24px 0 12px; }
        p { font-size: 15px; color: #1d1d1f; margin-bottom: 12px; }

        /* Lists */
        ul, ol { margin: 12px 0 12px 24px; }
        li { font-size: 15px; color: #1d1d1f; margin-bottom: 8px; }

        /* Tables */
        table { width: 100%; border-collapse: collapse; margin: 16px 0 24px; }
        th, td { padding: 12px 16px; text-align: left; border-bottom: 1px solid rgba(0,0,0,0.08); }
        th { background: #f5f5f7; font-weight: 600; font-size: 13px; color: #86868b; text-transform: uppercase; }
        td { font-size: 14px; }
        tr:hover { background: rgba(0,122,255,0.04); }

        /* Code */
        code {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 13px;
            background: rgba(0,122,255,0.08);
            color: #007aff;
            padding: 2px 8px;
            border-radius: 4px;
        }
        pre {
            background: #1d1d1f;
            color: #f5f5f7;
            padding: 16px 20px;
            border-radius: 10px;
            overflow-x: auto;
            margin: 12px 0 20px;
        }
        pre code { background: none; color: inherit; padding: 0; }

        /* Info boxes */
        .info-box {
            padding: 16px 20px;
            border-radius: 10px;
            margin: 16px 0;
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }
        .info-box.tip { background: rgba(52,199,89,0.08); border: 1px solid rgba(52,199,89,0.15); }
        .info-box.warning { background: rgba(255,149,0,0.08); border: 1px solid rgba(255,149,0,0.15); }
        .info-box.note { background: rgba(0,122,255,0.06); border: 1px solid rgba(0,122,255,0.1); }
        .info-box-icon { font-size: 20px; flex-shrink: 0; }
        .info-box-content { font-size: 14px; }
        .info-box-content strong { color: #248a3d; }
        .info-box.warning .info-box-content strong { color: #c93400; }
        .info-box.note .info-box-content strong { color: #0055d4; }

        /* Section cards */
        .section-card {
            background: #f5f5f7;
            border-radius: 12px;
            padding: 20px;
            margin: 16px 0;
        }
        .section-card h4 { font-size: 15px; font-weight: 600; margin-bottom: 12px; color: #1d1d1f; }

        /* Divider */
        hr { border: none; border-top: 1px solid rgba(0,0,0,0.08); margin: 32px 0; }

        /* Footer */
        .footer { text-align: center; padding: 30px; border-top: 1px solid rgba(0,0,0,0.08); margin-top: 40px; }
        .footer p { font-size: 13px; color: #86868b; }

        /* TOC */
        .toc {
            background: #f5f5f7;
            border-radius: 12px;
            padding: 20px 24px;
            margin-bottom: 32px;
        }
        .toc h3 { margin-top: 0; font-size: 15px; margin-bottom: 12px; }
        .toc ul { list-style: none; margin: 0; }
        .toc li { margin-bottom: 6px; }
        .toc a { color: #007aff; text-decoration: none; font-size: 14px; }
        .toc a:hover { text-decoration: underline; }

        /* Responsive */
        @media (max-width: 768px) {
            body { padding: 10px; }
            .content { padding: 24px; }
            h1 { font-size: 24px; }
            h2 { font-size: 20px; }
            table { font-size: 13px; }
            th, td { padding: 10px 12px; }
        }
        @media (max-width: 520px) {
            body { padding: 8px; }
            .content { padding: 16px; }
            h1 { font-size: 20px; }
            h2 { font-size: 18px; }
            .header-title { font-size: 12px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="/" class="back-btn">← Quay lại</a>
            <div class="traffic-lights">
                <div class="traffic-light light-close"></div>
                <div class="traffic-light light-minimize"></div>
                <div class="traffic-light light-maximize"></div>
            </div>
            <div class="header-title">Tài Liệu Đầy Đủ</div>
            <div style="width: 80px;"></div>
        </div>

        <div class="content">
            <h1>📋 Hướng Dẫn Sử Dụng TeleTask Bot</h1>
            <p class="subtitle">Bot quản lý công việc qua Telegram cho nhóm và cá nhân</p>

            <div class="toc">
                <h3>📑 Mục Lục</h3>
                <ul>
                    <li><a href="#start">Bắt Đầu Nhanh</a></li>
                    <li><a href="#taoviec">Tạo Việc (/taoviec)</a></li>
                    <li><a href="#giaoviec">Giao Việc (/giaoviec)</a></li>
                    <li><a href="#taskids">Loại Việc & Mã ID</a></li>
                    <li><a href="#commands">Các Lệnh Khác</a></li>
                    <li><a href="#stats">Thống Kê</a></li>
                    <li><a href="#calendar">Google Calendar</a></li>
                    <li><a href="#settings">Cài Đặt</a></li>
                    <li><a href="#tips">Mẹo Sử Dụng</a></li>
                </ul>
            </div>

            <h2 id="start">🚀 Bắt Đầu Nhanh</h2>
            <ol>
                <li>Khởi động bot: <code>/start</code></li>
                <li>Tạo việc: <code>/taoviec</code> (chế độ wizard)</li>
                <li>Giao việc: <code>/giaoviec</code> (chế độ wizard)</li>
                <li>Xem việc: <code>/xemviec</code></li>
            </ol>

            <hr>

            <h2 id="taoviec">📝 Tạo Việc (<code>/taoviec</code>)</h2>
            <p>Tạo việc từng bước với nút bấm hướng dẫn.</p>

            <h3>Cách Sử Dụng</h3>
            <ol>
                <li><strong>Bắt đầu wizard:</strong> Gõ <code>/taoviec</code> (không tham số)</li>
                <li><strong>Bước 1 - Nội dung:</strong> Nhập mô tả công việc</li>
                <li><strong>Bước 2 - Deadline:</strong> Chọn từ nút hoặc nhập thời gian</li>
                <li><strong>Bước 3 - Người nhận:</strong> Chọn "Cho mình" hoặc "Giao người khác"</li>
                <li><strong>Bước 4 - Độ ưu tiên:</strong> Chọn mức ưu tiên</li>
                <li><strong>Bước 5 - Xác nhận:</strong> Xem lại và tạo việc</li>
            </ol>

            <h3>Chế Độ Nhanh</h3>
            <p>Bỏ qua wizard bằng cách nhập trực tiếp:</p>
            <pre><code>/taoviec Hoàn thành báo cáo 17h</code></pre>

            <h3>Tùy Chọn Deadline</h3>
            <table>
                <tr><th>Nút</th><th>Ý nghĩa</th></tr>
                <tr><td>Hôm nay</td><td>Cuối ngày hôm nay (23:59)</td></tr>
                <tr><td>Ngày mai</td><td>Cuối ngày mai (23:59)</td></tr>
                <tr><td>Tuần sau</td><td>7 ngày từ bây giờ</td></tr>
                <tr><td>Tháng sau</td><td>30 ngày từ bây giờ</td></tr>
                <tr><td>Nhập thời gian</td><td>Nhập thời gian tùy chỉnh</td></tr>
                <tr><td>Bỏ qua</td><td>Không có deadline</td></tr>
            </table>

            <h3>Định Dạng Thời Gian</h3>
            <pre><code>14h30          → Hôm nay 14:30
ngày mai 10h   → Ngày mai 10:00
thứ 6 15h      → Thứ 6 tuần này 15:00
20/12 9h       → Ngày 20/12 lúc 09:00</code></pre>

            <hr>

            <h2 id="giaoviec">👥 Giao Việc (<code>/giaoviec</code>)</h2>
            <p>Giao việc cho một hoặc nhiều người.</p>

            <h3>Cách Sử Dụng</h3>
            <ol>
                <li><strong>Bắt đầu wizard:</strong> Gõ <code>/giaoviec</code> (không tham số)</li>
                <li><strong>Bước 1 - Nội dung:</strong> Nhập mô tả công việc</li>
                <li><strong>Bước 2 - Người nhận:</strong> Tag hoặc mention người dùng</li>
                <li><strong>Bước 3 - Deadline:</strong> Chọn deadline</li>
                <li><strong>Bước 4 - Độ ưu tiên:</strong> Chọn mức ưu tiên</li>
                <li><strong>Bước 5 - Xác nhận:</strong> Xem lại và giao việc</li>
            </ol>

            <h3>Chế Độ Nhanh</h3>
            <pre><code>/giaoviec @user Nội dung việc 14h
/giaoviec @user1 @user2 Việc nhóm 17h</code></pre>

            <h3>Cách Mention Người Dùng</h3>
            <div class="section-card">
                <h4>Hai cách mention:</h4>
                <ol>
                    <li><strong>@username</strong> - Cho người có username Telegram<br><code>@usertelegram2025 @hasontech2050</code></li>
                    <li><strong>Text mention</strong> - Cho người KHÔNG có username
                        <ul>
                            <li>Nhấn vào tên thành viên trong nhóm</li>
                            <li>Chọn "Mention" từ popup</li>
                            <li>Hoạt động ngay cả khi người dùng không có @username</li>
                        </ul>
                    </li>
                </ol>
            </div>

            <div class="info-box note">
                <span class="info-box-icon">ℹ️</span>
                <div class="info-box-content">
                    <strong>Lưu ý trong nhóm:</strong> Bạn phải REPLY tin nhắn của bot khi nhập text (vuốt phải tin nhắn bot → Reply). Do chế độ bảo mật của Telegram bot.
                </div>
            </div>

            <hr>

            <h2 id="taskids">🏷️ Loại Việc & Mã ID</h2>
            <table>
                <tr><th>Định dạng</th><th>Loại</th><th>Mô tả</th></tr>
                <tr><td><code>T-xxx</code></td><td>Việc cá nhân</td><td>Việc một người nhận</td></tr>
                <tr><td><code>G-xxx</code></td><td>Việc nhóm</td><td>Việc nhiều người (cha)</td></tr>
                <tr><td><code>P-xxx</code></td><td>Việc con</td><td>Việc con của việc nhóm</td></tr>
            </table>

            <h3>Mức Độ Ưu Tiên</h3>
            <table>
                <tr><th>Mức</th><th>Icon</th><th>Mô tả</th></tr>
                <tr><td>Khẩn cấp</td><td>🔴</td><td>Cần xử lý ngay</td></tr>
                <tr><td>Cao</td><td>🟠</td><td>Ưu tiên cao</td></tr>
                <tr><td>Bình thường</td><td>🟡</td><td>Mặc định</td></tr>
                <tr><td>Thấp</td><td>🟢</td><td>Ưu tiên thấp</td></tr>
            </table>

            <hr>

            <h2 id="commands">⌨️ Các Lệnh Khác</h2>
            <table>
                <tr><th>Lệnh</th><th>Mô tả</th></tr>
                <tr><td><code>/xemviec</code></td><td>Xem việc với menu phân loại</td></tr>
                <tr><td><code>/xemviec T-123</code></td><td>Xem chi tiết việc</td></tr>
                <tr><td><code>/xong T-123</code></td><td>Đánh dấu hoàn thành</td></tr>
                <tr><td><code>/danglam T-123</code></td><td>Đánh dấu đang làm</td></tr>
                <tr><td><code>/xoa T-123</code></td><td>Xóa việc</td></tr>
                <tr><td><code>/viecdagiao</code></td><td>Xem việc đã giao cho người khác</td></tr>
                <tr><td><code>/vieccanhan</code></td><td>Tạo việc cá nhân</td></tr>
                <tr><td><code>/nhacviec T-123 14h</code></td><td>Đặt nhắc nhở</td></tr>
                <tr><td><code>/thongtin</code></td><td>Thông tin bot</td></tr>
            </table>

            <h3>Xóa Hàng Loạt</h3>
            <table>
                <tr><th>Lệnh</th><th>Mô tả</th></tr>
                <tr><td><code>/xoahet</code></td><td>Xóa tất cả việc bạn tạo</td></tr>
                <tr><td><code>/xoaviecdagiao</code></td><td>Xóa việc đã giao cho người khác</td></tr>
            </table>

            <div class="info-box warning">
                <span class="info-box-icon">⚠️</span>
                <div class="info-box-content">
                    <strong>Cảnh báo:</strong> Xóa hàng loạt không thể hoàn tác!
                </div>
            </div>

            <hr>

            <h2 id="stats">📊 Thống Kê</h2>
            <table>
                <tr><th>Lệnh</th><th>Mô tả</th></tr>
                <tr><td><code>/thongke</code></td><td>Thống kê tổng hợp (tất cả)</td></tr>
                <tr><td><code>/thongketuan</code></td><td>Thống kê tuần này</td></tr>
                <tr><td><code>/thongkethang</code></td><td>Thống kê tháng này</td></tr>
                <tr><td><code>/viectrehan</code></td><td>Xem việc trễ hạn</td></tr>
                <tr><td><code>/export</code></td><td>Xuất báo cáo (CSV, Excel, PDF)</td></tr>
            </table>

            <h3>Phân Loại Thống Kê</h3>
            <ul>
                <li><strong>Việc đã giao:</strong> Việc bạn giao cho người khác</li>
                <li><strong>Việc được giao:</strong> Việc người khác giao cho bạn</li>
                <li><strong>Việc cá nhân:</strong> Việc tự tạo cho mình</li>
            </ul>

            <hr>

            <h2 id="calendar">📅 Google Calendar (<code>/lichgoogle</code>)</h2>
            <p>Đồng bộ deadline việc với Google Calendar.</p>

            <h3>Cách Kết Nối</h3>
            <ol>
                <li>Chạy <code>/lichgoogle</code></li>
                <li>Nhấn nút "🔗 Kết nối Google"</li>
                <li>Đăng nhập tài khoản Google</li>
                <li>Cấp quyền truy cập calendar</li>
                <li>Quay lại Telegram - thấy thông báo thành công</li>
            </ol>

            <h3>Menu Cài Đặt</h3>
            <table>
                <tr><th>Nút</th><th>Chức năng</th></tr>
                <tr><td>🔄 Chế độ đồng bộ</td><td>Chuyển chế độ (Tự động/Thủ công)</td></tr>
                <tr><td>⚡ Đồng bộ ngay</td><td>Đồng bộ tất cả việc vào lịch ngay</td></tr>
                <tr><td>❌ Ngắt kết nối</td><td>Ngắt kết nối tài khoản Google</td></tr>
            </table>

            <h3>Những Gì Được Đồng Bộ</h3>
            <ul>
                <li>✅ Tạo việc → Tạo sự kiện calendar</li>
                <li>✅ Cập nhật việc → Cập nhật sự kiện calendar</li>
                <li>✅ Xóa việc → Xóa sự kiện calendar</li>
                <li>✅ Khôi phục việc → Khôi phục sự kiện calendar</li>
                <li>✅ Hoàn thành việc → Sự kiện hiển thị ✅ ở tiêu đề</li>
            </ul>

            <hr>

            <h2 id="settings">⚙️ Cài Đặt (<code>/caidat</code>)</h2>
            <p>Cấu hình thông báo và múi giờ.</p>

            <h3>Menu Cài Đặt</h3>
            <table>
                <tr><th>Nút</th><th>Chức năng</th></tr>
                <tr><td>🔔 Thông báo</td><td>Cài đặt thông báo</td></tr>
                <tr><td>🌏 Múi giờ</td><td>Cài đặt múi giờ</td></tr>
            </table>

            <h3>Cài Đặt Thông Báo</h3>
            <table>
                <tr><th>Cài đặt</th><th>Mô tả</th></tr>
                <tr><td>📥 Giao việc</td><td>Khi ai đó giao việc cho bạn</td></tr>
                <tr><td>📊 Trạng thái</td><td>Khi trạng thái việc thay đổi</td></tr>
                <tr><td>⏰ Nhắc việc</td><td>Nhắc nhở trước deadline</td></tr>
                <tr><td>📈 Báo cáo</td><td>Báo cáo tổng hợp hàng ngày/tuần</td></tr>
            </table>

            <h3>Cài Đặt Nhắc Nhở</h3>
            <table>
                <tr><th>Tùy chọn</th><th>Thời điểm</th></tr>
                <tr><td>24 giờ trước</td><td>24 giờ trước deadline</td></tr>
                <tr><td>1 giờ trước</td><td>1 giờ trước deadline</td></tr>
                <tr><td>30 phút trước</td><td>30 phút trước deadline</td></tr>
                <tr><td>5 phút trước</td><td>5 phút trước deadline</td></tr>
                <tr><td>Khi trễ hạn</td><td>Khi việc trễ hạn</td></tr>
            </table>

            <h3>Nguồn Nhắc Nhở</h3>
            <table>
                <tr><th>Nguồn</th><th>Mô tả</th></tr>
                <tr><td>Telegram</td><td>Bot gửi nhắc nhở trong chat</td></tr>
                <tr><td>Google Calendar</td><td>Thông báo từ ứng dụng Calendar</td></tr>
                <tr><td>Cả hai</td><td>Cả Telegram và Calendar</td></tr>
            </table>

            <hr>

            <h2 id="tips">💡 Mẹo Sử Dụng</h2>

            <div class="info-box tip">
                <span class="info-box-icon">✨</span>
                <div class="info-box-content">
                    <strong>Dùng wizard</strong> cho việc phức tạp với nhiều tùy chọn
                </div>
            </div>

            <div class="info-box tip">
                <span class="info-box-icon">⚡</span>
                <div class="info-box-content">
                    <strong>Dùng chế độ nhanh</strong> cho việc đơn giản
                </div>
            </div>

            <div class="info-box tip">
                <span class="info-box-icon">👤</span>
                <div class="info-box-content">
                    <strong>Text mention</strong> hoạt động với người không có @username
                </div>
            </div>

            <div class="info-box tip">
                <span class="info-box-icon">💬</span>
                <div class="info-box-content">
                    <strong>Reply tin nhắn bot</strong> trong nhóm chat khi nhập text
                </div>
            </div>

            <div class="info-box tip">
                <span class="info-box-icon">📅</span>
                <div class="info-box-content">
                    <strong>Kết nối Google Calendar</strong> (<code>/lichgoogle</code>) để nhận thông báo calendar
                </div>
            </div>

            <div class="info-box tip">
                <span class="info-box-icon">🔔</span>
                <div class="info-box-content">
                    <strong>Dùng "Cả hai" nguồn nhắc</strong> để nhận thông báo qua cả Telegram và Calendar
                </div>
            </div>

            <div class="footer">
                <p>TeleTask Bot — Quản lý công việc hiệu quả qua Telegram</p>
            </div>
        </div>
    </div>
</body>
</html>
</file>

<file path="static/user-guide.md">
# Hướng Dẫn Sử Dụng TeleTask Bot

Bot quản lý công việc qua Telegram cho nhóm và cá nhân.

## Bắt Đầu Nhanh

1. Khởi động bot: `/start`
2. Tạo việc: `/taoviec` (chế độ wizard)
3. Giao việc: `/giaoviec` (chế độ wizard)
4. Xem việc: `/xemviec`

---

## Tạo Việc (`/taoviec`)

Tạo việc từng bước với nút bấm hướng dẫn.

### Cách Sử Dụng

1. **Bắt đầu wizard**: Gõ `/taoviec` (không tham số)
2. **Bước 1 - Nội dung**: Nhập mô tả công việc
3. **Bước 2 - Deadline**: Chọn từ nút hoặc nhập thời gian
4. **Bước 3 - Người nhận**: Chọn "Cho mình" hoặc "Giao người khác"
5. **Bước 4 - Độ ưu tiên**: Chọn mức ưu tiên
6. **Bước 5 - Xác nhận**: Xem lại và tạo việc

### Chế Độ Nhanh

Bỏ qua wizard bằng cách nhập trực tiếp:
```
/taoviec Hoàn thành báo cáo 17h
```

### Tùy Chọn Deadline

| Nút | Ý nghĩa |
|-----|---------|
| Hôm nay | Cuối ngày hôm nay (23:59) |
| Ngày mai | Cuối ngày mai (23:59) |
| Tuần sau | 7 ngày từ bây giờ |
| Tháng sau | 30 ngày từ bây giờ |
| Nhập thời gian | Nhập thời gian tùy chỉnh |
| Bỏ qua | Không có deadline |

### Định Dạng Thời Gian

```
14h30          → Hôm nay 14:30
ngày mai 10h   → Ngày mai 10:00
thứ 6 15h      → Thứ 6 tuần này 15:00
20/12 9h       → Ngày 20/12 lúc 09:00
```

---

## Giao Việc (`/giaoviec`)

Giao việc cho một hoặc nhiều người.

### Cách Sử Dụng

1. **Bắt đầu wizard**: Gõ `/giaoviec` (không tham số)
2. **Bước 1 - Nội dung**: Nhập mô tả công việc
3. **Bước 2 - Người nhận**: Tag hoặc mention người dùng
4. **Bước 3 - Deadline**: Chọn deadline
5. **Bước 4 - Độ ưu tiên**: Chọn mức ưu tiên
6. **Bước 5 - Xác nhận**: Xem lại và giao việc

### Chế Độ Nhanh

```
/giaoviec @user Nội dung việc 14h
/giaoviec @user1 @user2 Việc nhóm 17h
```

### Cách Mention Người Dùng

**Hai cách mention:**

1. **@username** - Cho người có username Telegram
   ```
   @myduyenn2202 @xuanson319
   ```

2. **Text mention** - Cho người KHÔNG có username
   - Nhấn vào tên thành viên trong nhóm
   - Chọn "Mention" từ popup
   - Hoạt động ngay cả khi người dùng không có @username

### Lưu Ý Trong Nhóm

Trong nhóm chat, bạn phải **REPLY** tin nhắn của bot khi nhập text:
- Vuốt phải tin nhắn bot → Reply
- Do chế độ bảo mật của Telegram bot

---

## Loại Việc & Mã ID

| Định dạng | Loại | Mô tả |
|-----------|------|-------|
| T-xxx | Việc cá nhân | Việc một người nhận |
| G-xxx | Việc nhóm | Việc nhiều người (cha) |
| P-xxx | Việc con | Việc con của việc nhóm |

---

## Mức Độ Ưu Tiên

| Mức | Icon | Mô tả |
|-----|------|-------|
| Khẩn cấp | 🔴 | Cần xử lý ngay |
| Cao | 🟠 | Ưu tiên cao |
| Bình thường | 🟡 | Mặc định |
| Thấp | 🟢 | Ưu tiên thấp |

---

## Các Lệnh Khác

| Lệnh | Mô tả |
|------|-------|
| `/xemviec` | Xem việc với menu phân loại |
| `/xemviec T-123` | Xem chi tiết việc |
| `/xong T-123` | Đánh dấu hoàn thành |
| `/danglam T-123` | Đánh dấu đang làm |
| `/xoa T-123` | Xóa việc |
| `/viecdagiao` | Xem việc đã giao cho người khác |
| `/vieccanhan` | Tạo việc cá nhân |
| `/nhacviec T-123 14h` | Đặt nhắc nhở |
| `/thongtin` | Thông tin bot |

---

## Lệnh Thống Kê

| Lệnh | Mô tả |
|------|-------|
| `/thongke` | Thống kê tổng hợp (tất cả) |
| `/thongketuan` | Thống kê tuần này |
| `/thongkethang` | Thống kê tháng này |

### Phân Loại Thống Kê

- **Việc đã giao**: Việc bạn giao cho người khác
- **Việc được giao**: Việc người khác giao cho bạn
- **Việc cá nhân**: Việc tự tạo cho mình

---

## Việc Trễ Hạn (`/viectrehan`)

Xem việc trễ hạn, mặc định lọc theo tháng hiện tại.

### Cách Sử Dụng

```
/viectrehan
```

Hiển thị việc trễ hạn của **tháng hiện tại** với nút lọc:
- 📅 **Hôm nay** - Việc trễ hạn hôm nay
- 📆 **Tuần này** - Việc trễ hạn tuần này
- 📊 **Tất cả** - Tất cả việc trễ hạn

### Reset Hàng Tháng

Số việc trễ hạn tự động reset đầu mỗi tháng mới. Giúp theo dõi hiệu suất theo tháng.

---

## Thông Báo Riêng

Khi tạo việc trong **nhóm chat**, người được giao nhận thông báo riêng qua tin nhắn DM từ bot.

### Cách Hoạt Động

1. Người tạo giao việc trong nhóm: `/giaoviec @user1 @user2 Nội dung`
2. Bot trả lời trong nhóm với xác nhận
3. Mỗi người nhận được **tin nhắn riêng** với chi tiết việc

### Lợi Ích

- Người nhận không bỏ lỡ việc ngay cả khi tắt thông báo nhóm
- Chi tiết việc có sẵn trong chat riêng để xem lại
- Hoạt động với cả việc một và nhiều người

---

## Chỉnh Sửa Việc

Sau khi xem việc với `/xemviec T-123`, sử dụng các nút menu chỉnh sửa.

### Tùy Chọn Chỉnh Sửa

| Nút | Chức năng |
|-----|-----------|
| 📝 Sửa nội dung | Chỉnh sửa nội dung việc |
| 📅 Sửa deadline | Thay đổi deadline |
| 👤 Sửa người nhận | Thay đổi người nhận |
| 🔔 Sửa độ ưu tiên | Thay đổi mức ưu tiên |

### Sửa Người Nhận

**Hai cách thay đổi người nhận:**

1. **@username** - Gõ username trực tiếp
   ```
   @newuser
   ```

2. **Text mention** - Cho người KHÔNG có @username
   - Nhấn vào tên thành viên trong nhóm
   - Chọn "Mention" từ popup
   - Reply tin nhắn chỉnh sửa của bot

**Chuyển đổi loại việc:**
- 1 người nhận → Việc cá nhân (P-ID)
- Nhiều người nhận → Việc nhóm (G-ID với P-IDs)

**Lưu ý:**
- Reply (vuốt phải) tin nhắn bot khi nhập text
- Link mention có thể click trong tin nhắn xác nhận

---

## Xóa Hàng Loạt

Xóa nhiều việc cùng lúc. Chỉ người tạo việc mới có thể xóa.

| Lệnh | Mô tả |
|------|-------|
| `/xoahet` | Xóa tất cả việc bạn tạo |
| `/xoaviecdagiao` | Xóa việc đã giao cho người khác |

### Cách Hoạt Động

1. Chạy lệnh
2. Bot hiển thị danh sách việc sẽ bị xóa (tối đa 5)
3. Nhấn **"Xác nhận"** để xóa hoặc **"Hủy"** để hủy

⚠️ **Cảnh báo:** Xóa hàng loạt không thể hoàn tác!

### Ví Dụ

```
/xoahet
→ Hiển thị: "Bạn có 3 việc sẽ bị xóa"
→ • P-0001: Hoàn thành báo cáo...
→ • P-0002: Gửi email...
→ • T-0003: Review code...
→ [Xác nhận xóa 3 việc] [Hủy]
```

---

## Xuất Báo Cáo (`/export`)

Xuất thống kê việc dưới dạng CSV, Excel, hoặc PDF.

### Cách Sử Dụng

1. Chạy `/export`
2. Chọn khoảng thời gian (7 ngày, 30 ngày, tuần này, tháng này, tùy chỉnh)
3. Chọn bộ lọc việc (tất cả, đã tạo, đã giao, được giao)
4. Chọn định dạng (CSV, Excel, PDF)
5. Nhận link tải với mật khẩu

### Truy Cập Báo Cáo

- Báo cáo được bảo vệ bằng mật khẩu
- Link tải hết hạn sau **72 giờ**
- Giao diện web kiểu MacOS để nhập mật khẩu

---

## Tích Hợp Google Calendar (`/lichgoogle`)

Đồng bộ deadline việc với Google Calendar.

### Cách Kết Nối

1. Chạy `/lichgoogle`
2. Nhấn nút "🔗 Kết nối Google"
3. Đăng nhập tài khoản Google
4. Cấp quyền truy cập calendar
5. Quay lại Telegram - thấy thông báo thành công

### Menu Cài Đặt

Sau khi kết nối, `/lichgoogle` hiển thị menu cài đặt:

| Nút | Chức năng |
|-----|-----------|
| 🔄 Chế độ đồng bộ | Chuyển chế độ (Tự động/Thủ công) |
| ⚡ Đồng bộ ngay | Đồng bộ tất cả việc vào lịch ngay |
| ❌ Ngắt kết nối | Ngắt kết nối tài khoản Google |

### Chế Độ Đồng Bộ

| Chế độ | Mô tả |
|--------|-------|
| **Tự động** | Đồng bộ ngay khi việc thay đổi |
| **Thủ công** | Chỉ đồng bộ khi nhấn "Đồng bộ ngay" |

### Những Gì Được Đồng Bộ

- ✅ Tạo việc → Tạo sự kiện calendar
- ✅ Cập nhật việc → Cập nhật sự kiện calendar
- ✅ Xóa việc → Xóa sự kiện calendar
- ✅ Khôi phục việc → Khôi phục sự kiện calendar
- ✅ Hoàn thành việc → Sự kiện hiển thị ✅ ở tiêu đề

### Tính Năng

- Deadline việc trở thành sự kiện calendar
- Việc hoàn thành hiển thị ✅ trong tiêu đề calendar
- Việc đã xóa được xóa khỏi calendar
- Hoạt động với thông báo Google Calendar

---

## Cài Đặt (`/caidat`)

Cấu hình thông báo và múi giờ.

### Tùy Chọn Menu

| Nút | Chức năng |
|-----|-----------|
| 🔔 Thông báo | Cài đặt thông báo |
| 🌏 Múi giờ | Cài đặt múi giờ |

### Cài Đặt Thông Báo

Kiểm soát thông báo nào bạn nhận:

| Cài đặt | Mô tả |
|---------|-------|
| 📥 Giao việc | Khi ai đó giao việc cho bạn |
| 📊 Trạng thái | Khi trạng thái việc thay đổi |
| ⏰ Nhắc việc | Nhắc nhở trước deadline |
| 📈 Báo cáo | Báo cáo tổng hợp hàng ngày/tuần |

### Cài Đặt Nhắc Nhở

Đặt thời điểm nhận nhắc nhở:

| Tùy chọn | Thời điểm |
|----------|-----------|
| 24 giờ trước | 24 giờ trước deadline |
| 1 giờ trước | 1 giờ trước deadline |
| 30 phút trước | 30 phút trước deadline |
| 5 phút trước | 5 phút trước deadline |
| Khi trễ hạn | Khi việc trễ hạn |

### Nguồn Nhắc Nhở

Chọn nơi nhận nhắc nhở:

| Nguồn | Mô tả |
|-------|-------|
| Telegram | Bot gửi nhắc nhở trong chat |
| Google Calendar | Thông báo từ ứng dụng Calendar |
| Cả hai | Cả Telegram và Calendar |

### Múi Giờ

Chọn múi giờ để hiển thị deadline chính xác:
- Asia/Ho_Chi_Minh (UTC+7) - Mặc định
- Các múi giờ chính khác có sẵn

---

## Giao Diện Web

TeleTask cung cấp giao diện web kiểu MacOS.

### Các Trang

| Trang | Mục đích | URL |
|-------|----------|-----|
| Hướng dẫn | Tài liệu bot | `/` |
| Tải báo cáo | Truy cập báo cáo có mật khẩu | `/report/{id}` |
| OAuth Callback | Xác thực Google Calendar | Nội bộ |

### Thiết Kế Responsive

Trang hướng dẫn tự động điều chỉnh theo kích thước màn hình:

| Thiết bị | Bố cục |
|----------|--------|
| Desktop (>1024px) | 4 cột + sidebar |
| Tablet (768-1024px) | 4 cột compact |
| Mobile (520-768px) | 4 cột nhỏ |
| Mobile nhỏ (<520px) | Lưới 2x2 |

---

## Mẹo Sử Dụng

1. **Dùng wizard** cho việc phức tạp với nhiều tùy chọn
2. **Dùng chế độ nhanh** cho việc đơn giản
3. **Text mention** hoạt động với người không có @username
4. **Reply tin nhắn bot** trong nhóm chat khi nhập text
5. **Link mention** trong xác nhận để thông báo người nhận
6. **Báo cáo xuất** được bảo vệ bằng mật khẩu
7. **Hướng dẫn** có sẵn tại trang web để xem nhanh
8. **Kết nối Google Calendar** (`/lichgoogle`) để nhận thông báo calendar
9. **Tùy chỉnh thông báo** (`/caidat`) để kiểm soát cảnh báo nhận được
10. **Dùng "Cả hai" nguồn nhắc** để nhận thông báo qua cả Telegram và Calendar
</file>

<file path="utils/__init__.py">
"""
Bot Utilities Module
Helper functions and utilities

Utils:
- keyboards: Inline keyboard builders
- messages: Vietnamese message templates
- validators: Input validation
- formatters: Output formatting
"""

from .messages import (
    # Command responses
    MSG_START,
    MSG_START_GROUP,
    MSG_HELP,
    MSG_HELP_GROUP,
    MSG_INFO,
    # Task messages
    MSG_TASK_CREATED,
    MSG_TASK_ASSIGNED,
    MSG_TASK_RECEIVED,
    MSG_TASK_COMPLETED,
    MSG_TASK_DELETED,
    MSG_TASK_RESTORED,
    MSG_TASK_DETAIL,
    MSG_TASK_LIST,
    MSG_TASK_LIST_EMPTY,
    MSG_TASK_LIST_ITEM,
    # Reminder messages
    MSG_REMINDER_24H,
    MSG_REMINDER_1H,
    MSG_REMINDER_OVERDUE,
    # Error messages
    ERR_NO_PERMISSION,
    ERR_NOT_FOUND,
    ERR_TASK_NOT_FOUND,
    ERR_USER_NOT_FOUND,
    ERR_INVALID_TIME,
    ERR_NO_CONTENT,
    ERR_NO_ASSIGNEE,
    ERR_GROUP_ONLY,
    ERR_PRIVATE_ONLY,
    ERR_UNDO_EXPIRED,
    ERR_ALREADY_COMPLETED,
    ERR_DATABASE,
    # Labels
    STATUS_PENDING,
    STATUS_IN_PROGRESS,
    STATUS_COMPLETED,
    STATUS_CANCELLED,
    PRIORITY_LOW,
    PRIORITY_NORMAL,
    PRIORITY_HIGH,
    PRIORITY_URGENT,
    # Icons
    ICON_PENDING,
    ICON_IN_PROGRESS,
    ICON_COMPLETED,
    ICON_OVERDUE,
    ICON_URGENT,
    ICON_HIGH,
)

from .formatters import (
    format_status,
    format_priority,
    get_status_icon,
    format_datetime,
    format_task_detail,
    format_task_list,
    truncate,
    escape_html,
    escape_markdown,
    progress_bar,
    format_stats_overview,
    format_weekly_report,
    format_monthly_report,
    mention_user,
    mention_user_html,
)

from .keyboards import (
    task_actions_keyboard,
    task_detail_keyboard,
    task_category_keyboard,
    progress_keyboard,
    undo_keyboard,
    bulk_undo_keyboard,
    pagination_keyboard,
    task_list_with_pagination,
    priority_keyboard,
    confirm_keyboard,
    edit_menu_keyboard,
    edit_priority_keyboard,
    bulk_delete_confirm_keyboard,
    # Wizard keyboards
    wizard_deadline_keyboard,
    wizard_assignee_keyboard,
    wizard_priority_keyboard,
    wizard_confirm_keyboard,
    wizard_cancel_keyboard,
    task_type_filter_keyboard,
)

from .validators import (
    extract_mentions,
    validate_task_content,
    validate_priority,
    validate_status,
    validate_progress,
    parse_task_command,
    is_valid_public_id,
    sanitize_html,
)

from .db_utils import (
    validate_user_setting_column,
    get_report_column,
    InvalidColumnError,
    USER_SETTING_COLUMNS,
)

__all__ = [
    # Messages
    "MSG_START",
    "MSG_START_GROUP",
    "MSG_HELP",
    "MSG_HELP_GROUP",
    "MSG_INFO",
    "MSG_TASK_CREATED",
    "MSG_TASK_ASSIGNED",
    "MSG_TASK_RECEIVED",
    "MSG_TASK_COMPLETED",
    "MSG_TASK_DELETED",
    "MSG_TASK_RESTORED",
    "MSG_TASK_DETAIL",
    "MSG_TASK_LIST",
    "MSG_TASK_LIST_EMPTY",
    "MSG_TASK_LIST_ITEM",
    "MSG_REMINDER_24H",
    "MSG_REMINDER_1H",
    "MSG_REMINDER_OVERDUE",
    "ERR_NO_PERMISSION",
    "ERR_NOT_FOUND",
    "ERR_TASK_NOT_FOUND",
    "ERR_USER_NOT_FOUND",
    "ERR_INVALID_TIME",
    "ERR_NO_CONTENT",
    "ERR_NO_ASSIGNEE",
    "ERR_GROUP_ONLY",
    "ERR_PRIVATE_ONLY",
    "ERR_UNDO_EXPIRED",
    "ERR_ALREADY_COMPLETED",
    "ERR_DATABASE",
    "STATUS_PENDING",
    "STATUS_IN_PROGRESS",
    "STATUS_COMPLETED",
    "STATUS_CANCELLED",
    "PRIORITY_LOW",
    "PRIORITY_NORMAL",
    "PRIORITY_HIGH",
    "PRIORITY_URGENT",
    "ICON_PENDING",
    "ICON_IN_PROGRESS",
    "ICON_COMPLETED",
    "ICON_OVERDUE",
    "ICON_URGENT",
    "ICON_HIGH",
    # Formatters
    "format_status",
    "format_priority",
    "get_status_icon",
    "format_datetime",
    "format_task_detail",
    "format_task_list",
    "truncate",
    "escape_html",
    "escape_markdown",
    "progress_bar",
    "format_stats_overview",
    "format_weekly_report",
    "format_monthly_report",
    "mention_user",
    "mention_user_html",
    # Keyboards
    "task_actions_keyboard",
    "task_detail_keyboard",
    "task_category_keyboard",
    "progress_keyboard",
    "undo_keyboard",
    "bulk_undo_keyboard",
    "pagination_keyboard",
    "task_list_with_pagination",
    "priority_keyboard",
    "confirm_keyboard",
    "edit_menu_keyboard",
    "edit_priority_keyboard",
    "bulk_delete_confirm_keyboard",
    # Wizard keyboards
    "wizard_deadline_keyboard",
    "wizard_assignee_keyboard",
    "wizard_priority_keyboard",
    "wizard_confirm_keyboard",
    "wizard_cancel_keyboard",
    "task_type_filter_keyboard",
    # Validators
    "extract_mentions",
    "validate_task_content",
    "validate_priority",
    "validate_status",
    "validate_progress",
    "parse_task_command",
    "is_valid_public_id",
    "sanitize_html",
    # DB utils
    "validate_user_setting_column",
    "get_report_column",
    "InvalidColumnError",
    "USER_SETTING_COLUMNS",
]
</file>

<file path="utils/db_utils.py">
"""
Database Utilities
Security validations for dynamic SQL operations
"""

from typing import Set

# Whitelist of columns allowed for dynamic user setting updates
USER_SETTING_COLUMNS: Set[str] = {
    # Notification settings
    "notify_reminder",
    "notify_weekly_report",
    "notify_monthly_report",
    "notify_task_assigned",
    "notify_task_status",
    "notify_all",
    # Reminder settings
    "remind_24h",
    "remind_1h",
    "remind_30m",
    "remind_5m",
    "remind_overdue",
    "reminder_source",
    # Other settings
    "timezone",
    "calendar_sync_interval",
}

# Whitelist for report type columns
REPORT_TYPE_MAP = {
    "weekly": "notify_weekly_report",
    "monthly": "notify_monthly_report",
}


class InvalidColumnError(ValueError):
    """Raised when column name is not in whitelist."""
    pass


def validate_user_setting_column(column: str) -> str:
    """
    Validate column name against whitelist.

    Args:
        column: Column name to validate

    Returns:
        Validated column name

    Raises:
        InvalidColumnError: If column not in whitelist
    """
    if column not in USER_SETTING_COLUMNS:
        raise InvalidColumnError(f"Invalid column: {column}")
    return column


def get_report_column(report_type: str) -> str:
    """
    Get validated column name for report type.

    Args:
        report_type: 'weekly' or 'monthly'

    Returns:
        Column name

    Raises:
        InvalidColumnError: If invalid report type
    """
    if report_type not in REPORT_TYPE_MAP:
        raise InvalidColumnError(f"Invalid report type: {report_type}")
    return REPORT_TYPE_MAP[report_type]
</file>

<file path="utils/formatters.py">
"""
Message Formatters
Format task data for display
"""

import html
from datetime import datetime
from typing import Any, Dict, List, Optional
import pytz

from .messages import (
    MSG_TASK_DETAIL,
    MSG_TASK_LIST,
    MSG_TASK_LIST_EMPTY,
    MSG_TASK_LIST_ITEM,
    STATUS_PENDING,
    STATUS_IN_PROGRESS,
    STATUS_COMPLETED,
    STATUS_CANCELLED,
    PRIORITY_LOW,
    PRIORITY_NORMAL,
    PRIORITY_HIGH,
    PRIORITY_URGENT,
    ICON_PENDING,
    ICON_IN_PROGRESS,
    ICON_COMPLETED,
    ICON_OVERDUE,
    ICON_URGENT,
    ICON_HIGH,
)

TZ = pytz.timezone("Asia/Ho_Chi_Minh")


def format_status(status: str) -> str:
    """Format status to Vietnamese label."""
    status_map = {
        "pending": STATUS_PENDING,
        "in_progress": STATUS_IN_PROGRESS,
        "completed": STATUS_COMPLETED,
        "cancelled": STATUS_CANCELLED,
    }
    return status_map.get(status, status)


def format_priority(priority: str) -> str:
    """Format priority to Vietnamese label."""
    priority_map = {
        "low": PRIORITY_LOW,
        "normal": PRIORITY_NORMAL,
        "high": PRIORITY_HIGH,
        "urgent": PRIORITY_URGENT,
    }
    return priority_map.get(priority, priority)


def get_status_icon(task: Dict[str, Any]) -> str:
    """Get icon based on task status and deadline."""
    status = task.get("status", "pending")
    priority = task.get("priority", "normal")
    deadline = task.get("deadline")

    # Completed
    if status == "completed":
        return ICON_COMPLETED

    # Check overdue
    if deadline and isinstance(deadline, datetime):
        now = datetime.now(TZ)
        if deadline.tzinfo is None:
            deadline = TZ.localize(deadline)
        else:
            deadline = deadline.astimezone(TZ)
        if deadline < now:
            return ICON_OVERDUE

    # Priority icons
    if priority == "urgent":
        return ICON_URGENT
    elif priority == "high":
        return ICON_HIGH

    # Status icons
    if status == "in_progress":
        return ICON_IN_PROGRESS

    return ICON_PENDING


def format_datetime(dt: Optional[datetime], relative: bool = False) -> str:
    """Format datetime for display in Vietnam timezone."""
    if not dt:
        return "Không có"

    # Convert to Vietnam timezone
    if dt.tzinfo is None:
        dt = TZ.localize(dt)
    else:
        dt = dt.astimezone(TZ)

    # Format: HH:MM [weekday], DD/MM/YYYY
    time_str = dt.strftime("%H:%M")
    date_str = dt.strftime("%d/%m/%Y")
    weekdays = ["Thứ 2", "Thứ 3", "Thứ 4", "Thứ 5", "Thứ 6", "Thứ 7", "CN"]
    weekday_str = weekdays[dt.weekday()]

    if relative:
        now = datetime.now(TZ)
        delta = (dt.date() - now.date()).days

        if delta == 0:
            return f"{time_str} Hôm nay, {date_str}"
        elif delta == 1:
            return f"{time_str} Ngày mai, {date_str}"
        elif delta == 2:
            return f"{time_str} Ngày kia, {date_str}"
        elif delta == -1:
            return f"{time_str} Hôm qua, {date_str}"

    return f"{time_str} {weekday_str}, {date_str}"


def format_task_detail(task: Dict[str, Any]) -> str:
    """Format task for detailed view."""
    # Format group line if task belongs to a group
    group_name = task.get("group_name")
    group_line = f"<b>Nhóm:</b> {group_name}" if group_name else ""

    return MSG_TASK_DETAIL.format(
        task_id=task.get("public_id", ""),
        content=task.get("content", ""),
        status=format_status(task.get("status", "pending")),
        progress=task.get("progress", 0),
        priority=format_priority(task.get("priority", "normal")),
        creator=task.get("creator_name", "N/A"),
        assignee=task.get("assignee_name", "N/A"),
        deadline=format_datetime(task.get("deadline"), relative=True),
        group_line=group_line,
        created_at=format_datetime(task.get("created_at")),
        updated_at=format_datetime(task.get("updated_at")),
    )


def format_task_list(
    tasks: List[Dict[str, Any]],
    title: str,
    page: int = 1,
    page_size: int = 10,
    total: Optional[int] = None,
) -> str:
    """Format task list for display."""
    if not tasks:
        return MSG_TASK_LIST_EMPTY

    total = total or len(tasks)
    total_pages = (total + page_size - 1) // page_size

    task_lines = []
    for task in tasks:
        icon = get_status_icon(task)
        deadline_str = format_datetime(task.get("deadline"), relative=True)

        content = task.get("content", "")
        if len(content) > 30:
            content = content[:27] + "..."

        line = MSG_TASK_LIST_ITEM.format(
            icon=icon,
            task_id=task.get("public_id", ""),
            content=content,
            deadline=deadline_str,
        )
        task_lines.append(line)

    return MSG_TASK_LIST.format(
        title=title,
        tasks="\n".join(task_lines),
        page=page,
        total_pages=total_pages,
        total=total,
    )


def truncate(text: str, max_length: int = 50) -> str:
    """Truncate text with ellipsis."""
    if len(text) <= max_length:
        return text
    return text[: max_length - 3] + "..."


def escape_html(text: str) -> str:
    """
    Escape HTML special characters to prevent XSS.

    Escapes: & < > " '

    Args:
        text: Text to escape

    Returns:
        HTML-safe string
    """
    if not text:
        return ""
    return html.escape(text, quote=True)


def mention_user(user: Dict[str, Any]) -> str:
    """
    Create Telegram mention link for user.
    Format: [Display Name](tg://user?id=telegram_id)
    Works even if user has no username.

    Display name is escaped to prevent Markdown injection.
    """
    display_name = user.get("display_name") or user.get("username") or "User"
    telegram_id = user.get("telegram_id")

    # Escape Markdown special characters in display name
    safe_name = escape_markdown(display_name)

    if telegram_id:
        # telegram_id should be numeric, but sanitize anyway
        safe_id = str(int(telegram_id)) if isinstance(telegram_id, (int, str)) and str(telegram_id).isdigit() else ""
        if safe_id:
            return f"[{safe_name}](tg://user?id={safe_id})"

    return safe_name


def mention_user_html(user: Dict[str, Any]) -> str:
    """
    Create Telegram mention link for user (HTML format).
    Format: <a href="tg://user?id=telegram_id">Display Name</a>

    Display name is escaped to prevent XSS.
    """
    display_name = user.get("display_name") or user.get("username") or "User"
    telegram_id = user.get("telegram_id")

    # Escape display name to prevent XSS
    safe_name = escape_html(display_name)

    if telegram_id:
        # telegram_id should be numeric, but sanitize anyway
        safe_id = str(int(telegram_id)) if isinstance(telegram_id, (int, str)) and str(telegram_id).isdigit() else ""
        if safe_id:
            return f'<a href="tg://user?id={safe_id}">{safe_name}</a>'

    return safe_name


def escape_markdown(text: str) -> str:
    """
    Escape Markdown V2 special characters.

    Characters: _ * [ ] ( ) ~ ` > # + - = | { } . ! \\
    """
    if not text:
        return ""

    # MarkdownV2 special characters (backslash must be first)
    special_chars = ['\\', '_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']

    result = text
    for char in special_chars:
        result = result.replace(char, f'\\{char}')

    return result


def progress_bar(percentage: float, width: int = 10) -> str:
    """Create a visual progress bar."""
    filled = int(width * percentage / 100)
    empty = width - filled
    return "█" * filled + "░" * empty


def format_stats_overview(stats: Dict[str, Any], name: str) -> str:
    """Format all-time statistics overview."""
    total_assigned = stats.get("total_assigned", 0)
    assigned_done = stats.get("assigned_done", 0)
    total_received = stats.get("total_received", 0)
    received_done = stats.get("received_done", 0)
    total_personal = stats.get("total_personal", 0)
    personal_done = stats.get("personal_done", 0)

    assigned_rate = (assigned_done / max(total_assigned, 1)) * 100
    received_rate = (received_done / max(total_received, 1)) * 100
    personal_rate = (personal_done / max(total_personal, 1)) * 100

    total = total_assigned + total_received + total_personal
    completed = assigned_done + received_done + personal_done
    overall_rate = (completed / max(total, 1)) * 100

    return f"""📊 THỐNG KÊ TỔNG HỢP
👤 {name}

--- VIỆC BẠN ĐÃ GIAO ---
📊 Tổng: {total_assigned} việc
✅ Hoàn thành: {assigned_done} ({assigned_rate:.0f}%)
📈 {progress_bar(assigned_rate)} {assigned_rate:.0f}%

--- VIỆC BẠN NHẬN ---
📊 Tổng: {total_received} việc
✅ Hoàn thành: {received_done} ({received_rate:.0f}%)
📈 {progress_bar(received_rate)} {received_rate:.0f}%

--- VIỆC CÁ NHÂN ---
📊 Tổng: {total_personal} việc
✅ Hoàn thành: {personal_done} ({personal_rate:.0f}%)
📈 {progress_bar(personal_rate)} {personal_rate:.0f}%

────────────────────────
💪 Hiệu suất tổng: {overall_rate:.0f}%"""


def format_weekly_report(
    name: str,
    stats: Dict[str, Any],
    start,
    end,
    group_rankings: Optional[Dict] = None,
    prev_stats: Optional[Dict] = None,
) -> str:
    """Format weekly report."""
    assigned_total = stats.get("assigned_total", 0)
    assigned_completed = stats.get("assigned_completed", 0)
    assigned_overdue = stats.get("assigned_overdue", 0)

    received_total = stats.get("received_total", 0)
    received_completed = stats.get("received_completed", 0)
    received_overdue = stats.get("received_overdue", 0)

    personal_total = stats.get("personal_total", 0)
    personal_completed = stats.get("personal_completed", 0)

    assigned_rate = (assigned_completed / max(assigned_total, 1)) * 100
    received_rate = (received_completed / max(received_total, 1)) * 100
    personal_rate = (personal_completed / max(personal_total, 1)) * 100

    total = assigned_total + received_total + personal_total
    completed = assigned_completed + received_completed + personal_completed
    overall_rate = (completed / max(total, 1)) * 100

    # Comparison with previous week
    change_text = ""
    if prev_stats:
        prev_total = (
            prev_stats.get("assigned_total", 0)
            + prev_stats.get("received_total", 0)
            + prev_stats.get("personal_total", 0)
        )
        prev_completed = (
            prev_stats.get("assigned_completed", 0)
            + prev_stats.get("received_completed", 0)
            + prev_stats.get("personal_completed", 0)
        )
        prev_rate = (prev_completed / max(prev_total, 1)) * 100
        diff = overall_rate - prev_rate
        if diff > 0:
            change_text = f"\n📈 So với tuần trước: +{diff:.0f}%"
        elif diff < 0:
            change_text = f"\n📉 So với tuần trước: {diff:.0f}%"

    # Rankings text
    rank_text = ""
    if group_rankings:
        rank_lines = [f"🏆 {g}: #{r[0]}/{r[1]}" for g, r in group_rankings.items()]
        rank_text = "\n" + "\n".join(rank_lines)

    return f"""📊 BÁO CÁO CÔNG VIỆC TUẦN
📅 {start.strftime('%d/%m/%Y')} - {end.strftime('%d/%m/%Y')}
👤 {name}

--- VIỆC BẠN ĐÃ GIAO ---
📊 Tổng: {assigned_total} việc
✅ Hoàn thành: {assigned_completed} ({assigned_rate:.0f}%)
🚨 Trễ deadline: {assigned_overdue}
📈 {progress_bar(assigned_rate)} {assigned_rate:.0f}%

--- VIỆC BẠN NHẬN ---
📊 Tổng: {received_total} việc
✅ Hoàn thành: {received_completed} ({received_rate:.0f}%)
🚨 Trễ deadline: {received_overdue}
📈 {progress_bar(received_rate)} {received_rate:.0f}%

--- VIỆC CÁ NHÂN ---
📊 Tổng: {personal_total} việc
✅ Hoàn thành: {personal_completed} ({personal_rate:.0f}%)
📈 {progress_bar(personal_rate)} {personal_rate:.0f}%

────────────────────────
💪 Hiệu suất tuần: {overall_rate:.0f}%{change_text}{rank_text}"""


def format_monthly_report(
    name: str,
    stats: Dict[str, Any],
    prev_stats: Optional[Dict],
    start,
    end,
) -> str:
    """Format monthly report."""
    assigned_total = stats.get("assigned_total", 0)
    assigned_completed = stats.get("assigned_completed", 0)
    assigned_overdue = stats.get("assigned_overdue", 0)

    received_total = stats.get("received_total", 0)
    received_completed = stats.get("received_completed", 0)
    received_overdue = stats.get("received_overdue", 0)

    personal_total = stats.get("personal_total", 0)
    personal_completed = stats.get("personal_completed", 0)

    assigned_rate = (assigned_completed / max(assigned_total, 1)) * 100
    received_rate = (received_completed / max(received_total, 1)) * 100
    personal_rate = (personal_completed / max(personal_total, 1)) * 100

    total = assigned_total + received_total + personal_total
    completed = assigned_completed + received_completed + personal_completed
    overall_rate = (completed / max(total, 1)) * 100

    # Comparison with previous month
    change_text = ""
    if prev_stats:
        prev_total = (
            prev_stats.get("assigned_total", 0)
            + prev_stats.get("received_total", 0)
            + prev_stats.get("personal_total", 0)
        )
        prev_completed = (
            prev_stats.get("assigned_completed", 0)
            + prev_stats.get("received_completed", 0)
            + prev_stats.get("personal_completed", 0)
        )
        prev_rate = (prev_completed / max(prev_total, 1)) * 100
        diff = overall_rate - prev_rate
        if diff > 0:
            change_text = f"\n📈 So với tháng trước: +{diff:.0f}%"
        elif diff < 0:
            change_text = f"\n📉 So với tháng trước: {diff:.0f}%"

    month_name = start.strftime("%m/%Y")

    return f"""📊 BÁO CÁO CÔNG VIỆC THÁNG {month_name}
👤 {name}

--- VIỆC BẠN ĐÃ GIAO ---
📊 Tổng: {assigned_total} việc
✅ Hoàn thành: {assigned_completed} ({assigned_rate:.0f}%)
🚨 Trễ deadline: {assigned_overdue}
📈 {progress_bar(assigned_rate)} {assigned_rate:.0f}%

--- VIỆC BẠN NHẬN ---
📊 Tổng: {received_total} việc
✅ Hoàn thành: {received_completed} ({received_rate:.0f}%)
🚨 Trễ deadline: {received_overdue}
📈 {progress_bar(received_rate)} {received_rate:.0f}%

--- VIỆC CÁ NHÂN ---
📊 Tổng: {personal_total} việc
✅ Hoàn thành: {personal_completed} ({personal_rate:.0f}%)
📈 {progress_bar(personal_rate)} {personal_rate:.0f}%

────────────────────────
💪 Hiệu suất tháng: {overall_rate:.0f}%{change_text}"""
</file>

<file path="utils/keyboards.py">
"""
Inline Keyboards
Telegram inline keyboards for task management
"""

from typing import List, Optional
from telegram import InlineKeyboardButton, InlineKeyboardMarkup


def task_actions_keyboard(
    task_id: str,
    show_complete: bool = True,
    show_progress: bool = True,
    show_delete: bool = True,
) -> InlineKeyboardMarkup:
    """Create task action buttons - each on separate row for full display."""
    buttons = []

    if show_progress:
        buttons.append([
            InlineKeyboardButton("📊 Cập nhật tiến độ", callback_data=f"task_progress:{task_id}")
        ])

    buttons.append([
        InlineKeyboardButton("📝 Xem chi tiết", callback_data=f"task_detail:{task_id}")
    ])

    if show_delete:
        buttons.append([
            InlineKeyboardButton("🗑️ Xóa việc", callback_data=f"task_delete:{task_id}")
        ])

    if show_complete:
        buttons.append([
            InlineKeyboardButton("✅ HOÀN THÀNH", callback_data=f"task_complete:{task_id}")
        ])

    return InlineKeyboardMarkup(buttons)


def task_detail_keyboard(
    task_id: str,
    can_edit: bool = True,
    can_complete: bool = True,
) -> InlineKeyboardMarkup:
    """Create task detail action buttons - each on separate row."""
    buttons = []

    buttons.append([
        InlineKeyboardButton("📊 Cập nhật tiến độ", callback_data=f"task_progress:{task_id}"),
    ])

    if can_edit:
        buttons.append([
            InlineKeyboardButton("✏️ Sửa thông tin", callback_data=f"task_edit:{task_id}"),
        ])
        buttons.append([
            InlineKeyboardButton("🗑️ Xóa việc", callback_data=f"task_delete:{task_id}"),
        ])

    buttons.append([
        InlineKeyboardButton("« Quay lại danh mục", callback_data="task_category:menu")
    ])

    if can_complete:
        buttons.append([
            InlineKeyboardButton("✅ HOÀN THÀNH", callback_data=f"task_complete:{task_id}")
        ])

    return InlineKeyboardMarkup(buttons)


def task_category_keyboard() -> InlineKeyboardMarkup:
    """Create task category selection menu."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("📋 Việc cá nhân", callback_data="task_category:personal"),
        ],
        [
            InlineKeyboardButton("📤 Việc đã giao", callback_data="task_category:assigned"),
        ],
        [
            InlineKeyboardButton("📥 Việc đã nhận", callback_data="task_category:received"),
        ],
        [
            InlineKeyboardButton("📊 Tất cả việc", callback_data="task_category:all"),
        ],
    ])


def progress_keyboard(task_id: str) -> InlineKeyboardMarkup:
    """Create progress update buttons."""
    buttons = [
        [
            InlineKeyboardButton("25%", callback_data=f"progress:{task_id}:25"),
            InlineKeyboardButton("50%", callback_data=f"progress:{task_id}:50"),
            InlineKeyboardButton("75%", callback_data=f"progress:{task_id}:75"),
        ],
        [
            InlineKeyboardButton("« Quay lại", callback_data=f"task_detail:{task_id}"),
        ],
        [
            InlineKeyboardButton("✅ 100% HOÀN THÀNH", callback_data=f"progress:{task_id}:100"),
        ],
    ]
    return InlineKeyboardMarkup(buttons)


def undo_keyboard(undo_id: int, seconds_remaining: int = 10) -> InlineKeyboardMarkup:
    """Create undo button for deleted tasks with countdown."""
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(f"↩️ Hoàn tác ({seconds_remaining}s)", callback_data=f"task_undo:{undo_id}")]
    ])


def bulk_undo_keyboard(undo_id: int, count: int, seconds_remaining: int = 10) -> InlineKeyboardMarkup:
    """Create undo button for bulk deleted tasks with countdown."""
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(f"↩️ Hoàn tác {count} việc ({seconds_remaining}s)", callback_data=f"bulk_undo:{undo_id}")]
    ])


def pagination_keyboard(
    prefix: str,
    page: int,
    total_pages: int,
    extra_data: str = "",
) -> InlineKeyboardMarkup:
    """Create pagination buttons."""
    buttons = []

    nav_row = []
    if page > 1:
        nav_row.append(
            InlineKeyboardButton(
                "« Trước",
                callback_data=f"{prefix}:page:{page - 1}:{extra_data}"
            )
        )

    nav_row.append(
        InlineKeyboardButton(f"{page}/{total_pages}", callback_data="noop")
    )

    if page < total_pages:
        nav_row.append(
            InlineKeyboardButton(
                "Sau »",
                callback_data=f"{prefix}:page:{page + 1}:{extra_data}"
            )
        )

    buttons.append(nav_row)

    return InlineKeyboardMarkup(buttons)


def task_list_with_pagination(
    tasks: list,
    page: int,
    total_pages: int,
    list_type: str = "personal",
) -> InlineKeyboardMarkup:
    """Create task list with pagination."""
    buttons = []

    # Task buttons with longer content display
    for task in tasks:
        task_id = task.get("public_id", "")
        content = task.get("content", "")[:40]
        if len(task.get("content", "")) > 40:
            content += "..."

        buttons.append([
            InlineKeyboardButton(
                f"{task_id}: {content}",
                callback_data=f"task_detail:{task_id}"
            )
        ])

    # Pagination
    nav_row = []
    if page > 1:
        nav_row.append(
            InlineKeyboardButton("« Trước", callback_data=f"list:{list_type}:{page - 1}")
        )
    nav_row.append(
        InlineKeyboardButton(f"{page}/{total_pages}", callback_data="noop")
    )
    if page < total_pages:
        nav_row.append(
            InlineKeyboardButton("Sau »", callback_data=f"list:{list_type}:{page + 1}")
        )
    buttons.append(nav_row)

    # Back to category menu
    buttons.append([
        InlineKeyboardButton("« Quay lại danh mục", callback_data="task_category:menu")
    ])

    return InlineKeyboardMarkup(buttons)


def priority_keyboard(task_id: str) -> InlineKeyboardMarkup:
    """Create priority selection buttons."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("Thấp", callback_data=f"priority:{task_id}:low"),
            InlineKeyboardButton("Bình thường", callback_data=f"priority:{task_id}:normal"),
        ],
        [
            InlineKeyboardButton("Cao", callback_data=f"priority:{task_id}:high"),
            InlineKeyboardButton("🚨 Khẩn cấp", callback_data=f"priority:{task_id}:urgent"),
        ],
        [
            InlineKeyboardButton("« Quay lại", callback_data=f"task_detail:{task_id}"),
        ],
    ])


def confirm_keyboard(action: str, item_id: str) -> InlineKeyboardMarkup:
    """Create confirmation buttons."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("✅ Xác nhận", callback_data=f"confirm:{action}:{item_id}"),
            InlineKeyboardButton("❌ Huỷ", callback_data=f"cancel:{action}:{item_id}"),
        ]
    ])


def edit_menu_keyboard(task_id: str) -> InlineKeyboardMarkup:
    """Create edit options menu."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("📝 Sửa nội dung", callback_data=f"edit_content:{task_id}"),
        ],
        [
            InlineKeyboardButton("📅 Sửa deadline", callback_data=f"edit_deadline:{task_id}"),
        ],
        [
            InlineKeyboardButton("🔔 Sửa độ ưu tiên", callback_data=f"edit_priority:{task_id}"),
        ],
        [
            InlineKeyboardButton("👤 Sửa người nhận", callback_data=f"edit_assignee:{task_id}"),
        ],
        [
            InlineKeyboardButton("« Quay lại", callback_data=f"task_detail:{task_id}"),
        ],
    ])


def edit_priority_keyboard(task_id: str) -> InlineKeyboardMarkup:
    """Create priority edit buttons."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("⬇️ Thấp", callback_data=f"set_priority:{task_id}:low"),
            InlineKeyboardButton("➡️ Bình thường", callback_data=f"set_priority:{task_id}:normal"),
        ],
        [
            InlineKeyboardButton("⬆️ Cao", callback_data=f"set_priority:{task_id}:high"),
            InlineKeyboardButton("🚨 Khẩn cấp", callback_data=f"set_priority:{task_id}:urgent"),
        ],
        [
            InlineKeyboardButton("« Quay lại", callback_data=f"task_edit:{task_id}"),
        ],
    ])


# =============================================================================
# Wizard Keyboards for Step-by-Step Task Creation
# =============================================================================


def wizard_deadline_keyboard() -> InlineKeyboardMarkup:
    """Deadline selection buttons for wizard - each on separate row."""
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("📅 Hôm nay", callback_data="wizard_deadline:today")],
        [InlineKeyboardButton("📅 Ngày mai", callback_data="wizard_deadline:tomorrow")],
        [InlineKeyboardButton("📅 Tuần sau", callback_data="wizard_deadline:nextweek")],
        [InlineKeyboardButton("📅 Tháng sau", callback_data="wizard_deadline:nextmonth")],
        [InlineKeyboardButton("⏰ Nhập thời gian cụ thể", callback_data="wizard_deadline:custom")],
        [InlineKeyboardButton("⏭️ Bỏ qua (không đặt deadline)", callback_data="wizard_deadline:skip")],
        [InlineKeyboardButton("« Quay lại", callback_data="wizard_back:content")],
        [InlineKeyboardButton("❌ Hủy tạo việc", callback_data="wizard_cancel")],
    ])


def wizard_assignee_keyboard(
    recent_users: Optional[List[dict]] = None,
    is_private_chat: bool = False,
) -> InlineKeyboardMarkup:
    """Assignee selection buttons for wizard - each on separate row.

    Args:
        recent_users: List of recent users for quick selection
        is_private_chat: If True, hide "Giao việc cho người khác" option
    """
    buttons = [
        [InlineKeyboardButton("👤 Tạo việc cho bản thân", callback_data="wizard_assignee:self")],
    ]

    # Only show "Giao việc cho người khác" in group chats
    if not is_private_chat:
        buttons.append([
            InlineKeyboardButton("👥 Giao việc cho người khác", callback_data="wizard_assignee:others")
        ])

    # Add recent users if available (each on separate row) - only in groups
    if recent_users and not is_private_chat:
        for user in recent_users[:3]:
            name = user.get("display_name", "?")[:15]
            user_id = user.get("id")
            buttons.append([
                InlineKeyboardButton(f"👤 @{name}", callback_data=f"wizard_assignee:user:{user_id}")
            ])

    buttons.append([InlineKeyboardButton("« Quay lại", callback_data="wizard_back:deadline")])
    buttons.append([InlineKeyboardButton("❌ Hủy tạo việc", callback_data="wizard_cancel")])

    return InlineKeyboardMarkup(buttons)


def wizard_priority_keyboard() -> InlineKeyboardMarkup:
    """Priority selection buttons for wizard - each on separate row."""
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("🔴 Khẩn cấp", callback_data="wizard_priority:urgent")],
        [InlineKeyboardButton("🟠 Cao", callback_data="wizard_priority:high")],
        [InlineKeyboardButton("🟡 Bình thường", callback_data="wizard_priority:normal")],
        [InlineKeyboardButton("🟢 Thấp", callback_data="wizard_priority:low")],
        [InlineKeyboardButton("« Quay lại", callback_data="wizard_back:assignee")],
        [InlineKeyboardButton("❌ Hủy tạo việc", callback_data="wizard_cancel")],
    ])


def wizard_confirm_keyboard() -> InlineKeyboardMarkup:
    """Confirmation buttons for wizard - each on separate row."""
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("✏️ SỬA THÔNG TIN", callback_data="wizard_edit:menu")],
        [InlineKeyboardButton("❌ Hủy tạo việc", callback_data="wizard_confirm:cancel")],
        [InlineKeyboardButton("✅ XÁC NHẬN TẠO VIỆC", callback_data="wizard_confirm:create")],
    ])


def wizard_edit_menu_keyboard() -> InlineKeyboardMarkup:
    """Edit submenu for task creation wizard."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("✏️ Sửa nội dung", callback_data="wizard_edit:content"),
        ],
        [
            InlineKeyboardButton("📅 Sửa deadline", callback_data="wizard_edit:deadline"),
        ],
        [
            InlineKeyboardButton("👤 Sửa người nhận", callback_data="wizard_edit:assignee"),
        ],
        [
            InlineKeyboardButton("🔔 Sửa độ ưu tiên", callback_data="wizard_edit:priority"),
        ],
        [
            InlineKeyboardButton("« Quay lại", callback_data="wizard_edit:back"),
        ],
    ])


def wizard_cancel_keyboard() -> InlineKeyboardMarkup:
    """Cancel wizard button."""
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("❌ Hủy", callback_data="wizard_cancel")],
    ])


def task_type_filter_keyboard(current_filter: str = "all") -> InlineKeyboardMarkup:
    """Task type filter buttons (Individual/Group)."""
    # Mark current filter with checkmark
    ind_label = "✓ 👤 Cá nhân" if current_filter == "individual" else "👤 Cá nhân"
    grp_label = "✓ 👥 Nhóm" if current_filter == "group" else "👥 Nhóm"
    all_label = "✓ 📋 Tất cả" if current_filter == "all" else "📋 Tất cả"

    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton(all_label, callback_data="task_filter:all"),
            InlineKeyboardButton(ind_label, callback_data="task_filter:individual"),
            InlineKeyboardButton(grp_label, callback_data="task_filter:group"),
        ],
    ])


def bulk_delete_confirm_keyboard(action: str, count: int) -> InlineKeyboardMarkup:
    """Create bulk delete confirmation buttons."""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton(
                f"✅ Xác nhận xóa {count} việc",
                callback_data=f"bulk_delete:{action}:confirm"
            ),
        ],
        [
            InlineKeyboardButton("❌ Hủy", callback_data=f"bulk_delete:{action}:cancel"),
        ],
    ])
</file>

<file path="utils/messages.py">
"""
Vietnamese Messages
All user-facing messages in Vietnamese with proper diacritics
"""

# Command responses
MSG_START = """
Xin chào {name}!

Tôi là TeleTask Bot - hệ thống quản lý công việc qua Telegram.

Sử dụng các lệnh:
/taoviec - Tạo việc mới cho bản thân
/vieccanhan - Xem danh sách việc cá nhân
/thongtin - Xem thông tin tài khoản

Gõ /help để xem hướng dẫn chi tiết.
"""

MSG_START_GROUP = """
Xin chào {name}!

Tôi là TeleTask Bot - hệ thống quản lý công việc qua Telegram.

Sử dụng các lệnh:
/taoviec - Tạo việc mới cho bản thân
/giaoviec - Giao việc cho người khác
/vieccanhan - Xem danh sách việc cá nhân
/thongtin - Xem thông tin tài khoản

Gõ /help để xem hướng dẫn chi tiết.
"""

MSG_HELP = """
📖 HƯỚNG DẪN SỬ DỤNG TELETASK BOT

━━━━━ TẠO VIỆC ━━━━━
/taoviec - Tạo việc cá nhân (wizard)

Ví dụ:
  /taoviec Họp đội 14h30

━━━━━ VIỆC LẶP LẠI ━━━━━
/vieclaplai - Tạo việc lặp lại tự động
/danhsachvieclaplai - Xem danh sách việc lặp

Ví dụ:
  /vieclaplai Họp đội hàng tuần thứ 2 9h
  /vieclaplai Báo cáo hàng tháng ngày 1 10h

━━━━━ XEM VIỆC ━━━━━
/xemviec - Danh mục việc (menu)
/xemviec [mã] - Chi tiết việc
/viecdanhan - Việc được giao cho bạn
/timviec [từ khóa] - Tìm kiếm việc

━━━━━ CẬP NHẬT ━━━━━
/xong [mã] - Hoàn thành việc
/tiendo [mã] [%] - Cập nhật tiến độ
/xoa [mã] - Xóa việc (hoàn tác 10s)
/xoanhieu [mã1,mã2,...] - Xóa nhiều việc
/xoatatca - Xóa tất cả việc (hoàn tác 10s)

━━━━━ NHẮC VIỆC ━━━━━
/nhacviec [mã] [thời gian] - Đặt nhắc
/xemnhac - Xem nhắc đã đặt

━━━━━ THỐNG KÊ ━━━━━
/thongke - Thống kê tổng hợp
/thongketuan - Thống kê tuần này
/thongkethang - Thống kê tháng này
/viectrehan - Xem việc trễ hạn
/export - Xuất báo cáo (CSV/Excel/PDF)

━━━━━ TÍCH HỢP ━━━━━
/lichgoogle - Kết nối và cài đặt Google Calendar

━━━━━ TÀI KHOẢN ━━━━━
/menu - Menu tính năng (nút bấm)
/caidat - Cài đặt cá nhân (thông báo, múi giờ)
/thongtin - Thông tin tài khoản
/start - Bắt đầu sử dụng bot
/help - Xem hướng dẫn này

📖 Hướng dẫn chi tiết: https://teletask.haduyson.com
"""

MSG_HELP_GROUP = """
📖 HƯỚNG DẪN SỬ DỤNG TELETASK BOT

━━━━━ TẠO VIỆC ━━━━━
/taoviec - Tạo việc cá nhân (wizard)
/giaoviec - Giao việc cho người khác

Ví dụ:
  /taoviec Họp đội 14h30
  /giaoviec @nam Chuẩn bị slide ngày mai 10h

━━━━━ VIỆC LẶP LẠI ━━━━━
/vieclaplai - Tạo việc lặp lại tự động
/danhsachvieclaplai - Xem danh sách việc lặp

Ví dụ:
  /vieclaplai Họp đội hàng tuần thứ 2 9h
  /vieclaplai Báo cáo hàng tháng ngày 1 10h

━━━━━ XEM VIỆC ━━━━━
/xemviec - Danh mục việc (menu)
/xemviec [mã] - Chi tiết việc
/viecdagiao - Việc bạn đã giao
/viecdanhan - Việc được giao cho bạn
/timviec [từ khóa] - Tìm kiếm việc

━━━━━ CẬP NHẬT ━━━━━
/xong [mã] - Hoàn thành việc
/tiendo [mã] [%] - Cập nhật tiến độ
/xoa [mã] - Xóa việc (hoàn tác 10s)
/xoanhieu [mã1,mã2,...] - Xóa nhiều việc
/xoatatca - Xóa tất cả việc (hoàn tác 10s)

━━━━━ NHẮC VIỆC ━━━━━
/nhacviec [mã] [thời gian] - Đặt nhắc
/xemnhac - Xem nhắc đã đặt

━━━━━ THỐNG KÊ ━━━━━
/thongke - Thống kê tổng hợp
/thongketuan - Thống kê tuần này
/thongkethang - Thống kê tháng này
/viectrehan - Xem việc trễ hạn
/export - Xuất báo cáo (CSV/Excel/PDF)

━━━━━ TÍCH HỢP ━━━━━
/lichgoogle - Kết nối và cài đặt Google Calendar

━━━━━ TÀI KHOẢN ━━━━━
/menu - Menu tính năng (nút bấm)
/caidat - Cài đặt cá nhân (thông báo, múi giờ)
/thongtin - Thông tin tài khoản
/start - Bắt đầu sử dụng bot
/help - Xem hướng dẫn này

📖 Hướng dẫn chi tiết: https://teletask.haduyson.com
"""

MSG_INFO = """
Thông tin tài khoản

Tên: {name}
Username: @{username}
Telegram ID: {telegram_id}

THỐNG KÊ:
Tổng việc: {total_tasks}
Đang xử lý: {in_progress}
Hoàn thành: {completed}
Trễ hạn: {overdue}

Múi giờ: {timezone}
"""

# Task messages
MSG_TASK_CREATED = """
Đã tạo việc thành công!

{task_id}: {content}
Deadline: {deadline}
Ưu tiên: {priority}
"""

MSG_TASK_ASSIGNED = """
Đã giao việc thành công!

{task_id}: {content}
Người nhận: {assignee}
Deadline: {deadline}
"""

MSG_TASK_RECEIVED = """
Bạn có việc mới!

{task_id}: {content}
Từ: {creator}
Deadline: {deadline}

Trả lời /xong {task_id} khi hoàn thành.
"""

MSG_TASK_COMPLETED = """
Đã hoàn thành việc {task_id}!

{content}
Thời gian: {completed_at}
"""

MSG_TASK_DELETED = """
Đã xóa việc {task_id}.

Bấm nút bên dưới để hoàn tác (trong 30 giây).
"""

MSG_TASK_RESTORED = "Đã khôi phục việc {task_id}."

MSG_TASK_DETAIL = """
<b>{task_id}</b>: {content}

<b>Trạng thái:</b> {status}
<b>Tiến độ:</b> {progress}%
<b>Ưu tiên:</b> {priority}

<b>Người tạo:</b> {creator}
<b>Người nhận:</b> {assignee}
<b>Deadline:</b> {deadline}
{group_line}
<b>Tạo lúc:</b> {created_at}
<b>Cập nhật:</b> {updated_at}
"""

MSG_TASK_LIST = """
{title}

{tasks}

Trang {page}/{total_pages} | Tổng: {total}
"""

MSG_TASK_LIST_EMPTY = "Không có việc nào."

MSG_TASK_LIST_ITEM = "{icon} {task_id}: {content} - {deadline}"

# Reminder messages
MSG_REMINDER_24H = """
⏰ <b>Nhắc nhở:</b> Việc sắp đến hạn!

<b>{task_id}</b>: {content}
<b>Deadline:</b> {deadline}

Còn 24 giờ để hoàn thành.
"""

MSG_REMINDER_1H = """
🚨 <b>KHẨN CẤP:</b> Việc sắp hết hạn!

<b>{task_id}</b>: {content}
<b>Deadline:</b> {deadline}

Chỉ còn 1 giờ!
"""

MSG_REMINDER_OVERDUE = """
⚠️ <b>CẢNH BÁO:</b> Việc đã quá hạn!

<b>{task_id}</b>: {content}
<b>Deadline:</b> {deadline}

Vui lòng cập nhật trạng thái.
"""

# Error messages
ERR_NO_PERMISSION = "Bạn không có quyền thực hiện thao tác này."
ERR_NOT_FOUND = "Không tìm thấy mục được yêu cầu."
ERR_TASK_NOT_FOUND = "Không tìm thấy việc {task_id}."
ERR_USER_NOT_FOUND = "Không tìm thấy người dùng {user}."
ERR_INVALID_TIME = "Không thể hiểu thời gian '{time}'. Vui lòng dùng định dạng: 10h30, ngày mai 14h, 15/12 9h..."
ERR_NO_CONTENT = "Vui lòng nhập nội dung việc."
ERR_NO_ASSIGNEE = "Vui lòng chỉ định người nhận việc (@username hoặc reply tin nhắn)."
ERR_GROUP_ONLY = "Lệnh này chỉ hoạt động trong nhóm."
ERR_PRIVATE_ONLY = "Lệnh này chỉ hoạt động trong chat riêng."
ERR_UNDO_EXPIRED = "Hết thời gian hoàn tác."
ERR_ALREADY_COMPLETED = "Việc {task_id} đã hoàn thành rồi."
ERR_DATABASE = "Lỗi hệ thống. Vui lòng thử lại sau."

# Status labels
STATUS_PENDING = "Chờ xử lý"
STATUS_IN_PROGRESS = "Đang làm"
STATUS_COMPLETED = "Hoàn thành"
STATUS_CANCELLED = "Đã huỷ"

# Priority labels
PRIORITY_LOW = "Thấp"
PRIORITY_NORMAL = "Bình thường"
PRIORITY_HIGH = "Cao"
PRIORITY_URGENT = "Khẩn cấp"

# Status icons
ICON_PENDING = "⏳"
ICON_IN_PROGRESS = "🔄"
ICON_COMPLETED = "✅"
ICON_OVERDUE = "🔴"
ICON_URGENT = "🚨"
ICON_HIGH = "🔶"
</file>

<file path="utils/validators.py">
"""
Input Validators
Validate user input for task management
"""

import re
from typing import List, Optional, Tuple


def extract_mentions(text: str) -> Tuple[List[str], str]:
    """
    Extract @mentions from text.

    Args:
        text: Input text

    Returns:
        Tuple of (list of usernames without @, remaining text)
    """
    mentions = re.findall(r"@(\w+)", text)
    remaining = re.sub(r"@\w+", "", text).strip()
    remaining = re.sub(r"\s+", " ", remaining)  # Normalize whitespace
    return mentions, remaining


def validate_task_content(content: str) -> Tuple[bool, str]:
    """
    Validate task content.

    Args:
        content: Task content text

    Returns:
        Tuple of (is_valid, error_message_or_cleaned_content)
    """
    if not content:
        return False, "Nội dung việc không được để trống."

    content = content.strip()

    if len(content) < 2:
        return False, "Nội dung việc quá ngắn (tối thiểu 2 ký tự)."

    if len(content) > 500:
        return False, "Nội dung việc quá dài (tối đa 500 ký tự)."

    return True, content


def validate_priority(priority: str) -> Tuple[bool, str]:
    """
    Validate and normalize priority.

    Args:
        priority: Priority string

    Returns:
        Tuple of (is_valid, normalized_priority)
    """
    priority = priority.lower().strip()

    # Vietnamese mappings
    priority_map = {
        "thap": "low",
        "binh thuong": "normal",
        "bt": "normal",
        "cao": "high",
        "khan cap": "urgent",
        "khancap": "urgent",
        "kc": "urgent",
        # English
        "low": "low",
        "normal": "normal",
        "high": "high",
        "urgent": "urgent",
    }

    if priority in priority_map:
        return True, priority_map[priority]

    return False, "normal"  # Default to normal


def validate_status(status: str) -> Tuple[bool, str]:
    """
    Validate and normalize status.

    Args:
        status: Status string

    Returns:
        Tuple of (is_valid, normalized_status)
    """
    status = status.lower().strip()

    status_map = {
        # Vietnamese
        "cho xu ly": "pending",
        "chua lam": "pending",
        "dang lam": "in_progress",
        "hoan thanh": "completed",
        "xong": "completed",
        "da huy": "cancelled",
        "huy": "cancelled",
        # English
        "pending": "pending",
        "in_progress": "in_progress",
        "completed": "completed",
        "cancelled": "cancelled",
    }

    if status in status_map:
        return True, status_map[status]

    return False, "pending"


def validate_progress(progress: str) -> Tuple[bool, int]:
    """
    Validate progress percentage.

    Args:
        progress: Progress string (e.g., "50", "50%")

    Returns:
        Tuple of (is_valid, progress_int)
    """
    # Remove % sign
    progress = progress.replace("%", "").strip()

    try:
        value = int(progress)
        if 0 <= value <= 100:
            return True, value
        return False, 0
    except ValueError:
        return False, 0


def parse_task_command(text: str) -> dict:
    """
    Parse task creation command.

    Format: [content] [time expression]

    Args:
        text: Command text after /taoviec

    Returns:
        Dict with parsed fields
    """
    result = {
        "content": "",
        "deadline_text": "",
        "mentions": [],
        "priority": "normal",
    }

    if not text:
        return result

    # Extract mentions first
    mentions, text = extract_mentions(text)
    result["mentions"] = mentions

    # Check for priority keywords
    priority_patterns = [
        (r"\b(khan\s*cap|kc)\b", "urgent"),
        (r"\b(uu\s*tien\s*cao|cao)\b", "high"),
        (r"\b(uu\s*tien\s*thap|thap)\b", "low"),
    ]

    for pattern, priority in priority_patterns:
        if re.search(pattern, text, re.IGNORECASE):
            result["priority"] = priority
            text = re.sub(pattern, "", text, flags=re.IGNORECASE)
            break

    result["content"] = text.strip()
    return result


def is_valid_public_id(public_id: str) -> bool:
    """
    Check if string is a valid task public ID.

    Format: P-XXXX or G-XXXX

    Args:
        public_id: Task ID string

    Returns:
        True if valid format
    """
    pattern = r"^[PG]-\d{4}$"
    return bool(re.match(pattern, public_id.upper()))


def sanitize_html(text: str) -> str:
    """
    Sanitize text for HTML message mode.

    Args:
        text: Input text

    Returns:
        Sanitized text
    """
    replacements = [
        ("&", "&amp;"),
        ("<", "&lt;"),
        (">", "&gt;"),
    ]
    for old, new in replacements:
        text = text.replace(old, new)
    return text
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/
dist/
bin/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# package manager
package-lock.json
yarn.lock
pnpm-lock.yaml

# semantic-release
.nyc_output

# env files (can opt-in for committing if needed)
.env*
!.env.example

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# flutter
.dart_tool
build
GoogleService-Info.plist

repomix-output.xml
.serena/cache
plans/**/*
!plans/templates/*
screenshots/*
docs/screenshots/*
docs/journals/*
docs/research/*
logs.txt
test-ck
__pycache__
prompt.md

# Gemini CLI settings (symlink to .claude/.mcp.json)
.gemini/settings.json
.claude/settings.bak.json
</file>

<file path=".repomixignore">
docs/*
plans/*
assets/*
dist/*
coverage/*
build/*
ios/*
android/*
tests/*
__tests__/*
__pycache__/*
node_modules/*

.opencode/*
.claude/*
.serena/*
.pnpm-store/*
.github/*
.dart_tool/*
.idea/*
.husky/*
.venv/*
</file>

<file path="alembic.ini">
# Alembic Configuration
# TeleTask Bot Database Migrations

[alembic]
# Path to migration scripts
script_location = database/migrations

# SQLAlchemy URL - loaded from environment
# sqlalchemy.url = driver://user:pass@localhost/dbname
# Set via DATABASE_URL environment variable

# Template for new migration files
file_template = %%(year)d%%(month).2d%%(day).2d_%%(hour).2d%%(minute).2d_%%(rev)s_%%(slug)s

# Timezone for revision timestamps
timezone = Asia/Ho_Chi_Minh

# Max length for revision IDs
truncate_slug_length = 40

# Enable revision ID in script names
revision_environment = false

# Source path for version locations
sourceless = false

# Auto-generate comments
output_encoding = utf-8

[post_write_hooks]
# Hooks to run after migration file creation

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console
qualname =

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers =
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s
datefmt = %H:%M:%S
</file>

<file path="bot.py">
#!/usr/bin/env python3
"""
TeleTask Bot - Entry Point
Vietnamese Task Management Telegram Bot

Usage:
    python bot.py

Environment Variables:
    BOT_TOKEN: Telegram bot token from @BotFather
    DATABASE_URL: PostgreSQL connection string
    See .env.example for full configuration
"""

import asyncio
import logging
import os
import sys
from datetime import datetime
from pathlib import Path

from dotenv import load_dotenv
from telegram import Update
from telegram.ext import Application

# Load environment variables
load_dotenv()

# Configure logging
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")
LOG_FILE = os.getenv("LOG_FILE")

logging.basicConfig(
    level=getattr(logging, LOG_LEVEL.upper(), logging.INFO),
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.StreamHandler(sys.stdout),
        *(
            [logging.FileHandler(LOG_FILE)]
            if LOG_FILE
            else []
        ),
    ],
)
logger = logging.getLogger(__name__)


async def post_init(application: Application) -> None:
    """Post-initialization hook to set bot commands."""
    from telegram import BotCommandScopeAllPrivateChats, BotCommandScopeAllGroupChats

    # Commands for private chat (no giaoviec, viecdagiao)
    # Quick actions prioritized at top for easy access
    private_commands = [
        ("menu", "📋 Menu thao tác nhanh"),
        ("taoviec", "➕ Tạo việc mới"),
        ("xemviec", "👁️ Xem việc"),
        ("xoa", "🗑️ Xóa việc"),
        ("thongke", "📊 Thống kê"),
        ("start", "Bắt đầu sử dụng bot"),
        ("help", "Xem hướng dẫn sử dụng"),
        ("vieccanhan", "Xem danh sách việc cá nhân"),
        ("xong", "Đánh dấu việc hoàn thành"),
        ("tiendo", "Cập nhật tiến độ việc"),
        ("timviec", "Tìm kiếm việc"),
        ("nhacviec", "Đặt nhắc việc tự động"),
        ("vieclaplai", "Tạo việc lặp lại tự động"),
        ("danhsachvieclaplai", "Xem danh sách việc lặp lại"),
        ("thongketuan", "Xem thống kê tuần này"),
        ("thongkethang", "Xem thống kê tháng này"),
        ("viectrehan", "Xem việc trễ hạn"),
        ("export", "Xuất báo cáo thống kê"),
        ("thongtin", "Xem thông tin tài khoản"),
        ("lichgoogle", "Kết nối Google Calendar"),
        ("caidat", "Cài đặt thông báo và múi giờ"),
    ]

    # Commands for group chat (includes giaoviec, viecdagiao)
    # Quick actions prioritized at top for easy access
    group_commands = [
        ("menu", "📋 Menu thao tác nhanh"),
        ("taoviec", "➕ Tạo việc mới"),
        ("giaoviec", "👥 Giao việc cho người khác"),
        ("xemviec", "👁️ Xem việc"),
        ("xoa", "🗑️ Xóa việc"),
        ("thongke", "📊 Thống kê"),
        ("start", "Bắt đầu sử dụng bot"),
        ("help", "Xem hướng dẫn sử dụng"),
        ("vieccanhan", "Xem danh sách việc cá nhân"),
        ("viecdagiao", "Xem việc bạn đã giao"),
        ("xong", "Đánh dấu việc hoàn thành"),
        ("tiendo", "Cập nhật tiến độ việc"),
        ("timviec", "Tìm kiếm việc"),
        ("nhacviec", "Đặt nhắc việc tự động"),
        ("vieclaplai", "Tạo việc lặp lại tự động"),
        ("danhsachvieclaplai", "Xem danh sách việc lặp lại"),
        ("thongketuan", "Xem thống kê tuần này"),
        ("thongkethang", "Xem thống kê tháng này"),
        ("viectrehan", "Xem việc trễ hạn"),
        ("export", "Xuất báo cáo thống kê"),
        ("thongtin", "Xem thông tin tài khoản"),
        ("lichgoogle", "Kết nối Google Calendar"),
        ("caidat", "Cài đặt thông báo và múi giờ"),
    ]

    # Set different commands for private and group chats
    await application.bot.set_my_commands(private_commands, scope=BotCommandScopeAllPrivateChats())
    await application.bot.set_my_commands(group_commands, scope=BotCommandScopeAllGroupChats())
    logger.info("Bot commands registered (private + group)")


async def main() -> None:
    """Main entry point for the bot."""
    logger.info("=" * 60)
    logger.info("TeleTask Bot Starting...")
    logger.info("=" * 60)

    # Validate required environment variables
    bot_token = os.getenv("BOT_TOKEN")
    if not bot_token:
        logger.error("BOT_TOKEN environment variable is required")
        sys.exit(1)

    database_url = os.getenv("DATABASE_URL")
    if not database_url:
        logger.error("DATABASE_URL environment variable is required")
        sys.exit(1)

    logger.info(f"Bot Name: {os.getenv('BOT_NAME', 'TeleTask')}")
    logger.info(f"Timezone: {os.getenv('TZ', 'UTC')}")
    logger.info(f"Log Level: {LOG_LEVEL}")

    # Initialize database connection
    from database.connection import init_database, close_database
    logger.info("Connecting to database...")
    await init_database(database_url)
    logger.info("Database connected")

    # Build application
    application = (
        Application.builder()
        .token(bot_token)
        .post_init(post_init)
        .build()
    )

    # Register handlers
    from handlers import register_handlers
    register_handlers(application)
    application.add_error_handler(error_handler)
    logger.info("Handlers registered")

    # Initialize reminder scheduler
    from database import get_db
    from scheduler import init_scheduler, reminder_scheduler, init_report_scheduler
    db = get_db()
    init_scheduler(application.bot, db)
    logger.info("Reminder scheduler started")

    # Initialize report scheduler (uses same APScheduler instance)
    init_report_scheduler(reminder_scheduler.scheduler, application.bot, db)
    logger.info("Report scheduler started")

    # Initialize monitoring (optional - only if admin IDs configured)
    health_server = None
    alert_service = None
    resource_monitor = None
    start_time = datetime.now()

    admin_ids_str = os.getenv('ADMIN_IDS', '')
    # Support both personal IDs (positive) and group IDs (negative)
    admin_ids = []
    for x in admin_ids_str.split(','):
        x = x.strip()
        if x.lstrip('-').isdigit() and x:
            admin_ids.append(int(x))

    if admin_ids:
        try:
            from monitoring import HealthCheckServer, AlertService, ResourceMonitor

            # Initialize alert service
            alert_service = AlertService(application.bot, admin_ids)

            # Start health check server
            health_port = int(os.getenv('HEALTH_PORT', 8080))
            health_server = HealthCheckServer(application, db, port=health_port)
            await health_server.start()

            # Start resource monitor
            resource_monitor = ResourceMonitor(db, alert_service, start_time)
            await resource_monitor.start()

            # Store alert service in bot_data for error handler
            application.bot_data['alert_service'] = alert_service

            # Send startup alert
            await alert_service.alert_bot_start()

            logger.info(f"Monitoring started (health port: {health_port}, admins: {len(admin_ids)})")
        except ImportError as e:
            logger.warning(f"Monitoring not available: {e}")
        except Exception as e:
            logger.error(f"Failed to start monitoring: {e}")
    else:
        logger.info("Monitoring disabled (no ADMIN_IDS configured)")

    # Start OAuth callback server (for Google Calendar)
    oauth_runner = None
    if os.getenv("GOOGLE_CALENDAR_ENABLED", "false").lower() == "true":
        try:
            from services.oauth_callback import start_oauth_server
            oauth_runner = await start_oauth_server()
        except Exception as e:
            logger.warning(f"OAuth callback server not started: {e}")

    logger.info("Bot initialization complete")
    logger.info("Starting polling...")

    try:
        # Start polling
        await application.initialize()
        await application.start()
        await application.updater.start_polling(
            allowed_updates=Update.ALL_TYPES,
            drop_pending_updates=True,
        )

        logger.info("Bot is running. Press Ctrl+C to stop.")

        # Keep running until interrupted
        stop_event = asyncio.Event()
        await stop_event.wait()

    except asyncio.CancelledError:
        logger.info("Bot stopping...")
    finally:
        # Cleanup
        logger.info("Shutting down...")

        # Stop monitoring
        if resource_monitor:
            await resource_monitor.stop()
        if health_server:
            await health_server.stop()

        # Stop OAuth server
        if oauth_runner:
            from services.oauth_callback import stop_oauth_server
            await stop_oauth_server(oauth_runner)

        from scheduler import stop_scheduler
        stop_scheduler()
        await application.updater.stop()
        await application.stop()
        await application.shutdown()
        await close_database()
        logger.info("Cleanup complete")


async def error_handler(update, context):
    """Global error handler with monitoring integration."""
    error = context.error
    logger.error(f"Error handling update: {error}", exc_info=error)

    # Record error metric
    try:
        from monitoring.metrics import record_error
        record_error(type(error).__name__)
    except ImportError:
        pass

    # Send alert to admins
    alert_service = context.application.bot_data.get('alert_service')
    if alert_service:
        try:
            await alert_service.alert_bot_crash(error)
        except Exception as e:
            logger.warning(f"Failed to send error alert: {e}")


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("Bot stopped by user")
    except Exception as e:
        logger.exception(f"Bot crashed: {e}")
        sys.exit(1)
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Role & Responsibilities

Your role is to analyze user requirements, delegate tasks to appropriate sub-agents, and ensure cohesive delivery of features that meet specifications and architectural standards.

## Workflows

- Primary workflow: `./.claude/workflows/primary-workflow.md`
- Development rules: `./.claude/workflows/development-rules.md`
- Orchestration protocols: `./.claude/workflows/orchestration-protocol.md`
- Documentation management: `./.claude/workflows/documentation-management.md`
- And other workflows: `./.claude/workflows/*`

**IMPORTANT:** Analyze the skills catalog and activate the skills that are needed for the task during the process.
**IMPORTANT:** You must follow strictly the development rules in `./.claude/workflows/development-rules.md` file.
**IMPORTANT:** Before you plan or proceed any implementation, always read the `./README.md` file first to get context.
**IMPORTANT:** Sacrifice grammar for the sake of concision when writing reports.
**IMPORTANT:** In reports, list any unresolved questions at the end, if any.
**IMPORTANT**: Date format is configured in `.ck.json` and injected by session hooks via `$CK_PLAN_DATE_FORMAT` env var. Use this format for plan/report naming.

## Documentation Management

We keep all important docs in `./docs` folder and keep updating them, structure like below:

```
./docs
├── project-overview-pdr.md
├── code-standards.md
├── codebase-summary.md
├── design-guidelines.md
├── deployment-guide.md
├── system-architecture.md
└── project-roadmap.md
```

**IMPORTANT:** *MUST READ* and *MUST COMPLY* all *INSTRUCTIONS* in project `./CLAUDE.md`, especially *WORKFLOWS* section is *CRITICALLY IMPORTANT*, this rule is *MANDATORY. NON-NEGOTIABLE. NO EXCEPTIONS. MUST REMEMBER AT ALL TIMES!!!*
</file>

<file path="ecosystem.config.js">
/**
 * PM2 Ecosystem Configuration
 * TeleTask Bot Template
 *
 * This file is auto-generated when creating a new bot.
 * Values like BOT_ID and paths will be replaced during bot creation.
 */

module.exports = {
    apps: [{
        // Bot identification
        name: 'BOT_ID_PLACEHOLDER',

        // Entry point
        script: 'bot.py',
        interpreter: 'python3.11',

        // Working directory
        cwd: '/home/botpanel/bots/BOT_ID_PLACEHOLDER',

        // Environment
        env: {
            NODE_ENV: 'production'
        },

        // Process management
        watch: false,
        autorestart: true,
        max_restarts: 10,
        restart_delay: 5000,
        kill_timeout: 3000,

        // Logging
        log_file: '/home/botpanel/logs/BOT_ID_PLACEHOLDER.log',
        error_file: '/home/botpanel/logs/BOT_ID_PLACEHOLDER-error.log',
        out_file: '/home/botpanel/logs/BOT_ID_PLACEHOLDER-out.log',
        time: true,
        log_date_format: 'YYYY-MM-DD HH:mm:ss Z',

        // Performance
        max_memory_restart: '200M',

        // Instance
        instances: 1,
        exec_mode: 'fork'
    }]
};
</file>

<file path="requirements.txt">
# TeleTask Bot Dependencies
# Generated by install.sh

# Telegram Bot Framework
python-telegram-bot>=21.0

# Database
asyncpg>=0.29.0
psycopg2-binary>=2.9.0
sqlalchemy>=2.0.0

# Migrations
alembic>=1.13.0

# Scheduler
APScheduler>=3.10.0

# Environment
python-dotenv>=1.0.0

# HTTP Client
aiohttp>=3.9.0

# Timezone
pytz>=2024.1

# Date utilities
python-dateutil>=2.8.0

# Cache (optional)
redis>=5.0.0

# Monitoring (optional)
prometheus-client>=0.19.0

# Google Calendar (optional)
google-api-python-client>=2.100.0
google-auth>=2.23.0
google-auth-oauthlib>=1.1.0

# Export/Report generation
openpyxl>=3.1.0
matplotlib>=3.8.0
reportlab>=4.0.0

# System monitoring
psutil>=5.9.0
</file>

</files>
